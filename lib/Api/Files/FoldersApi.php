<?php
/*
 * (c) Copyright Ascensio System SIA 2025
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * onlyoffice/docspace-api-sdk
 *
 * A simple PHP SDK for integrating with the ONLYOFFICE DocSpace API
 *
 * The version of the OpenAPI document: 3.6.0
 * Contact: support@onlyoffice.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */


namespace OpenAPI\Client\Api\Files;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 *  Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FoldersApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'checkUpload' => [
            'application/json',
        ],
        'createFolder' => [
            'application/json',
        ],
        'createFolderPrimaryExternalLink' => [
            'application/json',
        ],
        'createReportFolderHistory' => [
            'application/json',
        ],
        'deleteFolder' => [
            'application/json',
        ],
        'getFavoritesFolder' => [
            'application/json',
        ],
        'getFilesUsedSpace' => [
            'application/json',
        ],
        'getFolder' => [
            'application/json',
        ],
        'getFolderByFolderId' => [
            'application/json',
        ],
        'getFolderHistory' => [
            'application/json',
        ],
        'getFolderInfo' => [
            'application/json',
        ],
        'getFolderLinks' => [
            'application/json',
        ],
        'getFolderPath' => [
            'application/json',
        ],
        'getFolderPrimaryExternalLink' => [
            'application/json',
        ],
        'getFolders' => [
            'application/json',
        ],
        'getMyFolder' => [
            'application/json',
        ],
        'getNewFolderItems' => [
            'application/json',
        ],
        'getPrivacyFolder' => [
            'application/json',
        ],
        'getRecentFolder' => [
            'application/json',
        ],
        'getRootFolders' => [
            'application/json',
        ],
        'getTrashFolder' => [
            'application/json',
        ],
        'insertFile' => [
            'multipart/form-data',
        ],
        'insertFileToMyFromBody' => [
            'multipart/form-data',
        ],
        'renameFolder' => [
            'application/json',
        ],
        'setFolderOrder' => [
            'application/json',
        ],
        'setFolderPrimaryExternalLink' => [
            'application/json',
        ],
        'uploadFile' => [
            'application/json',
        ],
        'uploadFileToMy' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    private ?string $fields = null;

    public function withFields(string $fields): self
    {
        $this->fields = $fields;
        return $this;
    }

    /**
     * Operation checkUpload
     *
     * Check file uploads
     *
     * REST API Reference for checkUpload Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-upload/
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\CheckUploadRequest $check_upload_request The request parameters for checking file uploads. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUpload'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\STRINGArrayWrapper
     */
    public function checkUpload($folder_id, $check_upload_request, string $contentType = self::contentTypes['checkUpload'][0])
    {
        list($response) = $this->checkUploadWithHttpInfo($folder_id, $check_upload_request, $contentType);
        return $response;
    }

    /**
     * Operation checkUploadWithHttpInfo
     *
     * Check file uploads
     *
     * REST API Reference for checkUpload Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-upload/
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\CheckUploadRequest $check_upload_request The request parameters for checking file uploads. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUpload'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\STRINGArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkUploadWithHttpInfo($folder_id, $check_upload_request, string $contentType = self::contentTypes['checkUpload'][0])
    {
        $request = $this->checkUploadRequest($folder_id, $check_upload_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\STRINGArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\STRINGArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\STRINGArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkUploadAsync
     *
     * Check file uploads
     *
     * REST API Reference for checkUpload Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-upload/
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\CheckUploadRequest $check_upload_request The request parameters for checking file uploads. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkUploadAsync($folder_id, $check_upload_request, string $contentType = self::contentTypes['checkUpload'][0])
    {
        return $this->checkUploadAsyncWithHttpInfo($folder_id, $check_upload_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkUploadAsyncWithHttpInfo
     *
     * Check file uploads
     *
     * REST API Reference for checkUpload Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-upload/
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\CheckUploadRequest $check_upload_request The request parameters for checking file uploads. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkUploadAsyncWithHttpInfo($folder_id, $check_upload_request, string $contentType = self::contentTypes['checkUpload'][0])
    {
        $returnType = '\OpenAPI\Client\Model\STRINGArrayWrapper';
        $request = $this->checkUploadRequest($folder_id, $check_upload_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkUpload'
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\CheckUploadRequest $check_upload_request The request parameters for checking file uploads. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkUpload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkUploadRequest($folder_id, $check_upload_request, string $contentType = self::contentTypes['checkUpload'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling checkUpload'
            );
        }

        // verify the required parameter 'check_upload_request' is set
        if ($check_upload_request === null || (is_array($check_upload_request) && count($check_upload_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $check_upload_request when calling checkUpload'
            );
        }


        $resourcePath = '/api/2.0/files/{folderId}/upload/check';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($check_upload_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($check_upload_request));
            } else {
                $httpBody = $check_upload_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFolder
     *
     * Create a folder
     *
     * REST API Reference for createFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-folder/
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function createFolder($folder_id, $create_folder, string $contentType = self::contentTypes['createFolder'][0])
    {
        list($response) = $this->createFolderWithHttpInfo($folder_id, $create_folder, $contentType);
        return $response;
    }

    /**
     * Operation createFolderWithHttpInfo
     *
     * Create a folder
     *
     * REST API Reference for createFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-folder/
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFolderWithHttpInfo($folder_id, $create_folder, string $contentType = self::contentTypes['createFolder'][0])
    {
        $request = $this->createFolderRequest($folder_id, $create_folder, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFolderAsync
     *
     * Create a folder
     *
     * REST API Reference for createFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-folder/
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderAsync($folder_id, $create_folder, string $contentType = self::contentTypes['createFolder'][0])
    {
        return $this->createFolderAsyncWithHttpInfo($folder_id, $create_folder, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFolderAsyncWithHttpInfo
     *
     * Create a folder
     *
     * REST API Reference for createFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-folder/
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderAsyncWithHttpInfo($folder_id, $create_folder, string $contentType = self::contentTypes['createFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->createFolderRequest($folder_id, $create_folder, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFolder'
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFolderRequest($folder_id, $create_folder, string $contentType = self::contentTypes['createFolder'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling createFolder'
            );
        }

        // verify the required parameter 'create_folder' is set
        if ($create_folder === null || (is_array($create_folder) && count($create_folder) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_folder when calling createFolder'
            );
        }


        $resourcePath = '/api/2.0/files/folder/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_folder)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_folder));
            } else {
                $httpBody = $create_folder;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFolderPrimaryExternalLink
     *
     * Create primary external link
     *
     * REST API Reference for createFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-folder-primary-external-link/
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareWrapper
     */
    public function createFolderPrimaryExternalLink($id, $folder_link_request, string $contentType = self::contentTypes['createFolderPrimaryExternalLink'][0])
    {
        list($response) = $this->createFolderPrimaryExternalLinkWithHttpInfo($id, $folder_link_request, $contentType);
        return $response;
    }

    /**
     * Operation createFolderPrimaryExternalLinkWithHttpInfo
     *
     * Create primary external link
     *
     * REST API Reference for createFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-folder-primary-external-link/
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFolderPrimaryExternalLinkWithHttpInfo($id, $folder_link_request, string $contentType = self::contentTypes['createFolderPrimaryExternalLink'][0])
    {
        $request = $this->createFolderPrimaryExternalLinkRequest($id, $folder_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFolderPrimaryExternalLinkAsync
     *
     * Create primary external link
     *
     * REST API Reference for createFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-folder-primary-external-link/
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderPrimaryExternalLinkAsync($id, $folder_link_request, string $contentType = self::contentTypes['createFolderPrimaryExternalLink'][0])
    {
        return $this->createFolderPrimaryExternalLinkAsyncWithHttpInfo($id, $folder_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFolderPrimaryExternalLinkAsyncWithHttpInfo
     *
     * Create primary external link
     *
     * REST API Reference for createFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-folder-primary-external-link/
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFolderPrimaryExternalLinkAsyncWithHttpInfo($id, $folder_link_request, string $contentType = self::contentTypes['createFolderPrimaryExternalLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareWrapper';
        $request = $this->createFolderPrimaryExternalLinkRequest($id, $folder_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFolderPrimaryExternalLink'
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFolderPrimaryExternalLinkRequest($id, $folder_link_request, string $contentType = self::contentTypes['createFolderPrimaryExternalLink'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createFolderPrimaryExternalLink'
            );
        }

        // verify the required parameter 'folder_link_request' is set
        if ($folder_link_request === null || (is_array($folder_link_request) && count($folder_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_link_request when calling createFolderPrimaryExternalLink'
            );
        }


        $resourcePath = '/api/2.0/files/folder/{id}/link';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($folder_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($folder_link_request));
            } else {
                $httpBody = $folder_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createReportFolderHistory
     *
     * Generates folder history
     *
     * REST API Reference for createReportFolderHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-report-folder-history/
     *
     * @param  int $folder_id folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createReportFolderHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringWrapper
     */
    public function createReportFolderHistory($folder_id, string $contentType = self::contentTypes['createReportFolderHistory'][0])
    {
        list($response) = $this->createReportFolderHistoryWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation createReportFolderHistoryWithHttpInfo
     *
     * Generates folder history
     *
     * REST API Reference for createReportFolderHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-report-folder-history/
     *
     * @param  int $folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createReportFolderHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createReportFolderHistoryWithHttpInfo($folder_id, string $contentType = self::contentTypes['createReportFolderHistory'][0])
    {
        $request = $this->createReportFolderHistoryRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createReportFolderHistoryAsync
     *
     * Generates folder history
     *
     * REST API Reference for createReportFolderHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-report-folder-history/
     *
     * @param  int $folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createReportFolderHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createReportFolderHistoryAsync($folder_id, string $contentType = self::contentTypes['createReportFolderHistory'][0])
    {
        return $this->createReportFolderHistoryAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createReportFolderHistoryAsyncWithHttpInfo
     *
     * Generates folder history
     *
     * REST API Reference for createReportFolderHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-report-folder-history/
     *
     * @param  int $folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createReportFolderHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createReportFolderHistoryAsyncWithHttpInfo($folder_id, string $contentType = self::contentTypes['createReportFolderHistory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StringWrapper';
        $request = $this->createReportFolderHistoryRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createReportFolderHistory'
     *
     * @param  int $folder_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createReportFolderHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createReportFolderHistoryRequest($folder_id, string $contentType = self::contentTypes['createReportFolderHistory'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling createReportFolderHistory'
            );
        }


        $resourcePath = '/api/2.0/files/folder/{folderId}/log/report';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFolder
     *
     * Delete a folder
     *
     * REST API Reference for deleteFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-folder/
     *
     * @param  int $folder_id The folder ID to delete. (required)
     * @param  \OpenAPI\Client\Model\DeleteFolder $delete_folder The parameters for deleting a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function deleteFolder($folder_id, $delete_folder, string $contentType = self::contentTypes['deleteFolder'][0])
    {
        list($response) = $this->deleteFolderWithHttpInfo($folder_id, $delete_folder, $contentType);
        return $response;
    }

    /**
     * Operation deleteFolderWithHttpInfo
     *
     * Delete a folder
     *
     * REST API Reference for deleteFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-folder/
     *
     * @param  int $folder_id The folder ID to delete. (required)
     * @param  \OpenAPI\Client\Model\DeleteFolder $delete_folder The parameters for deleting a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFolderWithHttpInfo($folder_id, $delete_folder, string $contentType = self::contentTypes['deleteFolder'][0])
    {
        $request = $this->deleteFolderRequest($folder_id, $delete_folder, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFolderAsync
     *
     * Delete a folder
     *
     * REST API Reference for deleteFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-folder/
     *
     * @param  int $folder_id The folder ID to delete. (required)
     * @param  \OpenAPI\Client\Model\DeleteFolder $delete_folder The parameters for deleting a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsync($folder_id, $delete_folder, string $contentType = self::contentTypes['deleteFolder'][0])
    {
        return $this->deleteFolderAsyncWithHttpInfo($folder_id, $delete_folder, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFolderAsyncWithHttpInfo
     *
     * Delete a folder
     *
     * REST API Reference for deleteFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-folder/
     *
     * @param  int $folder_id The folder ID to delete. (required)
     * @param  \OpenAPI\Client\Model\DeleteFolder $delete_folder The parameters for deleting a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFolderAsyncWithHttpInfo($folder_id, $delete_folder, string $contentType = self::contentTypes['deleteFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->deleteFolderRequest($folder_id, $delete_folder, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFolder'
     *
     * @param  int $folder_id The folder ID to delete. (required)
     * @param  \OpenAPI\Client\Model\DeleteFolder $delete_folder The parameters for deleting a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFolderRequest($folder_id, $delete_folder, string $contentType = self::contentTypes['deleteFolder'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling deleteFolder'
            );
        }

        // verify the required parameter 'delete_folder' is set
        if ($delete_folder === null || (is_array($delete_folder) && count($delete_folder) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delete_folder when calling deleteFolder'
            );
        }


        $resourcePath = '/api/2.0/files/folder/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($delete_folder)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($delete_folder));
            } else {
                $httpBody = $delete_folder;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFavoritesFolder
     *
     * Get the Favorites section
     *
     * REST API Reference for getFavoritesFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-favorites-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavoritesFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderContentIntegerWrapper
     */
    public function getFavoritesFolder($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getFavoritesFolder'][0])
    {
        list($response) = $this->getFavoritesFolderWithHttpInfo($user_id_or_group_id, $filter_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);
        return $response;
    }

    /**
     * Operation getFavoritesFolderWithHttpInfo
     *
     * Get the Favorites section
     *
     * REST API Reference for getFavoritesFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-favorites-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavoritesFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderContentIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFavoritesFolderWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getFavoritesFolder'][0])
    {
        $request = $this->getFavoritesFolderRequest($user_id_or_group_id, $filter_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFavoritesFolderAsync
     *
     * Get the Favorites section
     *
     * REST API Reference for getFavoritesFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-favorites-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavoritesFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFavoritesFolderAsync($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getFavoritesFolder'][0])
    {
        return $this->getFavoritesFolderAsyncWithHttpInfo($user_id_or_group_id, $filter_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFavoritesFolderAsyncWithHttpInfo
     *
     * Get the Favorites section
     *
     * REST API Reference for getFavoritesFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-favorites-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavoritesFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFavoritesFolderAsyncWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getFavoritesFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderContentIntegerWrapper';
        $request = $this->getFavoritesFolderRequest($user_id_or_group_id, $filter_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFavoritesFolder'
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFavoritesFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFavoritesFolderRequest($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getFavoritesFolder'][0])
    {



        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getFavoritesFolder, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getFavoritesFolder, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/2.0/files/@favorites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id_or_group_id,
            'userIdOrGroupId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_type,
            'filterType', // param base name
            'FilterType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        if ($this->fields !== null) {
            $headerParams['fields'] = $this->fields;
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFilesUsedSpace
     *
     * Get used space of files
     *
     * REST API Reference for getFilesUsedSpace Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-used-space/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesUsedSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FilesStatisticsResultWrapper
     */
    public function getFilesUsedSpace(string $contentType = self::contentTypes['getFilesUsedSpace'][0])
    {
        list($response) = $this->getFilesUsedSpaceWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getFilesUsedSpaceWithHttpInfo
     *
     * Get used space of files
     *
     * REST API Reference for getFilesUsedSpace Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-used-space/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesUsedSpace'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FilesStatisticsResultWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesUsedSpaceWithHttpInfo(string $contentType = self::contentTypes['getFilesUsedSpace'][0])
    {
        $request = $this->getFilesUsedSpaceRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FilesStatisticsResultWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FilesStatisticsResultWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FilesStatisticsResultWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFilesUsedSpaceAsync
     *
     * Get used space of files
     *
     * REST API Reference for getFilesUsedSpace Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-used-space/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesUsedSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesUsedSpaceAsync(string $contentType = self::contentTypes['getFilesUsedSpace'][0])
    {
        return $this->getFilesUsedSpaceAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesUsedSpaceAsyncWithHttpInfo
     *
     * Get used space of files
     *
     * REST API Reference for getFilesUsedSpace Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-used-space/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesUsedSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesUsedSpaceAsyncWithHttpInfo(string $contentType = self::contentTypes['getFilesUsedSpace'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FilesStatisticsResultWrapper';
        $request = $this->getFilesUsedSpaceRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFilesUsedSpace'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesUsedSpace'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFilesUsedSpaceRequest(string $contentType = self::contentTypes['getFilesUsedSpace'][0])
    {


        $resourcePath = '/api/2.0/files/filesusedspace';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolder
     *
     * Get folder form filter
     *
     * REST API Reference for getFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FormsItemArrayWrapper
     */
    public function getFolder($folder_id, string $contentType = self::contentTypes['getFolder'][0])
    {
        list($response) = $this->getFolderWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation getFolderWithHttpInfo
     *
     * Get folder form filter
     *
     * REST API Reference for getFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FormsItemArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderWithHttpInfo($folder_id, string $contentType = self::contentTypes['getFolder'][0])
    {
        $request = $this->getFolderRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FormsItemArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FormsItemArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FormsItemArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFolderAsync
     *
     * Get folder form filter
     *
     * REST API Reference for getFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderAsync($folder_id, string $contentType = self::contentTypes['getFolder'][0])
    {
        return $this->getFolderAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderAsyncWithHttpInfo
     *
     * Get folder form filter
     *
     * REST API Reference for getFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderAsyncWithHttpInfo($folder_id, string $contentType = self::contentTypes['getFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FormsItemArrayWrapper';
        $request = $this->getFolderRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolder'
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFolderRequest($folder_id, string $contentType = self::contentTypes['getFolder'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling getFolder'
            );
        }


        $resourcePath = '/api/2.0/files/{folderId}/formfilter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolderByFolderId
     *
     * Get a folder by ID
     *
     * REST API Reference for getFolderByFolderId Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-by-folder-id/
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  string|null $shared_by The identifier of the user who shared the folder or file. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $room_id The room ID. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders, or all elements from the specified folder. (optional)
     * @param  string|null $extension Specifies whether to search for the specific file extension. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string|null $forms_item_key The forms item key. (optional)
     * @param  string|null $forms_item_type The forms item type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated request. (optional)
     * @param  string|null $sort_by The property used for sorting the folder request results. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text value used as a filter parameter for folder content queries. (optional)
     * @param  \OpenAPI\Client\Model\Location|null $location The location context of the request, specifying the area  where the operation is performed, such as a room, documents, or a link. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderByFolderId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderContentIntegerWrapper
     */
    public function getFolderByFolderId($folder_id, $user_id_or_group_id = null, $shared_by = null, $filter_type = null, $room_id = null, $exclude_subject = null, $apply_filter_option = null, $extension = null, $search_area = null, $forms_item_key = null, $forms_item_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, $location = null, string $contentType = self::contentTypes['getFolderByFolderId'][0])
    {
        list($response) = $this->getFolderByFolderIdWithHttpInfo($folder_id, $user_id_or_group_id, $shared_by, $filter_type, $room_id, $exclude_subject, $apply_filter_option, $extension, $search_area, $forms_item_key, $forms_item_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $location, $contentType);
        return $response;
    }

    /**
     * Operation getFolderByFolderIdWithHttpInfo
     *
     * Get a folder by ID
     *
     * REST API Reference for getFolderByFolderId Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-by-folder-id/
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  string|null $shared_by The identifier of the user who shared the folder or file. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $room_id The room ID. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders, or all elements from the specified folder. (optional)
     * @param  string|null $extension Specifies whether to search for the specific file extension. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string|null $forms_item_key The forms item key. (optional)
     * @param  string|null $forms_item_type The forms item type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated request. (optional)
     * @param  string|null $sort_by The property used for sorting the folder request results. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text value used as a filter parameter for folder content queries. (optional)
     * @param  \OpenAPI\Client\Model\Location|null $location The location context of the request, specifying the area  where the operation is performed, such as a room, documents, or a link. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderByFolderId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderContentIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderByFolderIdWithHttpInfo($folder_id, $user_id_or_group_id = null, $shared_by = null, $filter_type = null, $room_id = null, $exclude_subject = null, $apply_filter_option = null, $extension = null, $search_area = null, $forms_item_key = null, $forms_item_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, $location = null, string $contentType = self::contentTypes['getFolderByFolderId'][0])
    {
        $request = $this->getFolderByFolderIdRequest($folder_id, $user_id_or_group_id, $shared_by, $filter_type, $room_id, $exclude_subject, $apply_filter_option, $extension, $search_area, $forms_item_key, $forms_item_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $location, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFolderByFolderIdAsync
     *
     * Get a folder by ID
     *
     * REST API Reference for getFolderByFolderId Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-by-folder-id/
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  string|null $shared_by The identifier of the user who shared the folder or file. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $room_id The room ID. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders, or all elements from the specified folder. (optional)
     * @param  string|null $extension Specifies whether to search for the specific file extension. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string|null $forms_item_key The forms item key. (optional)
     * @param  string|null $forms_item_type The forms item type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated request. (optional)
     * @param  string|null $sort_by The property used for sorting the folder request results. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text value used as a filter parameter for folder content queries. (optional)
     * @param  \OpenAPI\Client\Model\Location|null $location The location context of the request, specifying the area  where the operation is performed, such as a room, documents, or a link. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderByFolderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderByFolderIdAsync($folder_id, $user_id_or_group_id = null, $shared_by = null, $filter_type = null, $room_id = null, $exclude_subject = null, $apply_filter_option = null, $extension = null, $search_area = null, $forms_item_key = null, $forms_item_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, $location = null, string $contentType = self::contentTypes['getFolderByFolderId'][0])
    {
        return $this->getFolderByFolderIdAsyncWithHttpInfo($folder_id, $user_id_or_group_id, $shared_by, $filter_type, $room_id, $exclude_subject, $apply_filter_option, $extension, $search_area, $forms_item_key, $forms_item_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $location, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderByFolderIdAsyncWithHttpInfo
     *
     * Get a folder by ID
     *
     * REST API Reference for getFolderByFolderId Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-by-folder-id/
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  string|null $shared_by The identifier of the user who shared the folder or file. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $room_id The room ID. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders, or all elements from the specified folder. (optional)
     * @param  string|null $extension Specifies whether to search for the specific file extension. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string|null $forms_item_key The forms item key. (optional)
     * @param  string|null $forms_item_type The forms item type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated request. (optional)
     * @param  string|null $sort_by The property used for sorting the folder request results. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text value used as a filter parameter for folder content queries. (optional)
     * @param  \OpenAPI\Client\Model\Location|null $location The location context of the request, specifying the area  where the operation is performed, such as a room, documents, or a link. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderByFolderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderByFolderIdAsyncWithHttpInfo($folder_id, $user_id_or_group_id = null, $shared_by = null, $filter_type = null, $room_id = null, $exclude_subject = null, $apply_filter_option = null, $extension = null, $search_area = null, $forms_item_key = null, $forms_item_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, $location = null, string $contentType = self::contentTypes['getFolderByFolderId'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderContentIntegerWrapper';
        $request = $this->getFolderByFolderIdRequest($folder_id, $user_id_or_group_id, $shared_by, $filter_type, $room_id, $exclude_subject, $apply_filter_option, $extension, $search_area, $forms_item_key, $forms_item_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $location, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolderByFolderId'
     *
     * @param  int $folder_id The folder ID. (required)
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  string|null $shared_by The identifier of the user who shared the folder or file. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $room_id The room ID. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders, or all elements from the specified folder. (optional)
     * @param  string|null $extension Specifies whether to search for the specific file extension. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string|null $forms_item_key The forms item key. (optional)
     * @param  string|null $forms_item_type The forms item type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated request. (optional)
     * @param  string|null $sort_by The property used for sorting the folder request results. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text value used as a filter parameter for folder content queries. (optional)
     * @param  \OpenAPI\Client\Model\Location|null $location The location context of the request, specifying the area  where the operation is performed, such as a room, documents, or a link. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderByFolderId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFolderByFolderIdRequest($folder_id, $user_id_or_group_id = null, $shared_by = null, $filter_type = null, $room_id = null, $exclude_subject = null, $apply_filter_option = null, $extension = null, $search_area = null, $forms_item_key = null, $forms_item_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, $location = null, string $contentType = self::contentTypes['getFolderByFolderId'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling getFolderByFolderId'
            );
        }











        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getFolderByFolderId, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getFolderByFolderId, must be bigger than or equal to 1.');
        }
        






        $resourcePath = '/api/2.0/files/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id_or_group_id,
            'userIdOrGroupId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $shared_by,
            'sharedBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_type,
            'filterType', // param base name
            'FilterType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $room_id,
            'roomId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_subject,
            'excludeSubject', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $apply_filter_option,
            'applyFilterOption', // param base name
            'ApplyFilterOption', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extension,
            'extension', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_area,
            'searchArea', // param base name
            'SearchArea', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $forms_item_key,
            'formsItemKey', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $forms_item_type,
            'formsItemType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location,
            'Location', // param base name
            'Location', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolderHistory
     *
     * Get folder history
     *
     * REST API Reference for getFolderHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-history/
     *
     * @param  int $folder_id The folder ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history request. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history request. (optional)
     * @param  int|null $count The number of records to retrieve for the folder history. (optional)
     * @param  int|null $start_index The starting index from which the history records are retrieved in the request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HistoryArrayWrapper
     */
    public function getFolderHistory($folder_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderHistory'][0])
    {
        list($response) = $this->getFolderHistoryWithHttpInfo($folder_id, $from_date, $to_date, $count, $start_index, $contentType);
        return $response;
    }

    /**
     * Operation getFolderHistoryWithHttpInfo
     *
     * Get folder history
     *
     * REST API Reference for getFolderHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-history/
     *
     * @param  int $folder_id The folder ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history request. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history request. (optional)
     * @param  int|null $count The number of records to retrieve for the folder history. (optional)
     * @param  int|null $start_index The starting index from which the history records are retrieved in the request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HistoryArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderHistoryWithHttpInfo($folder_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderHistory'][0])
    {
        $request = $this->getFolderHistoryRequest($folder_id, $from_date, $to_date, $count, $start_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HistoryArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HistoryArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HistoryArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFolderHistoryAsync
     *
     * Get folder history
     *
     * REST API Reference for getFolderHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-history/
     *
     * @param  int $folder_id The folder ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history request. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history request. (optional)
     * @param  int|null $count The number of records to retrieve for the folder history. (optional)
     * @param  int|null $start_index The starting index from which the history records are retrieved in the request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderHistoryAsync($folder_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderHistory'][0])
    {
        return $this->getFolderHistoryAsyncWithHttpInfo($folder_id, $from_date, $to_date, $count, $start_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderHistoryAsyncWithHttpInfo
     *
     * Get folder history
     *
     * REST API Reference for getFolderHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-history/
     *
     * @param  int $folder_id The folder ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history request. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history request. (optional)
     * @param  int|null $count The number of records to retrieve for the folder history. (optional)
     * @param  int|null $start_index The starting index from which the history records are retrieved in the request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderHistoryAsyncWithHttpInfo($folder_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderHistory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HistoryArrayWrapper';
        $request = $this->getFolderHistoryRequest($folder_id, $from_date, $to_date, $count, $start_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolderHistory'
     *
     * @param  int $folder_id The folder ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history request. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history request. (optional)
     * @param  int|null $count The number of records to retrieve for the folder history. (optional)
     * @param  int|null $start_index The starting index from which the history records are retrieved in the request. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFolderHistoryRequest($folder_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderHistory'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling getFolderHistory'
            );
        }



        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getFolderHistory, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getFolderHistory, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/api/2.0/files/folder/{folderId}/log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from_date,
            'fromDate', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to_date,
            'toDate', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolderInfo
     *
     * Get folder information
     *
     * REST API Reference for getFolderInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-info/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function getFolderInfo($folder_id, string $contentType = self::contentTypes['getFolderInfo'][0])
    {
        list($response) = $this->getFolderInfoWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation getFolderInfoWithHttpInfo
     *
     * Get folder information
     *
     * REST API Reference for getFolderInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-info/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderInfoWithHttpInfo($folder_id, string $contentType = self::contentTypes['getFolderInfo'][0])
    {
        $request = $this->getFolderInfoRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFolderInfoAsync
     *
     * Get folder information
     *
     * REST API Reference for getFolderInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-info/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderInfoAsync($folder_id, string $contentType = self::contentTypes['getFolderInfo'][0])
    {
        return $this->getFolderInfoAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderInfoAsyncWithHttpInfo
     *
     * Get folder information
     *
     * REST API Reference for getFolderInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-info/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderInfoAsyncWithHttpInfo($folder_id, string $contentType = self::contentTypes['getFolderInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->getFolderInfoRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolderInfo'
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFolderInfoRequest($folder_id, string $contentType = self::contentTypes['getFolderInfo'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling getFolderInfo'
            );
        }


        $resourcePath = '/api/2.0/files/folder/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolderLinks
     *
     * Get the folder links
     *
     * REST API Reference for getFolderLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-links/
     *
     * @param  int $id The folder ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderLinks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareArrayWrapper
     */
    public function getFolderLinks($id, string $contentType = self::contentTypes['getFolderLinks'][0])
    {
        list($response) = $this->getFolderLinksWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getFolderLinksWithHttpInfo
     *
     * Get the folder links
     *
     * REST API Reference for getFolderLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-links/
     *
     * @param  int $id The folder ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderLinks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderLinksWithHttpInfo($id, string $contentType = self::contentTypes['getFolderLinks'][0])
    {
        $request = $this->getFolderLinksRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFolderLinksAsync
     *
     * Get the folder links
     *
     * REST API Reference for getFolderLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-links/
     *
     * @param  int $id The folder ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderLinksAsync($id, string $contentType = self::contentTypes['getFolderLinks'][0])
    {
        return $this->getFolderLinksAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderLinksAsyncWithHttpInfo
     *
     * Get the folder links
     *
     * REST API Reference for getFolderLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-links/
     *
     * @param  int $id The folder ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderLinksAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getFolderLinks'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareArrayWrapper';
        $request = $this->getFolderLinksRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolderLinks'
     *
     * @param  int $id The folder ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFolderLinksRequest($id, string $contentType = self::contentTypes['getFolderLinks'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFolderLinks'
            );
        }


        $resourcePath = '/api/2.0/files/folder/{id}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolderPath
     *
     * Get the folder path
     *
     * REST API Reference for getFolderPath Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-path/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPath'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileEntryBaseArrayWrapper
     */
    public function getFolderPath($folder_id, string $contentType = self::contentTypes['getFolderPath'][0])
    {
        list($response) = $this->getFolderPathWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation getFolderPathWithHttpInfo
     *
     * Get the folder path
     *
     * REST API Reference for getFolderPath Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-path/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPath'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileEntryBaseArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderPathWithHttpInfo($folder_id, string $contentType = self::contentTypes['getFolderPath'][0])
    {
        $request = $this->getFolderPathRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFolderPathAsync
     *
     * Get the folder path
     *
     * REST API Reference for getFolderPath Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-path/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPath'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderPathAsync($folder_id, string $contentType = self::contentTypes['getFolderPath'][0])
    {
        return $this->getFolderPathAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderPathAsyncWithHttpInfo
     *
     * Get the folder path
     *
     * REST API Reference for getFolderPath Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-path/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPath'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderPathAsyncWithHttpInfo($folder_id, string $contentType = self::contentTypes['getFolderPath'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper';
        $request = $this->getFolderPathRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolderPath'
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPath'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFolderPathRequest($folder_id, string $contentType = self::contentTypes['getFolderPath'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling getFolderPath'
            );
        }


        $resourcePath = '/api/2.0/files/folder/{folderId}/path';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolderPrimaryExternalLink
     *
     * Get primary external link
     *
     * REST API Reference for getFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-primary-external-link/
     *
     * @param  int $id The folder unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareWrapper
     */
    public function getFolderPrimaryExternalLink($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderPrimaryExternalLink'][0])
    {
        list($response) = $this->getFolderPrimaryExternalLinkWithHttpInfo($id, $count, $start_index, $contentType);
        return $response;
    }

    /**
     * Operation getFolderPrimaryExternalLinkWithHttpInfo
     *
     * Get primary external link
     *
     * REST API Reference for getFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-primary-external-link/
     *
     * @param  int $id The folder unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFolderPrimaryExternalLinkWithHttpInfo($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderPrimaryExternalLink'][0])
    {
        $request = $this->getFolderPrimaryExternalLinkRequest($id, $count, $start_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFolderPrimaryExternalLinkAsync
     *
     * Get primary external link
     *
     * REST API Reference for getFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-primary-external-link/
     *
     * @param  int $id The folder unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderPrimaryExternalLinkAsync($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderPrimaryExternalLink'][0])
    {
        return $this->getFolderPrimaryExternalLinkAsyncWithHttpInfo($id, $count, $start_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFolderPrimaryExternalLinkAsyncWithHttpInfo
     *
     * Get primary external link
     *
     * REST API Reference for getFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folder-primary-external-link/
     *
     * @param  int $id The folder unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFolderPrimaryExternalLinkAsyncWithHttpInfo($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderPrimaryExternalLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareWrapper';
        $request = $this->getFolderPrimaryExternalLinkRequest($id, $count, $start_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolderPrimaryExternalLink'
     *
     * @param  int $id The folder unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFolderPrimaryExternalLinkRequest($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFolderPrimaryExternalLink'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFolderPrimaryExternalLink'
            );
        }

        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getFolderPrimaryExternalLink, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getFolderPrimaryExternalLink, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/api/2.0/files/folder/{id}/link';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFolders
     *
     * Get subfolders
     *
     * REST API Reference for getFolders Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folders/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolders'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileEntryBaseArrayWrapper
     */
    public function getFolders($folder_id, string $contentType = self::contentTypes['getFolders'][0])
    {
        list($response) = $this->getFoldersWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation getFoldersWithHttpInfo
     *
     * Get subfolders
     *
     * REST API Reference for getFolders Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folders/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolders'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileEntryBaseArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFoldersWithHttpInfo($folder_id, string $contentType = self::contentTypes['getFolders'][0])
    {
        $request = $this->getFoldersRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFoldersAsync
     *
     * Get subfolders
     *
     * REST API Reference for getFolders Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folders/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFoldersAsync($folder_id, string $contentType = self::contentTypes['getFolders'][0])
    {
        return $this->getFoldersAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFoldersAsyncWithHttpInfo
     *
     * Get subfolders
     *
     * REST API Reference for getFolders Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-folders/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFoldersAsyncWithHttpInfo($folder_id, string $contentType = self::contentTypes['getFolders'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper';
        $request = $this->getFoldersRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFolders'
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFoldersRequest($folder_id, string $contentType = self::contentTypes['getFolders'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling getFolders'
            );
        }


        $resourcePath = '/api/2.0/files/{folderId}/subfolders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getMyFolder
     *
     * Get the My documents section
     *
     * REST API Reference for getMyFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-my-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderContentIntegerWrapper
     */
    public function getMyFolder($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getMyFolder'][0])
    {
        list($response) = $this->getMyFolderWithHttpInfo($user_id_or_group_id, $filter_type, $apply_filter_option, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);
        return $response;
    }

    /**
     * Operation getMyFolderWithHttpInfo
     *
     * Get the My documents section
     *
     * REST API Reference for getMyFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-my-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderContentIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getMyFolderWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getMyFolder'][0])
    {
        $request = $this->getMyFolderRequest($user_id_or_group_id, $filter_type, $apply_filter_option, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getMyFolderAsync
     *
     * Get the My documents section
     *
     * REST API Reference for getMyFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-my-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyFolderAsync($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getMyFolder'][0])
    {
        return $this->getMyFolderAsyncWithHttpInfo($user_id_or_group_id, $filter_type, $apply_filter_option, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getMyFolderAsyncWithHttpInfo
     *
     * Get the My documents section
     *
     * REST API Reference for getMyFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-my-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getMyFolderAsyncWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getMyFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderContentIntegerWrapper';
        $request = $this->getMyFolderRequest($user_id_or_group_id, $filter_type, $apply_filter_option, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getMyFolder'
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getMyFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getMyFolderRequest($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getMyFolder'][0])
    {




        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getMyFolder, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getMyFolder, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/2.0/files/@my';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id_or_group_id,
            'userIdOrGroupId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_type,
            'filterType', // param base name
            'FilterType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $apply_filter_option,
            'applyFilterOption', // param base name
            'ApplyFilterOption', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        if ($this->fields !== null) {
            $headerParams['fields'] = $this->fields;
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewFolderItems
     *
     * Get new folder items
     *
     * REST API Reference for getNewFolderItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-new-folder-items/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewFolderItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileEntryBaseArrayWrapper
     */
    public function getNewFolderItems($folder_id, string $contentType = self::contentTypes['getNewFolderItems'][0])
    {
        list($response) = $this->getNewFolderItemsWithHttpInfo($folder_id, $contentType);
        return $response;
    }

    /**
     * Operation getNewFolderItemsWithHttpInfo
     *
     * Get new folder items
     *
     * REST API Reference for getNewFolderItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-new-folder-items/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewFolderItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileEntryBaseArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewFolderItemsWithHttpInfo($folder_id, string $contentType = self::contentTypes['getNewFolderItems'][0])
    {
        $request = $this->getNewFolderItemsRequest($folder_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getNewFolderItemsAsync
     *
     * Get new folder items
     *
     * REST API Reference for getNewFolderItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-new-folder-items/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewFolderItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewFolderItemsAsync($folder_id, string $contentType = self::contentTypes['getNewFolderItems'][0])
    {
        return $this->getNewFolderItemsAsyncWithHttpInfo($folder_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewFolderItemsAsyncWithHttpInfo
     *
     * Get new folder items
     *
     * REST API Reference for getNewFolderItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-new-folder-items/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewFolderItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewFolderItemsAsyncWithHttpInfo($folder_id, string $contentType = self::contentTypes['getNewFolderItems'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper';
        $request = $this->getNewFolderItemsRequest($folder_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewFolderItems'
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewFolderItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNewFolderItemsRequest($folder_id, string $contentType = self::contentTypes['getNewFolderItems'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling getNewFolderItems'
            );
        }


        $resourcePath = '/api/2.0/files/{folderId}/news';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPrivacyFolder
     *
     * Get the Private Room section
     *
     * REST API Reference for getPrivacyFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-privacy-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrivacyFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderContentIntegerWrapper
     */
    public function getPrivacyFolder($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getPrivacyFolder'][0])
    {
        list($response) = $this->getPrivacyFolderWithHttpInfo($user_id_or_group_id, $filter_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);
        return $response;
    }

    /**
     * Operation getPrivacyFolderWithHttpInfo
     *
     * Get the Private Room section
     *
     * REST API Reference for getPrivacyFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-privacy-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrivacyFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderContentIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPrivacyFolderWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getPrivacyFolder'][0])
    {
        $request = $this->getPrivacyFolderRequest($user_id_or_group_id, $filter_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPrivacyFolderAsync
     *
     * Get the Private Room section
     *
     * REST API Reference for getPrivacyFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-privacy-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrivacyFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPrivacyFolderAsync($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getPrivacyFolder'][0])
    {
        return $this->getPrivacyFolderAsyncWithHttpInfo($user_id_or_group_id, $filter_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPrivacyFolderAsyncWithHttpInfo
     *
     * Get the Private Room section
     *
     * REST API Reference for getPrivacyFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-privacy-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrivacyFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPrivacyFolderAsyncWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getPrivacyFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderContentIntegerWrapper';
        $request = $this->getPrivacyFolderRequest($user_id_or_group_id, $filter_type, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPrivacyFolder'
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The zero-based index of the first item to retrieve in a paginated list. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter or search criterion for folder content queries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPrivacyFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPrivacyFolderRequest($user_id_or_group_id = null, $filter_type = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getPrivacyFolder'][0])
    {



        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getPrivacyFolder, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getPrivacyFolder, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/2.0/files/@privacy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id_or_group_id,
            'userIdOrGroupId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_type,
            'filterType', // param base name
            'FilterType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        if ($this->fields !== null) {
            $headerParams['fields'] = $this->fields;
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRecentFolder
     *
     * Get the Recent section
     *
     * REST API Reference for getRecentFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-recent-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string[]|null $extension Specifies whether to search for a specific file extension in the Recent folder. (optional)
     * @param  int|null $count The maximum number of items to return. (optional)
     * @param  int|null $start_index The starting position of the results to be returned in the query response. (optional)
     * @param  string|null $sort_by Specifies the sorting criteria for the folder request. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecentFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderContentIntegerWrapper
     */
    public function getRecentFolder($user_id_or_group_id = null, $filter_type = null, $exclude_subject = null, $apply_filter_option = null, $search_area = null, $extension = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRecentFolder'][0])
    {
        list($response) = $this->getRecentFolderWithHttpInfo($user_id_or_group_id, $filter_type, $exclude_subject, $apply_filter_option, $search_area, $extension, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);
        return $response;
    }

    /**
     * Operation getRecentFolderWithHttpInfo
     *
     * Get the Recent section
     *
     * REST API Reference for getRecentFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-recent-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string[]|null $extension Specifies whether to search for a specific file extension in the Recent folder. (optional)
     * @param  int|null $count The maximum number of items to return. (optional)
     * @param  int|null $start_index The starting position of the results to be returned in the query response. (optional)
     * @param  string|null $sort_by Specifies the sorting criteria for the folder request. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecentFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderContentIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRecentFolderWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $exclude_subject = null, $apply_filter_option = null, $search_area = null, $extension = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRecentFolder'][0])
    {
        $request = $this->getRecentFolderRequest($user_id_or_group_id, $filter_type, $exclude_subject, $apply_filter_option, $search_area, $extension, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRecentFolderAsync
     *
     * Get the Recent section
     *
     * REST API Reference for getRecentFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-recent-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string[]|null $extension Specifies whether to search for a specific file extension in the Recent folder. (optional)
     * @param  int|null $count The maximum number of items to return. (optional)
     * @param  int|null $start_index The starting position of the results to be returned in the query response. (optional)
     * @param  string|null $sort_by Specifies the sorting criteria for the folder request. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecentFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecentFolderAsync($user_id_or_group_id = null, $filter_type = null, $exclude_subject = null, $apply_filter_option = null, $search_area = null, $extension = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRecentFolder'][0])
    {
        return $this->getRecentFolderAsyncWithHttpInfo($user_id_or_group_id, $filter_type, $exclude_subject, $apply_filter_option, $search_area, $extension, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRecentFolderAsyncWithHttpInfo
     *
     * Get the Recent section
     *
     * REST API Reference for getRecentFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-recent-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string[]|null $extension Specifies whether to search for a specific file extension in the Recent folder. (optional)
     * @param  int|null $count The maximum number of items to return. (optional)
     * @param  int|null $start_index The starting position of the results to be returned in the query response. (optional)
     * @param  string|null $sort_by Specifies the sorting criteria for the folder request. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecentFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRecentFolderAsyncWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $exclude_subject = null, $apply_filter_option = null, $search_area = null, $extension = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRecentFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderContentIntegerWrapper';
        $request = $this->getRecentFolderRequest($user_id_or_group_id, $filter_type, $exclude_subject, $apply_filter_option, $search_area, $extension, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRecentFolder'
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The search area. (optional)
     * @param  string[]|null $extension Specifies whether to search for a specific file extension in the Recent folder. (optional)
     * @param  int|null $count The maximum number of items to return. (optional)
     * @param  int|null $start_index The starting position of the results to be returned in the query response. (optional)
     * @param  string|null $sort_by Specifies the sorting criteria for the folder request. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRecentFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRecentFolderRequest($user_id_or_group_id = null, $filter_type = null, $exclude_subject = null, $apply_filter_option = null, $search_area = null, $extension = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRecentFolder'][0])
    {







        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getRecentFolder, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getRecentFolder, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/2.0/files/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id_or_group_id,
            'userIdOrGroupId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_type,
            'filterType', // param base name
            'FilterType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_subject,
            'excludeSubject', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $apply_filter_option,
            'applyFilterOption', // param base name
            'ApplyFilterOption', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_area,
            'searchArea', // param base name
            'SearchArea', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extension,
            'extension', // param base name
            'array', // openApiType
            'deepObject', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        if ($this->fields !== null) {
            $headerParams['fields'] = $this->fields;
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRootFolders
     *
     * Get filtered sections
     *
     * REST API Reference for getRootFolders Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-root-folders/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $without_trash Specifies whether to return the Trash section or not. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter for searching or retrieving folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRootFolders'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderContentIntegerArrayWrapper
     */
    public function getRootFolders($user_id_or_group_id = null, $filter_type = null, $without_trash = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRootFolders'][0])
    {
        list($response) = $this->getRootFoldersWithHttpInfo($user_id_or_group_id, $filter_type, $without_trash, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);
        return $response;
    }

    /**
     * Operation getRootFoldersWithHttpInfo
     *
     * Get filtered sections
     *
     * REST API Reference for getRootFolders Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-root-folders/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $without_trash Specifies whether to return the Trash section or not. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter for searching or retrieving folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRootFolders'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderContentIntegerArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRootFoldersWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $without_trash = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRootFolders'][0])
    {
        $request = $this->getRootFoldersRequest($user_id_or_group_id, $filter_type, $without_trash, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderContentIntegerArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderContentIntegerArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderContentIntegerArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRootFoldersAsync
     *
     * Get filtered sections
     *
     * REST API Reference for getRootFolders Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-root-folders/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $without_trash Specifies whether to return the Trash section or not. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter for searching or retrieving folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRootFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRootFoldersAsync($user_id_or_group_id = null, $filter_type = null, $without_trash = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRootFolders'][0])
    {
        return $this->getRootFoldersAsyncWithHttpInfo($user_id_or_group_id, $filter_type, $without_trash, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRootFoldersAsyncWithHttpInfo
     *
     * Get filtered sections
     *
     * REST API Reference for getRootFolders Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-root-folders/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $without_trash Specifies whether to return the Trash section or not. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter for searching or retrieving folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRootFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRootFoldersAsyncWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $without_trash = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRootFolders'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderContentIntegerArrayWrapper';
        $request = $this->getRootFoldersRequest($user_id_or_group_id, $filter_type, $without_trash, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRootFolders'
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  bool|null $without_trash Specifies whether to return the Trash section or not. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by Specifies the field by which the folder content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used as a filter for searching or retrieving folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRootFolders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRootFoldersRequest($user_id_or_group_id = null, $filter_type = null, $without_trash = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRootFolders'][0])
    {




        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getRootFolders, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getRootFolders, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/2.0/files/@root';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id_or_group_id,
            'userIdOrGroupId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_type,
            'filterType', // param base name
            'FilterType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $without_trash,
            'withoutTrash', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        if ($this->fields !== null) {
            $headerParams['fields'] = $this->fields;
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTrashFolder
     *
     * Get the Trash section
     *
     * REST API Reference for getTrashFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-trash-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrashFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderContentIntegerWrapper
     */
    public function getTrashFolder($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getTrashFolder'][0])
    {
        list($response) = $this->getTrashFolderWithHttpInfo($user_id_or_group_id, $filter_type, $apply_filter_option, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);
        return $response;
    }

    /**
     * Operation getTrashFolderWithHttpInfo
     *
     * Get the Trash section
     *
     * REST API Reference for getTrashFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-trash-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrashFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderContentIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTrashFolderWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getTrashFolder'][0])
    {
        $request = $this->getTrashFolderRequest($user_id_or_group_id, $filter_type, $apply_filter_option, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTrashFolderAsync
     *
     * Get the Trash section
     *
     * REST API Reference for getTrashFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-trash-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrashFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrashFolderAsync($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getTrashFolder'][0])
    {
        return $this->getTrashFolderAsyncWithHttpInfo($user_id_or_group_id, $filter_type, $apply_filter_option, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTrashFolderAsyncWithHttpInfo
     *
     * Get the Trash section
     *
     * REST API Reference for getTrashFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-trash-folder/
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrashFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTrashFolderAsyncWithHttpInfo($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getTrashFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderContentIntegerWrapper';
        $request = $this->getTrashFolderRequest($user_id_or_group_id, $filter_type, $apply_filter_option, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTrashFolder'
     *
     * @param  string|null $user_id_or_group_id The user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\FilterType|null $filter_type The filter type. (optional)
     * @param  \OpenAPI\Client\Model\ApplyFilterOption|null $apply_filter_option Specifies whether to return only files, only folders or all elements. (optional)
     * @param  int|null $count The maximum number of items to retrieve in the response. (optional)
     * @param  int|null $start_index The starting position of the items to be retrieved. (optional)
     * @param  string|null $sort_by The property used to specify the sorting criteria for folder contents. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text used for filtering or searching folder contents. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTrashFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTrashFolderRequest($user_id_or_group_id = null, $filter_type = null, $apply_filter_option = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getTrashFolder'][0])
    {




        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getTrashFolder, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FoldersApi.getTrashFolder, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/2.0/files/@trash';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $user_id_or_group_id,
            'userIdOrGroupId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_type,
            'filterType', // param base name
            'FilterType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $apply_filter_option,
            'applyFilterOption', // param base name
            'ApplyFilterOption', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        if ($this->fields !== null) {
            $headerParams['fields'] = $this->fields;
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertFile
     *
     * Insert a file
     *
     * REST API Reference for insertFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/insert-file/
     *
     * @param  int $folder_id The folder ID for inserting a file. (required)
     * @param  \SplFileObject|null $insert_file_file The file to be inserted. (optional)
     * @param  string|null $insert_file_title The file title to be inserted. (optional)
     * @param  bool|null $insert_file_create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $insert_file_keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $insert_file_stream_can_read insert_file_stream_can_read (optional)
     * @param  bool|null $insert_file_stream_can_write insert_file_stream_can_write (optional)
     * @param  bool|null $insert_file_stream_can_seek insert_file_stream_can_seek (optional)
     * @param  bool|null $insert_file_stream_can_timeout insert_file_stream_can_timeout (optional)
     * @param  int|null $insert_file_stream_length insert_file_stream_length (optional)
     * @param  int|null $insert_file_stream_position insert_file_stream_position (optional)
     * @param  int|null $insert_file_stream_read_timeout insert_file_stream_read_timeout (optional)
     * @param  int|null $insert_file_stream_write_timeout insert_file_stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function insertFile($folder_id, $insert_file_file = null, $insert_file_title = null, $insert_file_create_new_if_exist = null, $insert_file_keep_convert_status = null, $insert_file_stream_can_read = null, $insert_file_stream_can_write = null, $insert_file_stream_can_seek = null, $insert_file_stream_can_timeout = null, $insert_file_stream_length = null, $insert_file_stream_position = null, $insert_file_stream_read_timeout = null, $insert_file_stream_write_timeout = null, string $contentType = self::contentTypes['insertFile'][0])
    {
        list($response) = $this->insertFileWithHttpInfo($folder_id, $insert_file_file, $insert_file_title, $insert_file_create_new_if_exist, $insert_file_keep_convert_status, $insert_file_stream_can_read, $insert_file_stream_can_write, $insert_file_stream_can_seek, $insert_file_stream_can_timeout, $insert_file_stream_length, $insert_file_stream_position, $insert_file_stream_read_timeout, $insert_file_stream_write_timeout, $contentType);
        return $response;
    }

    /**
     * Operation insertFileWithHttpInfo
     *
     * Insert a file
     *
     * REST API Reference for insertFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/insert-file/
     *
     * @param  int $folder_id The folder ID for inserting a file. (required)
     * @param  \SplFileObject|null $insert_file_file The file to be inserted. (optional)
     * @param  string|null $insert_file_title The file title to be inserted. (optional)
     * @param  bool|null $insert_file_create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $insert_file_keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $insert_file_stream_can_read (optional)
     * @param  bool|null $insert_file_stream_can_write (optional)
     * @param  bool|null $insert_file_stream_can_seek (optional)
     * @param  bool|null $insert_file_stream_can_timeout (optional)
     * @param  int|null $insert_file_stream_length (optional)
     * @param  int|null $insert_file_stream_position (optional)
     * @param  int|null $insert_file_stream_read_timeout (optional)
     * @param  int|null $insert_file_stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertFileWithHttpInfo($folder_id, $insert_file_file = null, $insert_file_title = null, $insert_file_create_new_if_exist = null, $insert_file_keep_convert_status = null, $insert_file_stream_can_read = null, $insert_file_stream_can_write = null, $insert_file_stream_can_seek = null, $insert_file_stream_can_timeout = null, $insert_file_stream_length = null, $insert_file_stream_position = null, $insert_file_stream_read_timeout = null, $insert_file_stream_write_timeout = null, string $contentType = self::contentTypes['insertFile'][0])
    {
        $request = $this->insertFileRequest($folder_id, $insert_file_file, $insert_file_title, $insert_file_create_new_if_exist, $insert_file_keep_convert_status, $insert_file_stream_can_read, $insert_file_stream_can_write, $insert_file_stream_can_seek, $insert_file_stream_can_timeout, $insert_file_stream_length, $insert_file_stream_position, $insert_file_stream_read_timeout, $insert_file_stream_write_timeout, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation insertFileAsync
     *
     * Insert a file
     *
     * REST API Reference for insertFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/insert-file/
     *
     * @param  int $folder_id The folder ID for inserting a file. (required)
     * @param  \SplFileObject|null $insert_file_file The file to be inserted. (optional)
     * @param  string|null $insert_file_title The file title to be inserted. (optional)
     * @param  bool|null $insert_file_create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $insert_file_keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $insert_file_stream_can_read (optional)
     * @param  bool|null $insert_file_stream_can_write (optional)
     * @param  bool|null $insert_file_stream_can_seek (optional)
     * @param  bool|null $insert_file_stream_can_timeout (optional)
     * @param  int|null $insert_file_stream_length (optional)
     * @param  int|null $insert_file_stream_position (optional)
     * @param  int|null $insert_file_stream_read_timeout (optional)
     * @param  int|null $insert_file_stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFileAsync($folder_id, $insert_file_file = null, $insert_file_title = null, $insert_file_create_new_if_exist = null, $insert_file_keep_convert_status = null, $insert_file_stream_can_read = null, $insert_file_stream_can_write = null, $insert_file_stream_can_seek = null, $insert_file_stream_can_timeout = null, $insert_file_stream_length = null, $insert_file_stream_position = null, $insert_file_stream_read_timeout = null, $insert_file_stream_write_timeout = null, string $contentType = self::contentTypes['insertFile'][0])
    {
        return $this->insertFileAsyncWithHttpInfo($folder_id, $insert_file_file, $insert_file_title, $insert_file_create_new_if_exist, $insert_file_keep_convert_status, $insert_file_stream_can_read, $insert_file_stream_can_write, $insert_file_stream_can_seek, $insert_file_stream_can_timeout, $insert_file_stream_length, $insert_file_stream_position, $insert_file_stream_read_timeout, $insert_file_stream_write_timeout, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertFileAsyncWithHttpInfo
     *
     * Insert a file
     *
     * REST API Reference for insertFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/insert-file/
     *
     * @param  int $folder_id The folder ID for inserting a file. (required)
     * @param  \SplFileObject|null $insert_file_file The file to be inserted. (optional)
     * @param  string|null $insert_file_title The file title to be inserted. (optional)
     * @param  bool|null $insert_file_create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $insert_file_keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $insert_file_stream_can_read (optional)
     * @param  bool|null $insert_file_stream_can_write (optional)
     * @param  bool|null $insert_file_stream_can_seek (optional)
     * @param  bool|null $insert_file_stream_can_timeout (optional)
     * @param  int|null $insert_file_stream_length (optional)
     * @param  int|null $insert_file_stream_position (optional)
     * @param  int|null $insert_file_stream_read_timeout (optional)
     * @param  int|null $insert_file_stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFileAsyncWithHttpInfo($folder_id, $insert_file_file = null, $insert_file_title = null, $insert_file_create_new_if_exist = null, $insert_file_keep_convert_status = null, $insert_file_stream_can_read = null, $insert_file_stream_can_write = null, $insert_file_stream_can_seek = null, $insert_file_stream_can_timeout = null, $insert_file_stream_length = null, $insert_file_stream_position = null, $insert_file_stream_read_timeout = null, $insert_file_stream_write_timeout = null, string $contentType = self::contentTypes['insertFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->insertFileRequest($folder_id, $insert_file_file, $insert_file_title, $insert_file_create_new_if_exist, $insert_file_keep_convert_status, $insert_file_stream_can_read, $insert_file_stream_can_write, $insert_file_stream_can_seek, $insert_file_stream_can_timeout, $insert_file_stream_length, $insert_file_stream_position, $insert_file_stream_read_timeout, $insert_file_stream_write_timeout, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertFile'
     *
     * @param  int $folder_id The folder ID for inserting a file. (required)
     * @param  \SplFileObject|null $insert_file_file The file to be inserted. (optional)
     * @param  string|null $insert_file_title The file title to be inserted. (optional)
     * @param  bool|null $insert_file_create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $insert_file_keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $insert_file_stream_can_read (optional)
     * @param  bool|null $insert_file_stream_can_write (optional)
     * @param  bool|null $insert_file_stream_can_seek (optional)
     * @param  bool|null $insert_file_stream_can_timeout (optional)
     * @param  int|null $insert_file_stream_length (optional)
     * @param  int|null $insert_file_stream_position (optional)
     * @param  int|null $insert_file_stream_read_timeout (optional)
     * @param  int|null $insert_file_stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function insertFileRequest($folder_id, $insert_file_file = null, $insert_file_title = null, $insert_file_create_new_if_exist = null, $insert_file_keep_convert_status = null, $insert_file_stream_can_read = null, $insert_file_stream_can_write = null, $insert_file_stream_can_seek = null, $insert_file_stream_can_timeout = null, $insert_file_stream_length = null, $insert_file_stream_position = null, $insert_file_stream_read_timeout = null, $insert_file_stream_write_timeout = null, string $contentType = self::contentTypes['insertFile'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling insertFile'
            );
        }














        $resourcePath = '/api/2.0/files/{folderId}/insert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }

        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'insert_file_file' => $insert_file_file,
            'insert_file_title' => $insert_file_title,
            'insert_file_create_new_if_exist' => $insert_file_create_new_if_exist,
            'insert_file_keep_convert_status' => $insert_file_keep_convert_status,
            'insert_file_stream_can_read' => $insert_file_stream_can_read,
            'insert_file_stream_can_write' => $insert_file_stream_can_write,
            'insert_file_stream_can_seek' => $insert_file_stream_can_seek,
            'insert_file_stream_can_timeout' => $insert_file_stream_can_timeout,
            'insert_file_stream_length' => $insert_file_stream_length,
            'insert_file_stream_position' => $insert_file_stream_position,
            'insert_file_stream_read_timeout' => $insert_file_stream_read_timeout,
            'insert_file_stream_write_timeout' => $insert_file_stream_write_timeout,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertFileToMyFromBody
     *
     * Insert a file to the My documents section
     *
     * REST API Reference for insertFileToMyFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/insert-file-to-my-from-body/
     *
     * @param  \SplFileObject|null $file The file to be inserted. (optional)
     * @param  string|null $title The file title to be inserted. (optional)
     * @param  bool|null $create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $stream_can_read stream_can_read (optional)
     * @param  bool|null $stream_can_write stream_can_write (optional)
     * @param  bool|null $stream_can_seek stream_can_seek (optional)
     * @param  bool|null $stream_can_timeout stream_can_timeout (optional)
     * @param  int|null $stream_length stream_length (optional)
     * @param  int|null $stream_position stream_position (optional)
     * @param  int|null $stream_read_timeout stream_read_timeout (optional)
     * @param  int|null $stream_write_timeout stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFileToMyFromBody'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function insertFileToMyFromBody($file = null, $title = null, $create_new_if_exist = null, $keep_convert_status = null, $stream_can_read = null, $stream_can_write = null, $stream_can_seek = null, $stream_can_timeout = null, $stream_length = null, $stream_position = null, $stream_read_timeout = null, $stream_write_timeout = null, string $contentType = self::contentTypes['insertFileToMyFromBody'][0])
    {
        list($response) = $this->insertFileToMyFromBodyWithHttpInfo($file, $title, $create_new_if_exist, $keep_convert_status, $stream_can_read, $stream_can_write, $stream_can_seek, $stream_can_timeout, $stream_length, $stream_position, $stream_read_timeout, $stream_write_timeout, $contentType);
        return $response;
    }

    /**
     * Operation insertFileToMyFromBodyWithHttpInfo
     *
     * Insert a file to the My documents section
     *
     * REST API Reference for insertFileToMyFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/insert-file-to-my-from-body/
     *
     * @param  \SplFileObject|null $file The file to be inserted. (optional)
     * @param  string|null $title The file title to be inserted. (optional)
     * @param  bool|null $create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $stream_can_read (optional)
     * @param  bool|null $stream_can_write (optional)
     * @param  bool|null $stream_can_seek (optional)
     * @param  bool|null $stream_can_timeout (optional)
     * @param  int|null $stream_length (optional)
     * @param  int|null $stream_position (optional)
     * @param  int|null $stream_read_timeout (optional)
     * @param  int|null $stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFileToMyFromBody'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertFileToMyFromBodyWithHttpInfo($file = null, $title = null, $create_new_if_exist = null, $keep_convert_status = null, $stream_can_read = null, $stream_can_write = null, $stream_can_seek = null, $stream_can_timeout = null, $stream_length = null, $stream_position = null, $stream_read_timeout = null, $stream_write_timeout = null, string $contentType = self::contentTypes['insertFileToMyFromBody'][0])
    {
        $request = $this->insertFileToMyFromBodyRequest($file, $title, $create_new_if_exist, $keep_convert_status, $stream_can_read, $stream_can_write, $stream_can_seek, $stream_can_timeout, $stream_length, $stream_position, $stream_read_timeout, $stream_write_timeout, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation insertFileToMyFromBodyAsync
     *
     * Insert a file to the My documents section
     *
     * REST API Reference for insertFileToMyFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/insert-file-to-my-from-body/
     *
     * @param  \SplFileObject|null $file The file to be inserted. (optional)
     * @param  string|null $title The file title to be inserted. (optional)
     * @param  bool|null $create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $stream_can_read (optional)
     * @param  bool|null $stream_can_write (optional)
     * @param  bool|null $stream_can_seek (optional)
     * @param  bool|null $stream_can_timeout (optional)
     * @param  int|null $stream_length (optional)
     * @param  int|null $stream_position (optional)
     * @param  int|null $stream_read_timeout (optional)
     * @param  int|null $stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFileToMyFromBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFileToMyFromBodyAsync($file = null, $title = null, $create_new_if_exist = null, $keep_convert_status = null, $stream_can_read = null, $stream_can_write = null, $stream_can_seek = null, $stream_can_timeout = null, $stream_length = null, $stream_position = null, $stream_read_timeout = null, $stream_write_timeout = null, string $contentType = self::contentTypes['insertFileToMyFromBody'][0])
    {
        return $this->insertFileToMyFromBodyAsyncWithHttpInfo($file, $title, $create_new_if_exist, $keep_convert_status, $stream_can_read, $stream_can_write, $stream_can_seek, $stream_can_timeout, $stream_length, $stream_position, $stream_read_timeout, $stream_write_timeout, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertFileToMyFromBodyAsyncWithHttpInfo
     *
     * Insert a file to the My documents section
     *
     * REST API Reference for insertFileToMyFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/insert-file-to-my-from-body/
     *
     * @param  \SplFileObject|null $file The file to be inserted. (optional)
     * @param  string|null $title The file title to be inserted. (optional)
     * @param  bool|null $create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $stream_can_read (optional)
     * @param  bool|null $stream_can_write (optional)
     * @param  bool|null $stream_can_seek (optional)
     * @param  bool|null $stream_can_timeout (optional)
     * @param  int|null $stream_length (optional)
     * @param  int|null $stream_position (optional)
     * @param  int|null $stream_read_timeout (optional)
     * @param  int|null $stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFileToMyFromBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertFileToMyFromBodyAsyncWithHttpInfo($file = null, $title = null, $create_new_if_exist = null, $keep_convert_status = null, $stream_can_read = null, $stream_can_write = null, $stream_can_seek = null, $stream_can_timeout = null, $stream_length = null, $stream_position = null, $stream_read_timeout = null, $stream_write_timeout = null, string $contentType = self::contentTypes['insertFileToMyFromBody'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->insertFileToMyFromBodyRequest($file, $title, $create_new_if_exist, $keep_convert_status, $stream_can_read, $stream_can_write, $stream_can_seek, $stream_can_timeout, $stream_length, $stream_position, $stream_read_timeout, $stream_write_timeout, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertFileToMyFromBody'
     *
     * @param  \SplFileObject|null $file The file to be inserted. (optional)
     * @param  string|null $title The file title to be inserted. (optional)
     * @param  bool|null $create_new_if_exist Specifies whether to create a new file if it already exists or not. (optional)
     * @param  bool|null $keep_convert_status Specifies whether to keep the file converting status or not. (optional)
     * @param  bool|null $stream_can_read (optional)
     * @param  bool|null $stream_can_write (optional)
     * @param  bool|null $stream_can_seek (optional)
     * @param  bool|null $stream_can_timeout (optional)
     * @param  int|null $stream_length (optional)
     * @param  int|null $stream_position (optional)
     * @param  int|null $stream_read_timeout (optional)
     * @param  int|null $stream_write_timeout (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['insertFileToMyFromBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function insertFileToMyFromBodyRequest($file = null, $title = null, $create_new_if_exist = null, $keep_convert_status = null, $stream_can_read = null, $stream_can_write = null, $stream_can_seek = null, $stream_can_timeout = null, $stream_length = null, $stream_position = null, $stream_read_timeout = null, $stream_write_timeout = null, string $contentType = self::contentTypes['insertFileToMyFromBody'][0])
    {














        $resourcePath = '/api/2.0/files/@my/insert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
            'title' => $title,
            'create_new_if_exist' => $create_new_if_exist,
            'keep_convert_status' => $keep_convert_status,
            'stream_can_read' => $stream_can_read,
            'stream_can_write' => $stream_can_write,
            'stream_can_seek' => $stream_can_seek,
            'stream_can_timeout' => $stream_can_timeout,
            'stream_length' => $stream_length,
            'stream_position' => $stream_position,
            'stream_read_timeout' => $stream_read_timeout,
            'stream_write_timeout' => $stream_write_timeout,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation renameFolder
     *
     * Rename a folder
     *
     * REST API Reference for renameFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/rename-folder/
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function renameFolder($folder_id, $create_folder, string $contentType = self::contentTypes['renameFolder'][0])
    {
        list($response) = $this->renameFolderWithHttpInfo($folder_id, $create_folder, $contentType);
        return $response;
    }

    /**
     * Operation renameFolderWithHttpInfo
     *
     * Rename a folder
     *
     * REST API Reference for renameFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/rename-folder/
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function renameFolderWithHttpInfo($folder_id, $create_folder, string $contentType = self::contentTypes['renameFolder'][0])
    {
        $request = $this->renameFolderRequest($folder_id, $create_folder, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation renameFolderAsync
     *
     * Rename a folder
     *
     * REST API Reference for renameFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/rename-folder/
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameFolderAsync($folder_id, $create_folder, string $contentType = self::contentTypes['renameFolder'][0])
    {
        return $this->renameFolderAsyncWithHttpInfo($folder_id, $create_folder, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation renameFolderAsyncWithHttpInfo
     *
     * Rename a folder
     *
     * REST API Reference for renameFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/rename-folder/
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function renameFolderAsyncWithHttpInfo($folder_id, $create_folder, string $contentType = self::contentTypes['renameFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->renameFolderRequest($folder_id, $create_folder, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'renameFolder'
     *
     * @param  int $folder_id The folder ID for the folder creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFolder $create_folder The parameters for creating a folder. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['renameFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function renameFolderRequest($folder_id, $create_folder, string $contentType = self::contentTypes['renameFolder'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling renameFolder'
            );
        }

        // verify the required parameter 'create_folder' is set
        if ($create_folder === null || (is_array($create_folder) && count($create_folder) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_folder when calling renameFolder'
            );
        }


        $resourcePath = '/api/2.0/files/folder/{folderId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_folder)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_folder));
            } else {
                $httpBody = $create_folder;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setFolderOrder
     *
     * Set folder order
     *
     * REST API Reference for setFolderOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-folder-order/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The folder order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderOrder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function setFolderOrder($folder_id, $order_request_dto = null, string $contentType = self::contentTypes['setFolderOrder'][0])
    {
        list($response) = $this->setFolderOrderWithHttpInfo($folder_id, $order_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation setFolderOrderWithHttpInfo
     *
     * Set folder order
     *
     * REST API Reference for setFolderOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-folder-order/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The folder order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderOrder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function setFolderOrderWithHttpInfo($folder_id, $order_request_dto = null, string $contentType = self::contentTypes['setFolderOrder'][0])
    {
        $request = $this->setFolderOrderRequest($folder_id, $order_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setFolderOrderAsync
     *
     * Set folder order
     *
     * REST API Reference for setFolderOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-folder-order/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The folder order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFolderOrderAsync($folder_id, $order_request_dto = null, string $contentType = self::contentTypes['setFolderOrder'][0])
    {
        return $this->setFolderOrderAsyncWithHttpInfo($folder_id, $order_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setFolderOrderAsyncWithHttpInfo
     *
     * Set folder order
     *
     * REST API Reference for setFolderOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-folder-order/
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The folder order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFolderOrderAsyncWithHttpInfo($folder_id, $order_request_dto = null, string $contentType = self::contentTypes['setFolderOrder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->setFolderOrderRequest($folder_id, $order_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setFolderOrder'
     *
     * @param  int $folder_id The folder unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The folder order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setFolderOrderRequest($folder_id, $order_request_dto = null, string $contentType = self::contentTypes['setFolderOrder'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling setFolderOrder'
            );
        }



        $resourcePath = '/api/2.0/files/folder/{folderId}/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($order_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($order_request_dto));
            } else {
                $httpBody = $order_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setFolderPrimaryExternalLink
     *
     * Set the folder external link
     *
     * REST API Reference for setFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-folder-primary-external-link/
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareWrapper
     */
    public function setFolderPrimaryExternalLink($id, $folder_link_request, string $contentType = self::contentTypes['setFolderPrimaryExternalLink'][0])
    {
        list($response) = $this->setFolderPrimaryExternalLinkWithHttpInfo($id, $folder_link_request, $contentType);
        return $response;
    }

    /**
     * Operation setFolderPrimaryExternalLinkWithHttpInfo
     *
     * Set the folder external link
     *
     * REST API Reference for setFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-folder-primary-external-link/
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function setFolderPrimaryExternalLinkWithHttpInfo($id, $folder_link_request, string $contentType = self::contentTypes['setFolderPrimaryExternalLink'][0])
    {
        $request = $this->setFolderPrimaryExternalLinkRequest($id, $folder_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setFolderPrimaryExternalLinkAsync
     *
     * Set the folder external link
     *
     * REST API Reference for setFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-folder-primary-external-link/
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFolderPrimaryExternalLinkAsync($id, $folder_link_request, string $contentType = self::contentTypes['setFolderPrimaryExternalLink'][0])
    {
        return $this->setFolderPrimaryExternalLinkAsyncWithHttpInfo($id, $folder_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setFolderPrimaryExternalLinkAsyncWithHttpInfo
     *
     * Set the folder external link
     *
     * REST API Reference for setFolderPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-folder-primary-external-link/
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFolderPrimaryExternalLinkAsyncWithHttpInfo($id, $folder_link_request, string $contentType = self::contentTypes['setFolderPrimaryExternalLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareWrapper';
        $request = $this->setFolderPrimaryExternalLinkRequest($id, $folder_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setFolderPrimaryExternalLink'
     *
     * @param  int $id The folder ID. (required)
     * @param  \OpenAPI\Client\Model\FolderLinkRequest $folder_link_request The folder link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFolderPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setFolderPrimaryExternalLinkRequest($id, $folder_link_request, string $contentType = self::contentTypes['setFolderPrimaryExternalLink'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setFolderPrimaryExternalLink'
            );
        }

        // verify the required parameter 'folder_link_request' is set
        if ($folder_link_request === null || (is_array($folder_link_request) && count($folder_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_link_request when calling setFolderPrimaryExternalLink'
            );
        }


        $resourcePath = '/api/2.0/files/folder/{id}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($folder_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($folder_link_request));
            } else {
                $httpBody = $folder_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadFile
     *
     * Upload a file
     *
     * REST API Reference for uploadFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-file/
     *
     * @param  int $folder_id The folder ID to upload a file. (required)
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $upload_request_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectWrapper
     */
    public function uploadFile($folder_id, $upload_request_dto = null, string $contentType = self::contentTypes['uploadFile'][0])
    {
        list($response) = $this->uploadFileWithHttpInfo($folder_id, $upload_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation uploadFileWithHttpInfo
     *
     * Upload a file
     *
     * REST API Reference for uploadFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-file/
     *
     * @param  int $folder_id The folder ID to upload a file. (required)
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $upload_request_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadFileWithHttpInfo($folder_id, $upload_request_dto = null, string $contentType = self::contentTypes['uploadFile'][0])
    {
        $request = $this->uploadFileRequest($folder_id, $upload_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ObjectWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadFileAsync
     *
     * Upload a file
     *
     * REST API Reference for uploadFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-file/
     *
     * @param  int $folder_id The folder ID to upload a file. (required)
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $upload_request_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsync($folder_id, $upload_request_dto = null, string $contentType = self::contentTypes['uploadFile'][0])
    {
        return $this->uploadFileAsyncWithHttpInfo($folder_id, $upload_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFileAsyncWithHttpInfo
     *
     * Upload a file
     *
     * REST API Reference for uploadFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-file/
     *
     * @param  int $folder_id The folder ID to upload a file. (required)
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $upload_request_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsyncWithHttpInfo($folder_id, $upload_request_dto = null, string $contentType = self::contentTypes['uploadFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectWrapper';
        $request = $this->uploadFileRequest($folder_id, $upload_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadFile'
     *
     * @param  int $folder_id The folder ID to upload a file. (required)
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $upload_request_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadFileRequest($folder_id, $upload_request_dto = null, string $contentType = self::contentTypes['uploadFile'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling uploadFile'
            );
        }



        $resourcePath = '/api/2.0/files/{folderId}/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($upload_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($upload_request_dto));
            } else {
                $httpBody = $upload_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadFileToMy
     *
     * Upload a file to the My documents section
     *
     * REST API Reference for uploadFileToMy Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-file-to-my/
     *
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $in_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFileToMy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectWrapper
     */
    public function uploadFileToMy($in_dto = null, string $contentType = self::contentTypes['uploadFileToMy'][0])
    {
        list($response) = $this->uploadFileToMyWithHttpInfo($in_dto, $contentType);
        return $response;
    }

    /**
     * Operation uploadFileToMyWithHttpInfo
     *
     * Upload a file to the My documents section
     *
     * REST API Reference for uploadFileToMy Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-file-to-my/
     *
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $in_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFileToMy'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadFileToMyWithHttpInfo($in_dto = null, string $contentType = self::contentTypes['uploadFileToMy'][0])
    {
        $request = $this->uploadFileToMyRequest($in_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ObjectWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadFileToMyAsync
     *
     * Upload a file to the My documents section
     *
     * REST API Reference for uploadFileToMy Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-file-to-my/
     *
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $in_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFileToMy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileToMyAsync($in_dto = null, string $contentType = self::contentTypes['uploadFileToMy'][0])
    {
        return $this->uploadFileToMyAsyncWithHttpInfo($in_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFileToMyAsyncWithHttpInfo
     *
     * Upload a file to the My documents section
     *
     * REST API Reference for uploadFileToMy Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-file-to-my/
     *
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $in_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFileToMy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileToMyAsyncWithHttpInfo($in_dto = null, string $contentType = self::contentTypes['uploadFileToMy'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectWrapper';
        $request = $this->uploadFileToMyRequest($in_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadFileToMy'
     *
     * @param  \OpenAPI\Client\Model\UploadRequestDto|null $in_dto The request parameters for uploading a file. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFileToMy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadFileToMyRequest($in_dto = null, string $contentType = self::contentTypes['uploadFileToMy'][0])
    {



        $resourcePath = '/api/2.0/files/@my/upload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $in_dto,
            'inDto', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
