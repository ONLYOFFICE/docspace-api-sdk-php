<?php
/*
 * (c) Copyright Ascensio System SIA 2025
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Api
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.0.0
 * Contact: support@onlyoffice.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */


namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 *  Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FilesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addFileToRecent' => [
            'application/json',
        ],
        'addTemplates' => [
            'application/json',
        ],
        'changeVersionHistory' => [
            'application/json',
        ],
        'checkFillFormDraft' => [
            'application/json',
        ],
        'copyFileAs' => [
            'application/json',
        ],
        'createEditSession' => [
            'application/json',
        ],
        'createFile' => [
            'application/json',
        ],
        'createFileInMyDocuments' => [
            'application/json',
        ],
        'createFilePrimaryExternalLink' => [
            'application/json',
        ],
        'createHtmlFile' => [
            'application/json',
        ],
        'createHtmlFileInMyDocuments' => [
            'application/json',
        ],
        'createTextFile' => [
            'application/json',
        ],
        'createTextFileInMyDocuments' => [
            'application/json',
        ],
        'createThumbnails' => [
            'application/json',
        ],
        'deleteFile' => [
            'application/json',
        ],
        'deleteRecent' => [
            'application/json',
        ],
        'deleteTemplates' => [
            'application/json',
        ],
        'getAllFormRoles' => [
            'application/json',
        ],
        'getEditDiffUrl' => [
            'application/json',
        ],
        'getEditHistory' => [
            'application/json',
        ],
        'getFileHistory' => [
            'application/json',
        ],
        'getFileInfo' => [
            'application/json',
        ],
        'getFileLinks' => [
            'application/json',
        ],
        'getFilePrimaryExternalLink' => [
            'application/json',
        ],
        'getFileVersionInfo' => [
            'application/json',
        ],
        'getFillResult' => [
            'application/json',
        ],
        'getPresignedFileUri' => [
            'application/json',
        ],
        'getPresignedUri' => [
            'application/json',
        ],
        'getProtectedFileUsers' => [
            'application/json',
        ],
        'getReferenceData' => [
            'application/json',
        ],
        'isFormPDF' => [
            'application/json',
        ],
        'lockFile' => [
            'application/json',
        ],
        'manageFormFilling' => [
            'application/json',
        ],
        'openEditFile' => [
            'application/json',
        ],
        'restoreFileVersion' => [
            'application/json',
        ],
        'saveEditingFileFromForm' => [
            'multipart/form-data',
        ],
        'saveFileAsPdf' => [
            'application/json',
        ],
        'saveFormRoleMapping' => [
            'application/json',
        ],
        'setCustomFilterTag' => [
            'application/json',
        ],
        'setFileExternalLink' => [
            'application/json',
        ],
        'setFileOrder' => [
            'application/json',
        ],
        'setFilesOrder' => [
            'application/json',
        ],
        'startEditFile' => [
            'application/json',
        ],
        'startFillingFile' => [
            'application/json',
        ],
        'toggleFileFavorite' => [
            'application/json',
        ],
        'trackEditFile' => [
            'application/json',
        ],
        'updateFile' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }


    /**
     * Operation addFileToRecent
     *
     * REST API Reference for addFileToRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-file-to-recent/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFileToRecent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function addFileToRecent($file_id, string $contentType = self::contentTypes['addFileToRecent'][0])
    {
        list($response) = $this->addFileToRecentWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation addFileToRecentWithHttpInfo
     *
     * REST API Reference for addFileToRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-file-to-recent/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFileToRecent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function addFileToRecentWithHttpInfo($file_id, string $contentType = self::contentTypes['addFileToRecent'][0])
    {
        $request = $this->addFileToRecentRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addFileToRecentAsync
     *
     * REST API Reference for addFileToRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-file-to-recent/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFileToRecent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFileToRecentAsync($file_id, string $contentType = self::contentTypes['addFileToRecent'][0])
    {
        return $this->addFileToRecentAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addFileToRecentAsyncWithHttpInfo
     *
     * REST API Reference for addFileToRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-file-to-recent/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFileToRecent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFileToRecentAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['addFileToRecent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->addFileToRecentRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addFileToRecent'
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFileToRecent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addFileToRecentRequest($file_id, string $contentType = self::contentTypes['addFileToRecent'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling addFileToRecent'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation addTemplates
     *
     * REST API Reference for addTemplates Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-templates/
     *
     * @param  \OpenAPI\Client\Model\TemplatesRequestDto|null $templates_request_dto templates_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTemplates'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function addTemplates($templates_request_dto = null, string $contentType = self::contentTypes['addTemplates'][0])
    {
        list($response) = $this->addTemplatesWithHttpInfo($templates_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation addTemplatesWithHttpInfo
     *
     * REST API Reference for addTemplates Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-templates/
     *
     * @param  \OpenAPI\Client\Model\TemplatesRequestDto|null $templates_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTemplates'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function addTemplatesWithHttpInfo($templates_request_dto = null, string $contentType = self::contentTypes['addTemplates'][0])
    {
        $request = $this->addTemplatesRequest($templates_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addTemplatesAsync
     *
     * REST API Reference for addTemplates Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-templates/
     *
     * @param  \OpenAPI\Client\Model\TemplatesRequestDto|null $templates_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTemplatesAsync($templates_request_dto = null, string $contentType = self::contentTypes['addTemplates'][0])
    {
        return $this->addTemplatesAsyncWithHttpInfo($templates_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addTemplatesAsyncWithHttpInfo
     *
     * REST API Reference for addTemplates Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-templates/
     *
     * @param  \OpenAPI\Client\Model\TemplatesRequestDto|null $templates_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addTemplatesAsyncWithHttpInfo($templates_request_dto = null, string $contentType = self::contentTypes['addTemplates'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->addTemplatesRequest($templates_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addTemplates'
     *
     * @param  \OpenAPI\Client\Model\TemplatesRequestDto|null $templates_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addTemplatesRequest($templates_request_dto = null, string $contentType = self::contentTypes['addTemplates'][0])
    {



        $resourcePath = '/api/2.0/files/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($templates_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($templates_request_dto));
            } else {
                $httpBody = $templates_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeVersionHistory
     *
     * REST API Reference for changeVersionHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-version-history/
     *
     * @param  int $file_id The file Id to change its version history. (required)
     * @param  \OpenAPI\Client\Model\ChangeHistory $change_history The parameters for changing version history. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeVersionHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerArrayWrapper
     */
    public function changeVersionHistory($file_id, $change_history, string $contentType = self::contentTypes['changeVersionHistory'][0])
    {
        list($response) = $this->changeVersionHistoryWithHttpInfo($file_id, $change_history, $contentType);
        return $response;
    }

    /**
     * Operation changeVersionHistoryWithHttpInfo
     *
     * REST API Reference for changeVersionHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-version-history/
     *
     * @param  int $file_id The file Id to change its version history. (required)
     * @param  \OpenAPI\Client\Model\ChangeHistory $change_history The parameters for changing version history. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeVersionHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeVersionHistoryWithHttpInfo($file_id, $change_history, string $contentType = self::contentTypes['changeVersionHistory'][0])
    {
        $request = $this->changeVersionHistoryRequest($file_id, $change_history, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation changeVersionHistoryAsync
     *
     * REST API Reference for changeVersionHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-version-history/
     *
     * @param  int $file_id The file Id to change its version history. (required)
     * @param  \OpenAPI\Client\Model\ChangeHistory $change_history The parameters for changing version history. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeVersionHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeVersionHistoryAsync($file_id, $change_history, string $contentType = self::contentTypes['changeVersionHistory'][0])
    {
        return $this->changeVersionHistoryAsyncWithHttpInfo($file_id, $change_history, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeVersionHistoryAsyncWithHttpInfo
     *
     * REST API Reference for changeVersionHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-version-history/
     *
     * @param  int $file_id The file Id to change its version history. (required)
     * @param  \OpenAPI\Client\Model\ChangeHistory $change_history The parameters for changing version history. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeVersionHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeVersionHistoryAsyncWithHttpInfo($file_id, $change_history, string $contentType = self::contentTypes['changeVersionHistory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerArrayWrapper';
        $request = $this->changeVersionHistoryRequest($file_id, $change_history, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeVersionHistory'
     *
     * @param  int $file_id The file Id to change its version history. (required)
     * @param  \OpenAPI\Client\Model\ChangeHistory $change_history The parameters for changing version history. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeVersionHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function changeVersionHistoryRequest($file_id, $change_history, string $contentType = self::contentTypes['changeVersionHistory'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling changeVersionHistory'
            );
        }

        // verify the required parameter 'change_history' is set
        if ($change_history === null || (is_array($change_history) && count($change_history) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $change_history when calling changeVersionHistory'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($change_history)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($change_history));
            } else {
                $httpBody = $change_history;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkFillFormDraft
     *
     * REST API Reference for checkFillFormDraft Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-fill-form-draft/
     *
     * @param  int $file_id The file ID of the form draft. (required)
     * @param  \OpenAPI\Client\Model\CheckFillFormDraft $check_fill_form_draft The parameters for checking the form draft filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkFillFormDraft'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringWrapper
     */
    public function checkFillFormDraft($file_id, $check_fill_form_draft, string $contentType = self::contentTypes['checkFillFormDraft'][0])
    {
        list($response) = $this->checkFillFormDraftWithHttpInfo($file_id, $check_fill_form_draft, $contentType);
        return $response;
    }

    /**
     * Operation checkFillFormDraftWithHttpInfo
     *
     * REST API Reference for checkFillFormDraft Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-fill-form-draft/
     *
     * @param  int $file_id The file ID of the form draft. (required)
     * @param  \OpenAPI\Client\Model\CheckFillFormDraft $check_fill_form_draft The parameters for checking the form draft filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkFillFormDraft'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkFillFormDraftWithHttpInfo($file_id, $check_fill_form_draft, string $contentType = self::contentTypes['checkFillFormDraft'][0])
    {
        $request = $this->checkFillFormDraftRequest($file_id, $check_fill_form_draft, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkFillFormDraftAsync
     *
     * REST API Reference for checkFillFormDraft Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-fill-form-draft/
     *
     * @param  int $file_id The file ID of the form draft. (required)
     * @param  \OpenAPI\Client\Model\CheckFillFormDraft $check_fill_form_draft The parameters for checking the form draft filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkFillFormDraft'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkFillFormDraftAsync($file_id, $check_fill_form_draft, string $contentType = self::contentTypes['checkFillFormDraft'][0])
    {
        return $this->checkFillFormDraftAsyncWithHttpInfo($file_id, $check_fill_form_draft, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkFillFormDraftAsyncWithHttpInfo
     *
     * REST API Reference for checkFillFormDraft Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-fill-form-draft/
     *
     * @param  int $file_id The file ID of the form draft. (required)
     * @param  \OpenAPI\Client\Model\CheckFillFormDraft $check_fill_form_draft The parameters for checking the form draft filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkFillFormDraft'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkFillFormDraftAsyncWithHttpInfo($file_id, $check_fill_form_draft, string $contentType = self::contentTypes['checkFillFormDraft'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StringWrapper';
        $request = $this->checkFillFormDraftRequest($file_id, $check_fill_form_draft, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkFillFormDraft'
     *
     * @param  int $file_id The file ID of the form draft. (required)
     * @param  \OpenAPI\Client\Model\CheckFillFormDraft $check_fill_form_draft The parameters for checking the form draft filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkFillFormDraft'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkFillFormDraftRequest($file_id, $check_fill_form_draft, string $contentType = self::contentTypes['checkFillFormDraft'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling checkFillFormDraft'
            );
        }

        // verify the required parameter 'check_fill_form_draft' is set
        if ($check_fill_form_draft === null || (is_array($check_fill_form_draft) && count($check_fill_form_draft) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $check_fill_form_draft when calling checkFillFormDraft'
            );
        }


        $resourcePath = '/api/2.0/files/masterform/{fileId}/checkfillformdraft';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($check_fill_form_draft)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($check_fill_form_draft));
            } else {
                $httpBody = $check_fill_form_draft;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyFileAs
     *
     * REST API Reference for copyFileAs Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/copy-file-as/
     *
     * @param  int $file_id The file ID to copy. (required)
     * @param  \OpenAPI\Client\Model\CopyAsJsonElement $copy_as_json_element The parameters for copying a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileAs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileEntryBaseWrapper
     */
    public function copyFileAs($file_id, $copy_as_json_element, string $contentType = self::contentTypes['copyFileAs'][0])
    {
        list($response) = $this->copyFileAsWithHttpInfo($file_id, $copy_as_json_element, $contentType);
        return $response;
    }

    /**
     * Operation copyFileAsWithHttpInfo
     *
     * REST API Reference for copyFileAs Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/copy-file-as/
     *
     * @param  int $file_id The file ID to copy. (required)
     * @param  \OpenAPI\Client\Model\CopyAsJsonElement $copy_as_json_element The parameters for copying a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileAs'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileEntryBaseWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyFileAsWithHttpInfo($file_id, $copy_as_json_element, string $contentType = self::contentTypes['copyFileAs'][0])
    {
        $request = $this->copyFileAsRequest($file_id, $copy_as_json_element, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileEntryBaseWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileEntryBaseWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileEntryBaseWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation copyFileAsAsync
     *
     * REST API Reference for copyFileAs Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/copy-file-as/
     *
     * @param  int $file_id The file ID to copy. (required)
     * @param  \OpenAPI\Client\Model\CopyAsJsonElement $copy_as_json_element The parameters for copying a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileAs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileAsAsync($file_id, $copy_as_json_element, string $contentType = self::contentTypes['copyFileAs'][0])
    {
        return $this->copyFileAsAsyncWithHttpInfo($file_id, $copy_as_json_element, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyFileAsAsyncWithHttpInfo
     *
     * REST API Reference for copyFileAs Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/copy-file-as/
     *
     * @param  int $file_id The file ID to copy. (required)
     * @param  \OpenAPI\Client\Model\CopyAsJsonElement $copy_as_json_element The parameters for copying a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileAs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyFileAsAsyncWithHttpInfo($file_id, $copy_as_json_element, string $contentType = self::contentTypes['copyFileAs'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileEntryBaseWrapper';
        $request = $this->copyFileAsRequest($file_id, $copy_as_json_element, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyFileAs'
     *
     * @param  int $file_id The file ID to copy. (required)
     * @param  \OpenAPI\Client\Model\CopyAsJsonElement $copy_as_json_element The parameters for copying a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyFileAs'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function copyFileAsRequest($file_id, $copy_as_json_element, string $contentType = self::contentTypes['copyFileAs'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling copyFileAs'
            );
        }

        // verify the required parameter 'copy_as_json_element' is set
        if ($copy_as_json_element === null || (is_array($copy_as_json_element) && count($copy_as_json_element) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $copy_as_json_element when calling copyFileAs'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/copyas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($copy_as_json_element)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($copy_as_json_element));
            } else {
                $httpBody = $copy_as_json_element;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEditSession
     *
     * REST API Reference for createEditSession Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-edit-session/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $file_size The file size in bytes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEditSession'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectWrapper
     */
    public function createEditSession($file_id, $file_size = null, string $contentType = self::contentTypes['createEditSession'][0])
    {
        list($response) = $this->createEditSessionWithHttpInfo($file_id, $file_size, $contentType);
        return $response;
    }

    /**
     * Operation createEditSessionWithHttpInfo
     *
     * REST API Reference for createEditSession Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-edit-session/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $file_size The file size in bytes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEditSession'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEditSessionWithHttpInfo($file_id, $file_size = null, string $contentType = self::contentTypes['createEditSession'][0])
    {
        $request = $this->createEditSessionRequest($file_id, $file_size, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ObjectWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createEditSessionAsync
     *
     * REST API Reference for createEditSession Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-edit-session/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $file_size The file size in bytes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEditSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEditSessionAsync($file_id, $file_size = null, string $contentType = self::contentTypes['createEditSession'][0])
    {
        return $this->createEditSessionAsyncWithHttpInfo($file_id, $file_size, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEditSessionAsyncWithHttpInfo
     *
     * REST API Reference for createEditSession Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-edit-session/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $file_size The file size in bytes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEditSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEditSessionAsyncWithHttpInfo($file_id, $file_size = null, string $contentType = self::contentTypes['createEditSession'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectWrapper';
        $request = $this->createEditSessionRequest($file_id, $file_size, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEditSession'
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $file_size The file size in bytes. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEditSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEditSessionRequest($file_id, $file_size = null, string $contentType = self::contentTypes['createEditSession'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling createEditSession'
            );
        }



        $resourcePath = '/api/2.0/files/file/{fileId}/edit_session';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $file_size,
            'fileSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFile
     *
     * REST API Reference for createFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file/
     *
     * @param  int $folder_id The folder ID for the file creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement $create_file_json_element The parameters for creating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function createFile($folder_id, $create_file_json_element, string $contentType = self::contentTypes['createFile'][0])
    {
        list($response) = $this->createFileWithHttpInfo($folder_id, $create_file_json_element, $contentType);
        return $response;
    }

    /**
     * Operation createFileWithHttpInfo
     *
     * REST API Reference for createFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file/
     *
     * @param  int $folder_id The folder ID for the file creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement $create_file_json_element The parameters for creating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFileWithHttpInfo($folder_id, $create_file_json_element, string $contentType = self::contentTypes['createFile'][0])
    {
        $request = $this->createFileRequest($folder_id, $create_file_json_element, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFileAsync
     *
     * REST API Reference for createFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file/
     *
     * @param  int $folder_id The folder ID for the file creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement $create_file_json_element The parameters for creating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFileAsync($folder_id, $create_file_json_element, string $contentType = self::contentTypes['createFile'][0])
    {
        return $this->createFileAsyncWithHttpInfo($folder_id, $create_file_json_element, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFileAsyncWithHttpInfo
     *
     * REST API Reference for createFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file/
     *
     * @param  int $folder_id The folder ID for the file creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement $create_file_json_element The parameters for creating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFileAsyncWithHttpInfo($folder_id, $create_file_json_element, string $contentType = self::contentTypes['createFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->createFileRequest($folder_id, $create_file_json_element, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFile'
     *
     * @param  int $folder_id The folder ID for the file creation. (required)
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement $create_file_json_element The parameters for creating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFileRequest($folder_id, $create_file_json_element, string $contentType = self::contentTypes['createFile'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling createFile'
            );
        }

        // verify the required parameter 'create_file_json_element' is set
        if ($create_file_json_element === null || (is_array($create_file_json_element) && count($create_file_json_element) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_file_json_element when calling createFile'
            );
        }


        $resourcePath = '/api/2.0/files/{folderId}/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_file_json_element)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_file_json_element));
            } else {
                $httpBody = $create_file_json_element;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFileInMyDocuments
     *
     * REST API Reference for createFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement|null $create_file_json_element create_file_json_element (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function createFileInMyDocuments($create_file_json_element = null, string $contentType = self::contentTypes['createFileInMyDocuments'][0])
    {
        list($response) = $this->createFileInMyDocumentsWithHttpInfo($create_file_json_element, $contentType);
        return $response;
    }

    /**
     * Operation createFileInMyDocumentsWithHttpInfo
     *
     * REST API Reference for createFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement|null $create_file_json_element (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFileInMyDocumentsWithHttpInfo($create_file_json_element = null, string $contentType = self::contentTypes['createFileInMyDocuments'][0])
    {
        $request = $this->createFileInMyDocumentsRequest($create_file_json_element, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFileInMyDocumentsAsync
     *
     * REST API Reference for createFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement|null $create_file_json_element (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFileInMyDocumentsAsync($create_file_json_element = null, string $contentType = self::contentTypes['createFileInMyDocuments'][0])
    {
        return $this->createFileInMyDocumentsAsyncWithHttpInfo($create_file_json_element, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFileInMyDocumentsAsyncWithHttpInfo
     *
     * REST API Reference for createFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement|null $create_file_json_element (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFileInMyDocumentsAsyncWithHttpInfo($create_file_json_element = null, string $contentType = self::contentTypes['createFileInMyDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->createFileInMyDocumentsRequest($create_file_json_element, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFileInMyDocuments'
     *
     * @param  \OpenAPI\Client\Model\CreateFileJsonElement|null $create_file_json_element (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFileInMyDocumentsRequest($create_file_json_element = null, string $contentType = self::contentTypes['createFileInMyDocuments'][0])
    {



        $resourcePath = '/api/2.0/files/@my/file';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_file_json_element)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_file_json_element));
            } else {
                $httpBody = $create_file_json_element;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createFilePrimaryExternalLink
     *
     * REST API Reference for createFilePrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file-primary-external-link/
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareWrapper
     */
    public function createFilePrimaryExternalLink($id, $file_link_request, string $contentType = self::contentTypes['createFilePrimaryExternalLink'][0])
    {
        list($response) = $this->createFilePrimaryExternalLinkWithHttpInfo($id, $file_link_request, $contentType);
        return $response;
    }

    /**
     * Operation createFilePrimaryExternalLinkWithHttpInfo
     *
     * REST API Reference for createFilePrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file-primary-external-link/
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createFilePrimaryExternalLinkWithHttpInfo($id, $file_link_request, string $contentType = self::contentTypes['createFilePrimaryExternalLink'][0])
    {
        $request = $this->createFilePrimaryExternalLinkRequest($id, $file_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createFilePrimaryExternalLinkAsync
     *
     * REST API Reference for createFilePrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file-primary-external-link/
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFilePrimaryExternalLinkAsync($id, $file_link_request, string $contentType = self::contentTypes['createFilePrimaryExternalLink'][0])
    {
        return $this->createFilePrimaryExternalLinkAsyncWithHttpInfo($id, $file_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFilePrimaryExternalLinkAsyncWithHttpInfo
     *
     * REST API Reference for createFilePrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-file-primary-external-link/
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFilePrimaryExternalLinkAsyncWithHttpInfo($id, $file_link_request, string $contentType = self::contentTypes['createFilePrimaryExternalLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareWrapper';
        $request = $this->createFilePrimaryExternalLinkRequest($id, $file_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createFilePrimaryExternalLink'
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFilePrimaryExternalLinkRequest($id, $file_link_request, string $contentType = self::contentTypes['createFilePrimaryExternalLink'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createFilePrimaryExternalLink'
            );
        }

        // verify the required parameter 'file_link_request' is set
        if ($file_link_request === null || (is_array($file_link_request) && count($file_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_link_request when calling createFilePrimaryExternalLink'
            );
        }


        $resourcePath = '/api/2.0/files/file/{id}/link';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($file_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($file_link_request));
            } else {
                $httpBody = $file_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createHtmlFile
     *
     * REST API Reference for createHtmlFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-html-file/
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function createHtmlFile($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createHtmlFile'][0])
    {
        list($response) = $this->createHtmlFileWithHttpInfo($folder_id, $create_text_or_html_file, $contentType);
        return $response;
    }

    /**
     * Operation createHtmlFileWithHttpInfo
     *
     * REST API Reference for createHtmlFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-html-file/
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createHtmlFileWithHttpInfo($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createHtmlFile'][0])
    {
        $request = $this->createHtmlFileRequest($folder_id, $create_text_or_html_file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createHtmlFileAsync
     *
     * REST API Reference for createHtmlFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-html-file/
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHtmlFileAsync($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createHtmlFile'][0])
    {
        return $this->createHtmlFileAsyncWithHttpInfo($folder_id, $create_text_or_html_file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createHtmlFileAsyncWithHttpInfo
     *
     * REST API Reference for createHtmlFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-html-file/
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHtmlFileAsyncWithHttpInfo($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createHtmlFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->createHtmlFileRequest($folder_id, $create_text_or_html_file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createHtmlFile'
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createHtmlFileRequest($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createHtmlFile'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling createHtmlFile'
            );
        }

        // verify the required parameter 'create_text_or_html_file' is set
        if ($create_text_or_html_file === null || (is_array($create_text_or_html_file) && count($create_text_or_html_file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_text_or_html_file when calling createHtmlFile'
            );
        }


        $resourcePath = '/api/2.0/files/{folderId}/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_text_or_html_file)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_text_or_html_file));
            } else {
                $httpBody = $create_text_or_html_file;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createHtmlFileInMyDocuments
     *
     * REST API Reference for createHtmlFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-html-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function createHtmlFileInMyDocuments($create_text_or_html_file = null, string $contentType = self::contentTypes['createHtmlFileInMyDocuments'][0])
    {
        list($response) = $this->createHtmlFileInMyDocumentsWithHttpInfo($create_text_or_html_file, $contentType);
        return $response;
    }

    /**
     * Operation createHtmlFileInMyDocumentsWithHttpInfo
     *
     * REST API Reference for createHtmlFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-html-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createHtmlFileInMyDocumentsWithHttpInfo($create_text_or_html_file = null, string $contentType = self::contentTypes['createHtmlFileInMyDocuments'][0])
    {
        $request = $this->createHtmlFileInMyDocumentsRequest($create_text_or_html_file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createHtmlFileInMyDocumentsAsync
     *
     * REST API Reference for createHtmlFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-html-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHtmlFileInMyDocumentsAsync($create_text_or_html_file = null, string $contentType = self::contentTypes['createHtmlFileInMyDocuments'][0])
    {
        return $this->createHtmlFileInMyDocumentsAsyncWithHttpInfo($create_text_or_html_file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createHtmlFileInMyDocumentsAsyncWithHttpInfo
     *
     * REST API Reference for createHtmlFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-html-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createHtmlFileInMyDocumentsAsyncWithHttpInfo($create_text_or_html_file = null, string $contentType = self::contentTypes['createHtmlFileInMyDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->createHtmlFileInMyDocumentsRequest($create_text_or_html_file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createHtmlFileInMyDocuments'
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createHtmlFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createHtmlFileInMyDocumentsRequest($create_text_or_html_file = null, string $contentType = self::contentTypes['createHtmlFileInMyDocuments'][0])
    {



        $resourcePath = '/api/2.0/files/@my/html';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_text_or_html_file)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_text_or_html_file));
            } else {
                $httpBody = $create_text_or_html_file;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTextFile
     *
     * REST API Reference for createTextFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-text-file/
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function createTextFile($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createTextFile'][0])
    {
        list($response) = $this->createTextFileWithHttpInfo($folder_id, $create_text_or_html_file, $contentType);
        return $response;
    }

    /**
     * Operation createTextFileWithHttpInfo
     *
     * REST API Reference for createTextFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-text-file/
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTextFileWithHttpInfo($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createTextFile'][0])
    {
        $request = $this->createTextFileRequest($folder_id, $create_text_or_html_file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTextFileAsync
     *
     * REST API Reference for createTextFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-text-file/
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTextFileAsync($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createTextFile'][0])
    {
        return $this->createTextFileAsyncWithHttpInfo($folder_id, $create_text_or_html_file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTextFileAsyncWithHttpInfo
     *
     * REST API Reference for createTextFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-text-file/
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTextFileAsyncWithHttpInfo($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createTextFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->createTextFileRequest($folder_id, $create_text_or_html_file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTextFile'
     *
     * @param  int $folder_id The folder ID to create the text or HTML file. (required)
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile $create_text_or_html_file The parameters for creating an HTML or text file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTextFileRequest($folder_id, $create_text_or_html_file, string $contentType = self::contentTypes['createTextFile'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling createTextFile'
            );
        }

        // verify the required parameter 'create_text_or_html_file' is set
        if ($create_text_or_html_file === null || (is_array($create_text_or_html_file) && count($create_text_or_html_file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_text_or_html_file when calling createTextFile'
            );
        }


        $resourcePath = '/api/2.0/files/{folderId}/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_text_or_html_file)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_text_or_html_file));
            } else {
                $httpBody = $create_text_or_html_file;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTextFileInMyDocuments
     *
     * REST API Reference for createTextFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-text-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function createTextFileInMyDocuments($create_text_or_html_file = null, string $contentType = self::contentTypes['createTextFileInMyDocuments'][0])
    {
        list($response) = $this->createTextFileInMyDocumentsWithHttpInfo($create_text_or_html_file, $contentType);
        return $response;
    }

    /**
     * Operation createTextFileInMyDocumentsWithHttpInfo
     *
     * REST API Reference for createTextFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-text-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTextFileInMyDocumentsWithHttpInfo($create_text_or_html_file = null, string $contentType = self::contentTypes['createTextFileInMyDocuments'][0])
    {
        $request = $this->createTextFileInMyDocumentsRequest($create_text_or_html_file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTextFileInMyDocumentsAsync
     *
     * REST API Reference for createTextFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-text-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTextFileInMyDocumentsAsync($create_text_or_html_file = null, string $contentType = self::contentTypes['createTextFileInMyDocuments'][0])
    {
        return $this->createTextFileInMyDocumentsAsyncWithHttpInfo($create_text_or_html_file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTextFileInMyDocumentsAsyncWithHttpInfo
     *
     * REST API Reference for createTextFileInMyDocuments Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-text-file-in-my-documents/
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTextFileInMyDocumentsAsyncWithHttpInfo($create_text_or_html_file = null, string $contentType = self::contentTypes['createTextFileInMyDocuments'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->createTextFileInMyDocumentsRequest($create_text_or_html_file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTextFileInMyDocuments'
     *
     * @param  \OpenAPI\Client\Model\CreateTextOrHtmlFile|null $create_text_or_html_file (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTextFileInMyDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTextFileInMyDocumentsRequest($create_text_or_html_file = null, string $contentType = self::contentTypes['createTextFileInMyDocuments'][0])
    {



        $resourcePath = '/api/2.0/files/@my/text';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_text_or_html_file)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_text_or_html_file));
            } else {
                $httpBody = $create_text_or_html_file;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createThumbnails
     *
     * REST API Reference for createThumbnails Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-thumbnails/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThumbnails'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectArrayWrapper
     */
    public function createThumbnails($base_batch_request_dto = null, string $contentType = self::contentTypes['createThumbnails'][0])
    {
        list($response) = $this->createThumbnailsWithHttpInfo($base_batch_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation createThumbnailsWithHttpInfo
     *
     * REST API Reference for createThumbnails Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-thumbnails/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThumbnails'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createThumbnailsWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['createThumbnails'][0])
    {
        $request = $this->createThumbnailsRequest($base_batch_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ObjectArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ObjectArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createThumbnailsAsync
     *
     * REST API Reference for createThumbnails Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-thumbnails/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThumbnails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createThumbnailsAsync($base_batch_request_dto = null, string $contentType = self::contentTypes['createThumbnails'][0])
    {
        return $this->createThumbnailsAsyncWithHttpInfo($base_batch_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createThumbnailsAsyncWithHttpInfo
     *
     * REST API Reference for createThumbnails Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-thumbnails/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThumbnails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createThumbnailsAsyncWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['createThumbnails'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectArrayWrapper';
        $request = $this->createThumbnailsRequest($base_batch_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createThumbnails'
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createThumbnails'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createThumbnailsRequest($base_batch_request_dto = null, string $contentType = self::contentTypes['createThumbnails'][0])
    {



        $resourcePath = '/api/2.0/files/thumbnails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($base_batch_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($base_batch_request_dto));
            } else {
                $httpBody = $base_batch_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFile
     *
     * REST API Reference for deleteFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-file/
     *
     * @param  int $file_id The file ID to delete. (required)
     * @param  \OpenAPI\Client\Model\Delete $delete The parameters for deleting a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function deleteFile($file_id, $delete, string $contentType = self::contentTypes['deleteFile'][0])
    {
        list($response) = $this->deleteFileWithHttpInfo($file_id, $delete, $contentType);
        return $response;
    }

    /**
     * Operation deleteFileWithHttpInfo
     *
     * REST API Reference for deleteFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-file/
     *
     * @param  int $file_id The file ID to delete. (required)
     * @param  \OpenAPI\Client\Model\Delete $delete The parameters for deleting a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileWithHttpInfo($file_id, $delete, string $contentType = self::contentTypes['deleteFile'][0])
    {
        $request = $this->deleteFileRequest($file_id, $delete, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFileAsync
     *
     * REST API Reference for deleteFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-file/
     *
     * @param  int $file_id The file ID to delete. (required)
     * @param  \OpenAPI\Client\Model\Delete $delete The parameters for deleting a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsync($file_id, $delete, string $contentType = self::contentTypes['deleteFile'][0])
    {
        return $this->deleteFileAsyncWithHttpInfo($file_id, $delete, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileAsyncWithHttpInfo
     *
     * REST API Reference for deleteFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-file/
     *
     * @param  int $file_id The file ID to delete. (required)
     * @param  \OpenAPI\Client\Model\Delete $delete The parameters for deleting a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileAsyncWithHttpInfo($file_id, $delete, string $contentType = self::contentTypes['deleteFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->deleteFileRequest($file_id, $delete, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFile'
     *
     * @param  int $file_id The file ID to delete. (required)
     * @param  \OpenAPI\Client\Model\Delete $delete The parameters for deleting a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFileRequest($file_id, $delete, string $contentType = self::contentTypes['deleteFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling deleteFile'
            );
        }

        // verify the required parameter 'delete' is set
        if ($delete === null || (is_array($delete) && count($delete) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delete when calling deleteFile'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($delete)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($delete));
            } else {
                $httpBody = $delete;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRecent
     *
     * REST API Reference for deleteRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-recent/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\NoContentResultWrapper
     */
    public function deleteRecent($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteRecent'][0])
    {
        list($response) = $this->deleteRecentWithHttpInfo($base_batch_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation deleteRecentWithHttpInfo
     *
     * REST API Reference for deleteRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-recent/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\NoContentResultWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRecentWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteRecent'][0])
    {
        $request = $this->deleteRecentRequest($base_batch_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\NoContentResultWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\NoContentResultWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\NoContentResultWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRecentAsync
     *
     * REST API Reference for deleteRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-recent/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecentAsync($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteRecent'][0])
    {
        return $this->deleteRecentAsyncWithHttpInfo($base_batch_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRecentAsyncWithHttpInfo
     *
     * REST API Reference for deleteRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-recent/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRecentAsyncWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteRecent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\NoContentResultWrapper';
        $request = $this->deleteRecentRequest($base_batch_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRecent'
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRecent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRecentRequest($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteRecent'][0])
    {



        $resourcePath = '/api/2.0/files/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($base_batch_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($base_batch_request_dto));
            } else {
                $httpBody = $base_batch_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTemplates
     *
     * REST API Reference for deleteTemplates Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-templates/
     *
     * @param  int[]|null $request_body The file IDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplates'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function deleteTemplates($request_body = null, string $contentType = self::contentTypes['deleteTemplates'][0])
    {
        list($response) = $this->deleteTemplatesWithHttpInfo($request_body, $contentType);
        return $response;
    }

    /**
     * Operation deleteTemplatesWithHttpInfo
     *
     * REST API Reference for deleteTemplates Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-templates/
     *
     * @param  int[]|null $request_body The file IDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplates'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTemplatesWithHttpInfo($request_body = null, string $contentType = self::contentTypes['deleteTemplates'][0])
    {
        $request = $this->deleteTemplatesRequest($request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteTemplatesAsync
     *
     * REST API Reference for deleteTemplates Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-templates/
     *
     * @param  int[]|null $request_body The file IDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplatesAsync($request_body = null, string $contentType = self::contentTypes['deleteTemplates'][0])
    {
        return $this->deleteTemplatesAsyncWithHttpInfo($request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTemplatesAsyncWithHttpInfo
     *
     * REST API Reference for deleteTemplates Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-templates/
     *
     * @param  int[]|null $request_body The file IDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTemplatesAsyncWithHttpInfo($request_body = null, string $contentType = self::contentTypes['deleteTemplates'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->deleteTemplatesRequest($request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTemplates'
     *
     * @param  int[]|null $request_body The file IDs. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteTemplates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTemplatesRequest($request_body = null, string $contentType = self::contentTypes['deleteTemplates'][0])
    {



        $resourcePath = '/api/2.0/files/templates';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllFormRoles
     *
     * REST API Reference for getAllFormRoles Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-all-form-roles/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllFormRoles'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FormRoleArrayWrapper
     */
    public function getAllFormRoles($file_id, string $contentType = self::contentTypes['getAllFormRoles'][0])
    {
        list($response) = $this->getAllFormRolesWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation getAllFormRolesWithHttpInfo
     *
     * REST API Reference for getAllFormRoles Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-all-form-roles/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllFormRoles'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FormRoleArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllFormRolesWithHttpInfo($file_id, string $contentType = self::contentTypes['getAllFormRoles'][0])
    {
        $request = $this->getAllFormRolesRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FormRoleArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FormRoleArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FormRoleArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAllFormRolesAsync
     *
     * REST API Reference for getAllFormRoles Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-all-form-roles/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllFormRoles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllFormRolesAsync($file_id, string $contentType = self::contentTypes['getAllFormRoles'][0])
    {
        return $this->getAllFormRolesAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllFormRolesAsyncWithHttpInfo
     *
     * REST API Reference for getAllFormRoles Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-all-form-roles/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllFormRoles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllFormRolesAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['getAllFormRoles'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FormRoleArrayWrapper';
        $request = $this->getAllFormRolesRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllFormRoles'
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllFormRoles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllFormRolesRequest($file_id, string $contentType = self::contentTypes['getAllFormRoles'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling getAllFormRoles'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/formroles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEditDiffUrl
     *
     * REST API Reference for getEditDiffUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-edit-diff-url/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditDiffUrl'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EditHistoryDataWrapper
     */
    public function getEditDiffUrl($file_id, $version = null, string $contentType = self::contentTypes['getEditDiffUrl'][0])
    {
        list($response) = $this->getEditDiffUrlWithHttpInfo($file_id, $version, $contentType);
        return $response;
    }

    /**
     * Operation getEditDiffUrlWithHttpInfo
     *
     * REST API Reference for getEditDiffUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-edit-diff-url/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditDiffUrl'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EditHistoryDataWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEditDiffUrlWithHttpInfo($file_id, $version = null, string $contentType = self::contentTypes['getEditDiffUrl'][0])
    {
        $request = $this->getEditDiffUrlRequest($file_id, $version, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\EditHistoryDataWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\EditHistoryDataWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EditHistoryDataWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEditDiffUrlAsync
     *
     * REST API Reference for getEditDiffUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-edit-diff-url/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditDiffUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEditDiffUrlAsync($file_id, $version = null, string $contentType = self::contentTypes['getEditDiffUrl'][0])
    {
        return $this->getEditDiffUrlAsyncWithHttpInfo($file_id, $version, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEditDiffUrlAsyncWithHttpInfo
     *
     * REST API Reference for getEditDiffUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-edit-diff-url/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditDiffUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEditDiffUrlAsyncWithHttpInfo($file_id, $version = null, string $contentType = self::contentTypes['getEditDiffUrl'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EditHistoryDataWrapper';
        $request = $this->getEditDiffUrlRequest($file_id, $version, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEditDiffUrl'
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditDiffUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEditDiffUrlRequest($file_id, $version = null, string $contentType = self::contentTypes['getEditDiffUrl'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling getEditDiffUrl'
            );
        }



        $resourcePath = '/api/2.0/files/file/{fileId}/edit/diff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEditHistory
     *
     * REST API Reference for getEditHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-edit-history/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EditHistoryArrayWrapper
     */
    public function getEditHistory($file_id, string $contentType = self::contentTypes['getEditHistory'][0])
    {
        list($response) = $this->getEditHistoryWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation getEditHistoryWithHttpInfo
     *
     * REST API Reference for getEditHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-edit-history/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EditHistoryArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEditHistoryWithHttpInfo($file_id, string $contentType = self::contentTypes['getEditHistory'][0])
    {
        $request = $this->getEditHistoryRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\EditHistoryArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\EditHistoryArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EditHistoryArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getEditHistoryAsync
     *
     * REST API Reference for getEditHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-edit-history/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEditHistoryAsync($file_id, string $contentType = self::contentTypes['getEditHistory'][0])
    {
        return $this->getEditHistoryAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEditHistoryAsyncWithHttpInfo
     *
     * REST API Reference for getEditHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-edit-history/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEditHistoryAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['getEditHistory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EditHistoryArrayWrapper';
        $request = $this->getEditHistoryRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEditHistory'
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getEditHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getEditHistoryRequest($file_id, string $contentType = self::contentTypes['getEditHistory'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling getEditHistory'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/edit/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileHistory
     *
     * REST API Reference for getFileHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-history/
     *
     * @param  int $file_id The file ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history. (optional)
     * @param  int|null $count The number of history entries to retrieve for the file log. (optional)
     * @param  int|null $start_index The starting index for retrieving a subset of file history entries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HistoryArrayWrapper
     */
    public function getFileHistory($file_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileHistory'][0])
    {
        list($response) = $this->getFileHistoryWithHttpInfo($file_id, $from_date, $to_date, $count, $start_index, $contentType);
        return $response;
    }

    /**
     * Operation getFileHistoryWithHttpInfo
     *
     * REST API Reference for getFileHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-history/
     *
     * @param  int $file_id The file ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history. (optional)
     * @param  int|null $count The number of history entries to retrieve for the file log. (optional)
     * @param  int|null $start_index The starting index for retrieving a subset of file history entries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileHistory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HistoryArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileHistoryWithHttpInfo($file_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileHistory'][0])
    {
        $request = $this->getFileHistoryRequest($file_id, $from_date, $to_date, $count, $start_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HistoryArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HistoryArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HistoryArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFileHistoryAsync
     *
     * REST API Reference for getFileHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-history/
     *
     * @param  int $file_id The file ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history. (optional)
     * @param  int|null $count The number of history entries to retrieve for the file log. (optional)
     * @param  int|null $start_index The starting index for retrieving a subset of file history entries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileHistoryAsync($file_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileHistory'][0])
    {
        return $this->getFileHistoryAsyncWithHttpInfo($file_id, $from_date, $to_date, $count, $start_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileHistoryAsyncWithHttpInfo
     *
     * REST API Reference for getFileHistory Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-history/
     *
     * @param  int $file_id The file ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history. (optional)
     * @param  int|null $count The number of history entries to retrieve for the file log. (optional)
     * @param  int|null $start_index The starting index for retrieving a subset of file history entries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileHistoryAsyncWithHttpInfo($file_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileHistory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HistoryArrayWrapper';
        $request = $this->getFileHistoryRequest($file_id, $from_date, $to_date, $count, $start_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileHistory'
     *
     * @param  int $file_id The file ID of the history request. (required)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $from_date The start date of the history. (optional)
     * @param  \OpenAPI\Client\Model\ApiDateTime|null $to_date The end date of the history. (optional)
     * @param  int|null $count The number of history entries to retrieve for the file log. (optional)
     * @param  int|null $start_index The starting index for retrieving a subset of file history entries. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileHistory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileHistoryRequest($file_id, $from_date = null, $to_date = null, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileHistory'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling getFileHistory'
            );
        }



        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FilesApi.getFileHistory, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FilesApi.getFileHistory, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/api/2.0/files/file/{fileId}/log';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $from_date,
            'fromDate', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $to_date,
            'toDate', // param base name
            'object', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileInfo
     *
     * REST API Reference for getFileInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-info/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function getFileInfo($file_id, $version = null, string $contentType = self::contentTypes['getFileInfo'][0])
    {
        list($response) = $this->getFileInfoWithHttpInfo($file_id, $version, $contentType);
        return $response;
    }

    /**
     * Operation getFileInfoWithHttpInfo
     *
     * REST API Reference for getFileInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-info/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileInfoWithHttpInfo($file_id, $version = null, string $contentType = self::contentTypes['getFileInfo'][0])
    {
        $request = $this->getFileInfoRequest($file_id, $version, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFileInfoAsync
     *
     * REST API Reference for getFileInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-info/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileInfoAsync($file_id, $version = null, string $contentType = self::contentTypes['getFileInfo'][0])
    {
        return $this->getFileInfoAsyncWithHttpInfo($file_id, $version, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileInfoAsyncWithHttpInfo
     *
     * REST API Reference for getFileInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-info/
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileInfoAsyncWithHttpInfo($file_id, $version = null, string $contentType = self::contentTypes['getFileInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->getFileInfoRequest($file_id, $version, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileInfo'
     *
     * @param  int $file_id The file ID. (required)
     * @param  int|null $version The file version. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileInfoRequest($file_id, $version = null, string $contentType = self::contentTypes['getFileInfo'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling getFileInfo'
            );
        }



        $resourcePath = '/api/2.0/files/file/{fileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileLinks
     *
     * REST API Reference for getFileLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-links/
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileLinks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareArrayWrapper
     */
    public function getFileLinks($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileLinks'][0])
    {
        list($response) = $this->getFileLinksWithHttpInfo($id, $count, $start_index, $contentType);
        return $response;
    }

    /**
     * Operation getFileLinksWithHttpInfo
     *
     * REST API Reference for getFileLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-links/
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileLinks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileLinksWithHttpInfo($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileLinks'][0])
    {
        $request = $this->getFileLinksRequest($id, $count, $start_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFileLinksAsync
     *
     * REST API Reference for getFileLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-links/
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileLinksAsync($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileLinks'][0])
    {
        return $this->getFileLinksAsyncWithHttpInfo($id, $count, $start_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileLinksAsyncWithHttpInfo
     *
     * REST API Reference for getFileLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-links/
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileLinksAsyncWithHttpInfo($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileLinks'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareArrayWrapper';
        $request = $this->getFileLinksRequest($id, $count, $start_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileLinks'
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileLinksRequest($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFileLinks'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFileLinks'
            );
        }

        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FilesApi.getFileLinks, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FilesApi.getFileLinks, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/api/2.0/files/file/{id}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFilePrimaryExternalLink
     *
     * REST API Reference for getFilePrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-primary-external-link/
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareWrapper
     */
    public function getFilePrimaryExternalLink($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFilePrimaryExternalLink'][0])
    {
        list($response) = $this->getFilePrimaryExternalLinkWithHttpInfo($id, $count, $start_index, $contentType);
        return $response;
    }

    /**
     * Operation getFilePrimaryExternalLinkWithHttpInfo
     *
     * REST API Reference for getFilePrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-primary-external-link/
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilePrimaryExternalLinkWithHttpInfo($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFilePrimaryExternalLink'][0])
    {
        $request = $this->getFilePrimaryExternalLinkRequest($id, $count, $start_index, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFilePrimaryExternalLinkAsync
     *
     * REST API Reference for getFilePrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-primary-external-link/
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilePrimaryExternalLinkAsync($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFilePrimaryExternalLink'][0])
    {
        return $this->getFilePrimaryExternalLinkAsyncWithHttpInfo($id, $count, $start_index, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilePrimaryExternalLinkAsyncWithHttpInfo
     *
     * REST API Reference for getFilePrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-primary-external-link/
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilePrimaryExternalLinkAsyncWithHttpInfo($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFilePrimaryExternalLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareWrapper';
        $request = $this->getFilePrimaryExternalLinkRequest($id, $count, $start_index, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFilePrimaryExternalLink'
     *
     * @param  int $id The file unique identifier. (required)
     * @param  int|null $count The number of items to retrieve in the request. (optional)
     * @param  int|null $start_index The starting index for the query results. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilePrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFilePrimaryExternalLinkRequest($id, $count = null, $start_index = null, string $contentType = self::contentTypes['getFilePrimaryExternalLink'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFilePrimaryExternalLink'
            );
        }

        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FilesApi.getFilePrimaryExternalLink, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling FilesApi.getFilePrimaryExternalLink, must be bigger than or equal to 1.');
        }
        


        $resourcePath = '/api/2.0/files/file/{id}/link';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFileVersionInfo
     *
     * REST API Reference for getFileVersionInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-version-info/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersionInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerArrayWrapper
     */
    public function getFileVersionInfo($file_id, string $contentType = self::contentTypes['getFileVersionInfo'][0])
    {
        list($response) = $this->getFileVersionInfoWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation getFileVersionInfoWithHttpInfo
     *
     * REST API Reference for getFileVersionInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-version-info/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersionInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFileVersionInfoWithHttpInfo($file_id, string $contentType = self::contentTypes['getFileVersionInfo'][0])
    {
        $request = $this->getFileVersionInfoRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFileVersionInfoAsync
     *
     * REST API Reference for getFileVersionInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-version-info/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersionInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileVersionInfoAsync($file_id, string $contentType = self::contentTypes['getFileVersionInfo'][0])
    {
        return $this->getFileVersionInfoAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFileVersionInfoAsyncWithHttpInfo
     *
     * REST API Reference for getFileVersionInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-file-version-info/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersionInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFileVersionInfoAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['getFileVersionInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerArrayWrapper';
        $request = $this->getFileVersionInfoRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFileVersionInfo'
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFileVersionInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFileVersionInfoRequest($file_id, string $contentType = self::contentTypes['getFileVersionInfo'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling getFileVersionInfo'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFillResult
     *
     * REST API Reference for getFillResult Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-fill-result/
     *
     * @param  string|null $filling_session_id The form-filling session ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFillResult'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FillingFormResultIntegerWrapper
     */
    public function getFillResult($filling_session_id = null, string $contentType = self::contentTypes['getFillResult'][0])
    {
        list($response) = $this->getFillResultWithHttpInfo($filling_session_id, $contentType);
        return $response;
    }

    /**
     * Operation getFillResultWithHttpInfo
     *
     * REST API Reference for getFillResult Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-fill-result/
     *
     * @param  string|null $filling_session_id The form-filling session ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFillResult'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FillingFormResultIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFillResultWithHttpInfo($filling_session_id = null, string $contentType = self::contentTypes['getFillResult'][0])
    {
        $request = $this->getFillResultRequest($filling_session_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FillingFormResultIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FillingFormResultIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FillingFormResultIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFillResultAsync
     *
     * REST API Reference for getFillResult Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-fill-result/
     *
     * @param  string|null $filling_session_id The form-filling session ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFillResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFillResultAsync($filling_session_id = null, string $contentType = self::contentTypes['getFillResult'][0])
    {
        return $this->getFillResultAsyncWithHttpInfo($filling_session_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFillResultAsyncWithHttpInfo
     *
     * REST API Reference for getFillResult Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-fill-result/
     *
     * @param  string|null $filling_session_id The form-filling session ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFillResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFillResultAsyncWithHttpInfo($filling_session_id = null, string $contentType = self::contentTypes['getFillResult'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FillingFormResultIntegerWrapper';
        $request = $this->getFillResultRequest($filling_session_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFillResult'
     *
     * @param  string|null $filling_session_id The form-filling session ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFillResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFillResultRequest($filling_session_id = null, string $contentType = self::contentTypes['getFillResult'][0])
    {



        $resourcePath = '/api/2.0/files/file/fillresult';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filling_session_id,
            'fillingSessionId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPresignedFileUri
     *
     * REST API Reference for getPresignedFileUri Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-presigned-file-uri/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedFileUri'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileLinkWrapper
     */
    public function getPresignedFileUri($file_id, string $contentType = self::contentTypes['getPresignedFileUri'][0])
    {
        list($response) = $this->getPresignedFileUriWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation getPresignedFileUriWithHttpInfo
     *
     * REST API Reference for getPresignedFileUri Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-presigned-file-uri/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedFileUri'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileLinkWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPresignedFileUriWithHttpInfo($file_id, string $contentType = self::contentTypes['getPresignedFileUri'][0])
    {
        $request = $this->getPresignedFileUriRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileLinkWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileLinkWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileLinkWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPresignedFileUriAsync
     *
     * REST API Reference for getPresignedFileUri Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-presigned-file-uri/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedFileUri'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPresignedFileUriAsync($file_id, string $contentType = self::contentTypes['getPresignedFileUri'][0])
    {
        return $this->getPresignedFileUriAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPresignedFileUriAsyncWithHttpInfo
     *
     * REST API Reference for getPresignedFileUri Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-presigned-file-uri/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedFileUri'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPresignedFileUriAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['getPresignedFileUri'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileLinkWrapper';
        $request = $this->getPresignedFileUriRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPresignedFileUri'
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedFileUri'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPresignedFileUriRequest($file_id, string $contentType = self::contentTypes['getPresignedFileUri'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling getPresignedFileUri'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/presigned';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPresignedUri
     *
     * REST API Reference for getPresignedUri Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-presigned-uri/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedUri'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringWrapper
     */
    public function getPresignedUri($file_id, string $contentType = self::contentTypes['getPresignedUri'][0])
    {
        list($response) = $this->getPresignedUriWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation getPresignedUriWithHttpInfo
     *
     * REST API Reference for getPresignedUri Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-presigned-uri/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedUri'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPresignedUriWithHttpInfo($file_id, string $contentType = self::contentTypes['getPresignedUri'][0])
    {
        $request = $this->getPresignedUriRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPresignedUriAsync
     *
     * REST API Reference for getPresignedUri Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-presigned-uri/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedUri'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPresignedUriAsync($file_id, string $contentType = self::contentTypes['getPresignedUri'][0])
    {
        return $this->getPresignedUriAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPresignedUriAsyncWithHttpInfo
     *
     * REST API Reference for getPresignedUri Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-presigned-uri/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedUri'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPresignedUriAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['getPresignedUri'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StringWrapper';
        $request = $this->getPresignedUriRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPresignedUri'
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPresignedUri'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPresignedUriRequest($file_id, string $contentType = self::contentTypes['getPresignedUri'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling getPresignedUri'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/presigneduri';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getProtectedFileUsers
     *
     * REST API Reference for getProtectedFileUsers Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-protected-file-users/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProtectedFileUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\MentionWrapperArrayWrapper
     */
    public function getProtectedFileUsers($file_id, string $contentType = self::contentTypes['getProtectedFileUsers'][0])
    {
        list($response) = $this->getProtectedFileUsersWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation getProtectedFileUsersWithHttpInfo
     *
     * REST API Reference for getProtectedFileUsers Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-protected-file-users/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProtectedFileUsers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\MentionWrapperArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getProtectedFileUsersWithHttpInfo($file_id, string $contentType = self::contentTypes['getProtectedFileUsers'][0])
    {
        $request = $this->getProtectedFileUsersRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\MentionWrapperArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\MentionWrapperArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\MentionWrapperArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getProtectedFileUsersAsync
     *
     * REST API Reference for getProtectedFileUsers Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-protected-file-users/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProtectedFileUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProtectedFileUsersAsync($file_id, string $contentType = self::contentTypes['getProtectedFileUsers'][0])
    {
        return $this->getProtectedFileUsersAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getProtectedFileUsersAsyncWithHttpInfo
     *
     * REST API Reference for getProtectedFileUsers Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-protected-file-users/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProtectedFileUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getProtectedFileUsersAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['getProtectedFileUsers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\MentionWrapperArrayWrapper';
        $request = $this->getProtectedFileUsersRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getProtectedFileUsers'
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getProtectedFileUsers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getProtectedFileUsersRequest($file_id, string $contentType = self::contentTypes['getProtectedFileUsers'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling getProtectedFileUsers'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/protectusers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getReferenceData
     *
     * REST API Reference for getReferenceData Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-reference-data/
     *
     * @param  \OpenAPI\Client\Model\GetReferenceDataDtoInteger|null $get_reference_data_dto_integer get_reference_data_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReferenceData'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileReferenceWrapper
     */
    public function getReferenceData($get_reference_data_dto_integer = null, string $contentType = self::contentTypes['getReferenceData'][0])
    {
        list($response) = $this->getReferenceDataWithHttpInfo($get_reference_data_dto_integer, $contentType);
        return $response;
    }

    /**
     * Operation getReferenceDataWithHttpInfo
     *
     * REST API Reference for getReferenceData Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-reference-data/
     *
     * @param  \OpenAPI\Client\Model\GetReferenceDataDtoInteger|null $get_reference_data_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReferenceData'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileReferenceWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getReferenceDataWithHttpInfo($get_reference_data_dto_integer = null, string $contentType = self::contentTypes['getReferenceData'][0])
    {
        $request = $this->getReferenceDataRequest($get_reference_data_dto_integer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileReferenceWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileReferenceWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileReferenceWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getReferenceDataAsync
     *
     * REST API Reference for getReferenceData Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-reference-data/
     *
     * @param  \OpenAPI\Client\Model\GetReferenceDataDtoInteger|null $get_reference_data_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReferenceData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceDataAsync($get_reference_data_dto_integer = null, string $contentType = self::contentTypes['getReferenceData'][0])
    {
        return $this->getReferenceDataAsyncWithHttpInfo($get_reference_data_dto_integer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getReferenceDataAsyncWithHttpInfo
     *
     * REST API Reference for getReferenceData Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-reference-data/
     *
     * @param  \OpenAPI\Client\Model\GetReferenceDataDtoInteger|null $get_reference_data_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReferenceData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getReferenceDataAsyncWithHttpInfo($get_reference_data_dto_integer = null, string $contentType = self::contentTypes['getReferenceData'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileReferenceWrapper';
        $request = $this->getReferenceDataRequest($get_reference_data_dto_integer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getReferenceData'
     *
     * @param  \OpenAPI\Client\Model\GetReferenceDataDtoInteger|null $get_reference_data_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getReferenceData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getReferenceDataRequest($get_reference_data_dto_integer = null, string $contentType = self::contentTypes['getReferenceData'][0])
    {



        $resourcePath = '/api/2.0/files/file/referencedata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($get_reference_data_dto_integer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($get_reference_data_dto_integer));
            } else {
                $httpBody = $get_reference_data_dto_integer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation isFormPDF
     *
     * REST API Reference for isFormPDF Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/is-form-pdf/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isFormPDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function isFormPDF($file_id, string $contentType = self::contentTypes['isFormPDF'][0])
    {
        list($response) = $this->isFormPDFWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation isFormPDFWithHttpInfo
     *
     * REST API Reference for isFormPDF Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/is-form-pdf/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isFormPDF'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function isFormPDFWithHttpInfo($file_id, string $contentType = self::contentTypes['isFormPDF'][0])
    {
        $request = $this->isFormPDFRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation isFormPDFAsync
     *
     * REST API Reference for isFormPDF Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/is-form-pdf/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isFormPDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function isFormPDFAsync($file_id, string $contentType = self::contentTypes['isFormPDF'][0])
    {
        return $this->isFormPDFAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation isFormPDFAsyncWithHttpInfo
     *
     * REST API Reference for isFormPDF Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/is-form-pdf/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isFormPDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function isFormPDFAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['isFormPDF'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->isFormPDFRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'isFormPDF'
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isFormPDF'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function isFormPDFRequest($file_id, string $contentType = self::contentTypes['isFormPDF'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling isFormPDF'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/isformpdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockFile
     *
     * REST API Reference for lockFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/lock-file/
     *
     * @param  int $file_id The file ID for locking. (required)
     * @param  \OpenAPI\Client\Model\LockFileParameters $lock_file_parameters The parameters for locking a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function lockFile($file_id, $lock_file_parameters, string $contentType = self::contentTypes['lockFile'][0])
    {
        list($response) = $this->lockFileWithHttpInfo($file_id, $lock_file_parameters, $contentType);
        return $response;
    }

    /**
     * Operation lockFileWithHttpInfo
     *
     * REST API Reference for lockFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/lock-file/
     *
     * @param  int $file_id The file ID for locking. (required)
     * @param  \OpenAPI\Client\Model\LockFileParameters $lock_file_parameters The parameters for locking a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function lockFileWithHttpInfo($file_id, $lock_file_parameters, string $contentType = self::contentTypes['lockFile'][0])
    {
        $request = $this->lockFileRequest($file_id, $lock_file_parameters, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation lockFileAsync
     *
     * REST API Reference for lockFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/lock-file/
     *
     * @param  int $file_id The file ID for locking. (required)
     * @param  \OpenAPI\Client\Model\LockFileParameters $lock_file_parameters The parameters for locking a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockFileAsync($file_id, $lock_file_parameters, string $contentType = self::contentTypes['lockFile'][0])
    {
        return $this->lockFileAsyncWithHttpInfo($file_id, $lock_file_parameters, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lockFileAsyncWithHttpInfo
     *
     * REST API Reference for lockFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/lock-file/
     *
     * @param  int $file_id The file ID for locking. (required)
     * @param  \OpenAPI\Client\Model\LockFileParameters $lock_file_parameters The parameters for locking a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockFileAsyncWithHttpInfo($file_id, $lock_file_parameters, string $contentType = self::contentTypes['lockFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->lockFileRequest($file_id, $lock_file_parameters, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lockFile'
     *
     * @param  int $file_id The file ID for locking. (required)
     * @param  \OpenAPI\Client\Model\LockFileParameters $lock_file_parameters The parameters for locking a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lockFileRequest($file_id, $lock_file_parameters, string $contentType = self::contentTypes['lockFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling lockFile'
            );
        }

        // verify the required parameter 'lock_file_parameters' is set
        if ($lock_file_parameters === null || (is_array($lock_file_parameters) && count($lock_file_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lock_file_parameters when calling lockFile'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($lock_file_parameters)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($lock_file_parameters));
            } else {
                $httpBody = $lock_file_parameters;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation manageFormFilling
     *
     * REST API Reference for manageFormFilling Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/manage-form-filling/
     *
     * @param  string $file_id file_id (required)
     * @param  \OpenAPI\Client\Model\ManageFormFillingDtoInteger|null $manage_form_filling_dto_integer manage_form_filling_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['manageFormFilling'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function manageFormFilling($file_id, $manage_form_filling_dto_integer = null, string $contentType = self::contentTypes['manageFormFilling'][0])
    {
        $this->manageFormFillingWithHttpInfo($file_id, $manage_form_filling_dto_integer, $contentType);
    }

    /**
     * Operation manageFormFillingWithHttpInfo
     *
     * REST API Reference for manageFormFilling Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/manage-form-filling/
     *
     * @param  string $file_id (required)
     * @param  \OpenAPI\Client\Model\ManageFormFillingDtoInteger|null $manage_form_filling_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['manageFormFilling'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function manageFormFillingWithHttpInfo($file_id, $manage_form_filling_dto_integer = null, string $contentType = self::contentTypes['manageFormFilling'][0])
    {
        $request = $this->manageFormFillingRequest($file_id, $manage_form_filling_dto_integer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation manageFormFillingAsync
     *
     * REST API Reference for manageFormFilling Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/manage-form-filling/
     *
     * @param  string $file_id (required)
     * @param  \OpenAPI\Client\Model\ManageFormFillingDtoInteger|null $manage_form_filling_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['manageFormFilling'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function manageFormFillingAsync($file_id, $manage_form_filling_dto_integer = null, string $contentType = self::contentTypes['manageFormFilling'][0])
    {
        return $this->manageFormFillingAsyncWithHttpInfo($file_id, $manage_form_filling_dto_integer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation manageFormFillingAsyncWithHttpInfo
     *
     * REST API Reference for manageFormFilling Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/manage-form-filling/
     *
     * @param  string $file_id (required)
     * @param  \OpenAPI\Client\Model\ManageFormFillingDtoInteger|null $manage_form_filling_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['manageFormFilling'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function manageFormFillingAsyncWithHttpInfo($file_id, $manage_form_filling_dto_integer = null, string $contentType = self::contentTypes['manageFormFilling'][0])
    {
        $returnType = '';
        $request = $this->manageFormFillingRequest($file_id, $manage_form_filling_dto_integer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'manageFormFilling'
     *
     * @param  string $file_id (required)
     * @param  \OpenAPI\Client\Model\ManageFormFillingDtoInteger|null $manage_form_filling_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['manageFormFilling'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function manageFormFillingRequest($file_id, $manage_form_filling_dto_integer = null, string $contentType = self::contentTypes['manageFormFilling'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling manageFormFilling'
            );
        }



        $resourcePath = '/api/2.0/files/file/{fileId}/manageformfilling';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($manage_form_filling_dto_integer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($manage_form_filling_dto_integer));
            } else {
                $httpBody = $manage_form_filling_dto_integer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation openEditFile
     *
     * REST API Reference for openEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/open-edit-file/
     *
     * @param  int $file_id The file ID to open. (required)
     * @param  int|null $version The file version to open. (optional)
     * @param  bool|null $view Specifies if the document will be opened for viewing only or not. (optional)
     * @param  \OpenAPI\Client\Model\EditorType|null $editor_type The editor type to open the file. (optional)
     * @param  bool|null $edit Specifies if the document is opened in the editing mode or not. (optional)
     * @param  bool|null $fill Specifies if the document is opened in the form-filling mode or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['openEditFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConfigurationIntegerWrapper
     */
    public function openEditFile($file_id, $version = null, $view = null, $editor_type = null, $edit = null, $fill = null, string $contentType = self::contentTypes['openEditFile'][0])
    {
        list($response) = $this->openEditFileWithHttpInfo($file_id, $version, $view, $editor_type, $edit, $fill, $contentType);
        return $response;
    }

    /**
     * Operation openEditFileWithHttpInfo
     *
     * REST API Reference for openEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/open-edit-file/
     *
     * @param  int $file_id The file ID to open. (required)
     * @param  int|null $version The file version to open. (optional)
     * @param  bool|null $view Specifies if the document will be opened for viewing only or not. (optional)
     * @param  \OpenAPI\Client\Model\EditorType|null $editor_type The editor type to open the file. (optional)
     * @param  bool|null $edit Specifies if the document is opened in the editing mode or not. (optional)
     * @param  bool|null $fill Specifies if the document is opened in the form-filling mode or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['openEditFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConfigurationIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function openEditFileWithHttpInfo($file_id, $version = null, $view = null, $editor_type = null, $edit = null, $fill = null, string $contentType = self::contentTypes['openEditFile'][0])
    {
        $request = $this->openEditFileRequest($file_id, $version, $view, $editor_type, $edit, $fill, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ConfigurationIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ConfigurationIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConfigurationIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation openEditFileAsync
     *
     * REST API Reference for openEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/open-edit-file/
     *
     * @param  int $file_id The file ID to open. (required)
     * @param  int|null $version The file version to open. (optional)
     * @param  bool|null $view Specifies if the document will be opened for viewing only or not. (optional)
     * @param  \OpenAPI\Client\Model\EditorType|null $editor_type The editor type to open the file. (optional)
     * @param  bool|null $edit Specifies if the document is opened in the editing mode or not. (optional)
     * @param  bool|null $fill Specifies if the document is opened in the form-filling mode or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['openEditFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function openEditFileAsync($file_id, $version = null, $view = null, $editor_type = null, $edit = null, $fill = null, string $contentType = self::contentTypes['openEditFile'][0])
    {
        return $this->openEditFileAsyncWithHttpInfo($file_id, $version, $view, $editor_type, $edit, $fill, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation openEditFileAsyncWithHttpInfo
     *
     * REST API Reference for openEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/open-edit-file/
     *
     * @param  int $file_id The file ID to open. (required)
     * @param  int|null $version The file version to open. (optional)
     * @param  bool|null $view Specifies if the document will be opened for viewing only or not. (optional)
     * @param  \OpenAPI\Client\Model\EditorType|null $editor_type The editor type to open the file. (optional)
     * @param  bool|null $edit Specifies if the document is opened in the editing mode or not. (optional)
     * @param  bool|null $fill Specifies if the document is opened in the form-filling mode or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['openEditFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function openEditFileAsyncWithHttpInfo($file_id, $version = null, $view = null, $editor_type = null, $edit = null, $fill = null, string $contentType = self::contentTypes['openEditFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConfigurationIntegerWrapper';
        $request = $this->openEditFileRequest($file_id, $version, $view, $editor_type, $edit, $fill, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'openEditFile'
     *
     * @param  int $file_id The file ID to open. (required)
     * @param  int|null $version The file version to open. (optional)
     * @param  bool|null $view Specifies if the document will be opened for viewing only or not. (optional)
     * @param  \OpenAPI\Client\Model\EditorType|null $editor_type The editor type to open the file. (optional)
     * @param  bool|null $edit Specifies if the document is opened in the editing mode or not. (optional)
     * @param  bool|null $fill Specifies if the document is opened in the form-filling mode or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['openEditFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function openEditFileRequest($file_id, $version = null, $view = null, $editor_type = null, $edit = null, $fill = null, string $contentType = self::contentTypes['openEditFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling openEditFile'
            );
        }







        $resourcePath = '/api/2.0/files/file/{fileId}/openedit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $view,
            'view', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $editor_type,
            'editorType', // param base name
            'EditorType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $edit,
            'edit', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $fill,
            'fill', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation restoreFileVersion
     *
     * REST API Reference for restoreFileVersion Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/restore-file-version/
     *
     * @param  int $file_id The file ID of the restore version. (required)
     * @param  int|null $version The file version of the restore. (optional)
     * @param  string|null $url The file version URL of the restore. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFileVersion'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EditHistoryArrayWrapper
     */
    public function restoreFileVersion($file_id, $version = null, $url = null, string $contentType = self::contentTypes['restoreFileVersion'][0])
    {
        list($response) = $this->restoreFileVersionWithHttpInfo($file_id, $version, $url, $contentType);
        return $response;
    }

    /**
     * Operation restoreFileVersionWithHttpInfo
     *
     * REST API Reference for restoreFileVersion Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/restore-file-version/
     *
     * @param  int $file_id The file ID of the restore version. (required)
     * @param  int|null $version The file version of the restore. (optional)
     * @param  string|null $url The file version URL of the restore. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFileVersion'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EditHistoryArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function restoreFileVersionWithHttpInfo($file_id, $version = null, $url = null, string $contentType = self::contentTypes['restoreFileVersion'][0])
    {
        $request = $this->restoreFileVersionRequest($file_id, $version, $url, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\EditHistoryArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\EditHistoryArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EditHistoryArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation restoreFileVersionAsync
     *
     * REST API Reference for restoreFileVersion Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/restore-file-version/
     *
     * @param  int $file_id The file ID of the restore version. (required)
     * @param  int|null $version The file version of the restore. (optional)
     * @param  string|null $url The file version URL of the restore. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFileVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreFileVersionAsync($file_id, $version = null, $url = null, string $contentType = self::contentTypes['restoreFileVersion'][0])
    {
        return $this->restoreFileVersionAsyncWithHttpInfo($file_id, $version, $url, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation restoreFileVersionAsyncWithHttpInfo
     *
     * REST API Reference for restoreFileVersion Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/restore-file-version/
     *
     * @param  int $file_id The file ID of the restore version. (required)
     * @param  int|null $version The file version of the restore. (optional)
     * @param  string|null $url The file version URL of the restore. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFileVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function restoreFileVersionAsyncWithHttpInfo($file_id, $version = null, $url = null, string $contentType = self::contentTypes['restoreFileVersion'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EditHistoryArrayWrapper';
        $request = $this->restoreFileVersionRequest($file_id, $version, $url, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'restoreFileVersion'
     *
     * @param  int $file_id The file ID of the restore version. (required)
     * @param  int|null $version The file version of the restore. (optional)
     * @param  string|null $url The file version URL of the restore. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['restoreFileVersion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function restoreFileVersionRequest($file_id, $version = null, $url = null, string $contentType = self::contentTypes['restoreFileVersion'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling restoreFileVersion'
            );
        }




        $resourcePath = '/api/2.0/files/file/{fileId}/restoreversion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url,
            'url', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveEditingFileFromForm
     *
     * REST API Reference for saveEditingFileFromForm Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-editing-file-from-form/
     *
     * @param  int $file_id The editing file ID from the request. (required)
     * @param  string|null $file_extension The editing file extension from the request. (optional)
     * @param  string|null $download_uri The URI to download the editing file. (optional)
     * @param  \SplFileObject|null $file The request file stream. (optional)
     * @param  bool|null $forcesave Specifies whether to force save the file or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveEditingFileFromForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function saveEditingFileFromForm($file_id, $file_extension = null, $download_uri = null, $file = null, $forcesave = null, string $contentType = self::contentTypes['saveEditingFileFromForm'][0])
    {
        list($response) = $this->saveEditingFileFromFormWithHttpInfo($file_id, $file_extension, $download_uri, $file, $forcesave, $contentType);
        return $response;
    }

    /**
     * Operation saveEditingFileFromFormWithHttpInfo
     *
     * REST API Reference for saveEditingFileFromForm Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-editing-file-from-form/
     *
     * @param  int $file_id The editing file ID from the request. (required)
     * @param  string|null $file_extension The editing file extension from the request. (optional)
     * @param  string|null $download_uri The URI to download the editing file. (optional)
     * @param  \SplFileObject|null $file The request file stream. (optional)
     * @param  bool|null $forcesave Specifies whether to force save the file or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveEditingFileFromForm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveEditingFileFromFormWithHttpInfo($file_id, $file_extension = null, $download_uri = null, $file = null, $forcesave = null, string $contentType = self::contentTypes['saveEditingFileFromForm'][0])
    {
        $request = $this->saveEditingFileFromFormRequest($file_id, $file_extension, $download_uri, $file, $forcesave, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation saveEditingFileFromFormAsync
     *
     * REST API Reference for saveEditingFileFromForm Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-editing-file-from-form/
     *
     * @param  int $file_id The editing file ID from the request. (required)
     * @param  string|null $file_extension The editing file extension from the request. (optional)
     * @param  string|null $download_uri The URI to download the editing file. (optional)
     * @param  \SplFileObject|null $file The request file stream. (optional)
     * @param  bool|null $forcesave Specifies whether to force save the file or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveEditingFileFromForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveEditingFileFromFormAsync($file_id, $file_extension = null, $download_uri = null, $file = null, $forcesave = null, string $contentType = self::contentTypes['saveEditingFileFromForm'][0])
    {
        return $this->saveEditingFileFromFormAsyncWithHttpInfo($file_id, $file_extension, $download_uri, $file, $forcesave, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveEditingFileFromFormAsyncWithHttpInfo
     *
     * REST API Reference for saveEditingFileFromForm Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-editing-file-from-form/
     *
     * @param  int $file_id The editing file ID from the request. (required)
     * @param  string|null $file_extension The editing file extension from the request. (optional)
     * @param  string|null $download_uri The URI to download the editing file. (optional)
     * @param  \SplFileObject|null $file The request file stream. (optional)
     * @param  bool|null $forcesave Specifies whether to force save the file or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveEditingFileFromForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveEditingFileFromFormAsyncWithHttpInfo($file_id, $file_extension = null, $download_uri = null, $file = null, $forcesave = null, string $contentType = self::contentTypes['saveEditingFileFromForm'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->saveEditingFileFromFormRequest($file_id, $file_extension, $download_uri, $file, $forcesave, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveEditingFileFromForm'
     *
     * @param  int $file_id The editing file ID from the request. (required)
     * @param  string|null $file_extension The editing file extension from the request. (optional)
     * @param  string|null $download_uri The URI to download the editing file. (optional)
     * @param  \SplFileObject|null $file The request file stream. (optional)
     * @param  bool|null $forcesave Specifies whether to force save the file or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveEditingFileFromForm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function saveEditingFileFromFormRequest($file_id, $file_extension = null, $download_uri = null, $file = null, $forcesave = null, string $contentType = self::contentTypes['saveEditingFileFromForm'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling saveEditingFileFromForm'
            );
        }






        $resourcePath = '/api/2.0/files/file/{fileId}/saveediting';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }

        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file_extension' => $file_extension,
            'download_uri' => $download_uri,
            'file' => $file,
            'forcesave' => $forcesave,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveFileAsPdf
     *
     * REST API Reference for saveFileAsPdf Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-file-as-pdf/
     *
     * @param  int $id The file ID to save as PDF. (required)
     * @param  \OpenAPI\Client\Model\SaveAsPdfInteger $save_as_pdf_integer The parameters for saving the file as PDF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFileAsPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function saveFileAsPdf($id, $save_as_pdf_integer, string $contentType = self::contentTypes['saveFileAsPdf'][0])
    {
        list($response) = $this->saveFileAsPdfWithHttpInfo($id, $save_as_pdf_integer, $contentType);
        return $response;
    }

    /**
     * Operation saveFileAsPdfWithHttpInfo
     *
     * REST API Reference for saveFileAsPdf Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-file-as-pdf/
     *
     * @param  int $id The file ID to save as PDF. (required)
     * @param  \OpenAPI\Client\Model\SaveAsPdfInteger $save_as_pdf_integer The parameters for saving the file as PDF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFileAsPdf'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveFileAsPdfWithHttpInfo($id, $save_as_pdf_integer, string $contentType = self::contentTypes['saveFileAsPdf'][0])
    {
        $request = $this->saveFileAsPdfRequest($id, $save_as_pdf_integer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation saveFileAsPdfAsync
     *
     * REST API Reference for saveFileAsPdf Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-file-as-pdf/
     *
     * @param  int $id The file ID to save as PDF. (required)
     * @param  \OpenAPI\Client\Model\SaveAsPdfInteger $save_as_pdf_integer The parameters for saving the file as PDF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFileAsPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveFileAsPdfAsync($id, $save_as_pdf_integer, string $contentType = self::contentTypes['saveFileAsPdf'][0])
    {
        return $this->saveFileAsPdfAsyncWithHttpInfo($id, $save_as_pdf_integer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveFileAsPdfAsyncWithHttpInfo
     *
     * REST API Reference for saveFileAsPdf Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-file-as-pdf/
     *
     * @param  int $id The file ID to save as PDF. (required)
     * @param  \OpenAPI\Client\Model\SaveAsPdfInteger $save_as_pdf_integer The parameters for saving the file as PDF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFileAsPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveFileAsPdfAsyncWithHttpInfo($id, $save_as_pdf_integer, string $contentType = self::contentTypes['saveFileAsPdf'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->saveFileAsPdfRequest($id, $save_as_pdf_integer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveFileAsPdf'
     *
     * @param  int $id The file ID to save as PDF. (required)
     * @param  \OpenAPI\Client\Model\SaveAsPdfInteger $save_as_pdf_integer The parameters for saving the file as PDF. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFileAsPdf'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function saveFileAsPdfRequest($id, $save_as_pdf_integer, string $contentType = self::contentTypes['saveFileAsPdf'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling saveFileAsPdf'
            );
        }

        // verify the required parameter 'save_as_pdf_integer' is set
        if ($save_as_pdf_integer === null || (is_array($save_as_pdf_integer) && count($save_as_pdf_integer) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $save_as_pdf_integer when calling saveFileAsPdf'
            );
        }


        $resourcePath = '/api/2.0/files/file/{id}/saveaspdf';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($save_as_pdf_integer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($save_as_pdf_integer));
            } else {
                $httpBody = $save_as_pdf_integer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveFormRoleMapping
     *
     * REST API Reference for saveFormRoleMapping Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-form-role-mapping/
     *
     * @param  string $file_id file_id (required)
     * @param  \OpenAPI\Client\Model\SaveFormRoleMappingDtoInteger|null $save_form_role_mapping_dto_integer save_form_role_mapping_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFormRoleMapping'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function saveFormRoleMapping($file_id, $save_form_role_mapping_dto_integer = null, string $contentType = self::contentTypes['saveFormRoleMapping'][0])
    {
        $this->saveFormRoleMappingWithHttpInfo($file_id, $save_form_role_mapping_dto_integer, $contentType);
    }

    /**
     * Operation saveFormRoleMappingWithHttpInfo
     *
     * REST API Reference for saveFormRoleMapping Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-form-role-mapping/
     *
     * @param  string $file_id (required)
     * @param  \OpenAPI\Client\Model\SaveFormRoleMappingDtoInteger|null $save_form_role_mapping_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFormRoleMapping'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveFormRoleMappingWithHttpInfo($file_id, $save_form_role_mapping_dto_integer = null, string $contentType = self::contentTypes['saveFormRoleMapping'][0])
    {
        $request = $this->saveFormRoleMappingRequest($file_id, $save_form_role_mapping_dto_integer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation saveFormRoleMappingAsync
     *
     * REST API Reference for saveFormRoleMapping Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-form-role-mapping/
     *
     * @param  string $file_id (required)
     * @param  \OpenAPI\Client\Model\SaveFormRoleMappingDtoInteger|null $save_form_role_mapping_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFormRoleMapping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveFormRoleMappingAsync($file_id, $save_form_role_mapping_dto_integer = null, string $contentType = self::contentTypes['saveFormRoleMapping'][0])
    {
        return $this->saveFormRoleMappingAsyncWithHttpInfo($file_id, $save_form_role_mapping_dto_integer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveFormRoleMappingAsyncWithHttpInfo
     *
     * REST API Reference for saveFormRoleMapping Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-form-role-mapping/
     *
     * @param  string $file_id (required)
     * @param  \OpenAPI\Client\Model\SaveFormRoleMappingDtoInteger|null $save_form_role_mapping_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFormRoleMapping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveFormRoleMappingAsyncWithHttpInfo($file_id, $save_form_role_mapping_dto_integer = null, string $contentType = self::contentTypes['saveFormRoleMapping'][0])
    {
        $returnType = '';
        $request = $this->saveFormRoleMappingRequest($file_id, $save_form_role_mapping_dto_integer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveFormRoleMapping'
     *
     * @param  string $file_id (required)
     * @param  \OpenAPI\Client\Model\SaveFormRoleMappingDtoInteger|null $save_form_role_mapping_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveFormRoleMapping'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function saveFormRoleMappingRequest($file_id, $save_form_role_mapping_dto_integer = null, string $contentType = self::contentTypes['saveFormRoleMapping'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling saveFormRoleMapping'
            );
        }



        $resourcePath = '/api/2.0/files/file/{fileId}/formrolemapping';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($save_form_role_mapping_dto_integer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($save_form_role_mapping_dto_integer));
            } else {
                $httpBody = $save_form_role_mapping_dto_integer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setCustomFilterTag
     *
     * REST API Reference for setCustomFilterTag Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-custom-filter-tag/
     *
     * @param  int $file_id The file ID. (required)
     * @param  \OpenAPI\Client\Model\CustomFilterParameters $custom_filter_parameters The parameters for setting the Custom Filter editing mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCustomFilterTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function setCustomFilterTag($file_id, $custom_filter_parameters, string $contentType = self::contentTypes['setCustomFilterTag'][0])
    {
        list($response) = $this->setCustomFilterTagWithHttpInfo($file_id, $custom_filter_parameters, $contentType);
        return $response;
    }

    /**
     * Operation setCustomFilterTagWithHttpInfo
     *
     * REST API Reference for setCustomFilterTag Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-custom-filter-tag/
     *
     * @param  int $file_id The file ID. (required)
     * @param  \OpenAPI\Client\Model\CustomFilterParameters $custom_filter_parameters The parameters for setting the Custom Filter editing mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCustomFilterTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function setCustomFilterTagWithHttpInfo($file_id, $custom_filter_parameters, string $contentType = self::contentTypes['setCustomFilterTag'][0])
    {
        $request = $this->setCustomFilterTagRequest($file_id, $custom_filter_parameters, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setCustomFilterTagAsync
     *
     * REST API Reference for setCustomFilterTag Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-custom-filter-tag/
     *
     * @param  int $file_id The file ID. (required)
     * @param  \OpenAPI\Client\Model\CustomFilterParameters $custom_filter_parameters The parameters for setting the Custom Filter editing mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCustomFilterTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCustomFilterTagAsync($file_id, $custom_filter_parameters, string $contentType = self::contentTypes['setCustomFilterTag'][0])
    {
        return $this->setCustomFilterTagAsyncWithHttpInfo($file_id, $custom_filter_parameters, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setCustomFilterTagAsyncWithHttpInfo
     *
     * REST API Reference for setCustomFilterTag Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-custom-filter-tag/
     *
     * @param  int $file_id The file ID. (required)
     * @param  \OpenAPI\Client\Model\CustomFilterParameters $custom_filter_parameters The parameters for setting the Custom Filter editing mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCustomFilterTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setCustomFilterTagAsyncWithHttpInfo($file_id, $custom_filter_parameters, string $contentType = self::contentTypes['setCustomFilterTag'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->setCustomFilterTagRequest($file_id, $custom_filter_parameters, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setCustomFilterTag'
     *
     * @param  int $file_id The file ID. (required)
     * @param  \OpenAPI\Client\Model\CustomFilterParameters $custom_filter_parameters The parameters for setting the Custom Filter editing mode. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setCustomFilterTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setCustomFilterTagRequest($file_id, $custom_filter_parameters, string $contentType = self::contentTypes['setCustomFilterTag'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling setCustomFilterTag'
            );
        }

        // verify the required parameter 'custom_filter_parameters' is set
        if ($custom_filter_parameters === null || (is_array($custom_filter_parameters) && count($custom_filter_parameters) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_filter_parameters when calling setCustomFilterTag'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/customfilter';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_filter_parameters)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_filter_parameters));
            } else {
                $httpBody = $custom_filter_parameters;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setFileExternalLink
     *
     * REST API Reference for setFileExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-file-external-link/
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareWrapper
     */
    public function setFileExternalLink($id, $file_link_request, string $contentType = self::contentTypes['setFileExternalLink'][0])
    {
        list($response) = $this->setFileExternalLinkWithHttpInfo($id, $file_link_request, $contentType);
        return $response;
    }

    /**
     * Operation setFileExternalLinkWithHttpInfo
     *
     * REST API Reference for setFileExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-file-external-link/
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function setFileExternalLinkWithHttpInfo($id, $file_link_request, string $contentType = self::contentTypes['setFileExternalLink'][0])
    {
        $request = $this->setFileExternalLinkRequest($id, $file_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setFileExternalLinkAsync
     *
     * REST API Reference for setFileExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-file-external-link/
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFileExternalLinkAsync($id, $file_link_request, string $contentType = self::contentTypes['setFileExternalLink'][0])
    {
        return $this->setFileExternalLinkAsyncWithHttpInfo($id, $file_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setFileExternalLinkAsyncWithHttpInfo
     *
     * REST API Reference for setFileExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-file-external-link/
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFileExternalLinkAsyncWithHttpInfo($id, $file_link_request, string $contentType = self::contentTypes['setFileExternalLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareWrapper';
        $request = $this->setFileExternalLinkRequest($id, $file_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setFileExternalLink'
     *
     * @param  int $id The file ID. (required)
     * @param  \OpenAPI\Client\Model\FileLinkRequest $file_link_request The file external link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setFileExternalLinkRequest($id, $file_link_request, string $contentType = self::contentTypes['setFileExternalLink'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setFileExternalLink'
            );
        }

        // verify the required parameter 'file_link_request' is set
        if ($file_link_request === null || (is_array($file_link_request) && count($file_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_link_request when calling setFileExternalLink'
            );
        }


        $resourcePath = '/api/2.0/files/file/{id}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($file_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($file_link_request));
            } else {
                $httpBody = $file_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setFileOrder
     *
     * REST API Reference for setFileOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-file-order/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The file order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileOrder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function setFileOrder($file_id, $order_request_dto = null, string $contentType = self::contentTypes['setFileOrder'][0])
    {
        list($response) = $this->setFileOrderWithHttpInfo($file_id, $order_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation setFileOrderWithHttpInfo
     *
     * REST API Reference for setFileOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-file-order/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The file order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileOrder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function setFileOrderWithHttpInfo($file_id, $order_request_dto = null, string $contentType = self::contentTypes['setFileOrder'][0])
    {
        $request = $this->setFileOrderRequest($file_id, $order_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setFileOrderAsync
     *
     * REST API Reference for setFileOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-file-order/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The file order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFileOrderAsync($file_id, $order_request_dto = null, string $contentType = self::contentTypes['setFileOrder'][0])
    {
        return $this->setFileOrderAsyncWithHttpInfo($file_id, $order_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setFileOrderAsyncWithHttpInfo
     *
     * REST API Reference for setFileOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-file-order/
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The file order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFileOrderAsyncWithHttpInfo($file_id, $order_request_dto = null, string $contentType = self::contentTypes['setFileOrder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->setFileOrderRequest($file_id, $order_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setFileOrder'
     *
     * @param  int $file_id The file unique identifier. (required)
     * @param  \OpenAPI\Client\Model\OrderRequestDto|null $order_request_dto The file order information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFileOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setFileOrderRequest($file_id, $order_request_dto = null, string $contentType = self::contentTypes['setFileOrder'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling setFileOrder'
            );
        }



        $resourcePath = '/api/2.0/files/{fileId}/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($order_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($order_request_dto));
            } else {
                $httpBody = $order_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setFilesOrder
     *
     * REST API Reference for setFilesOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-files-order/
     *
     * @param  \OpenAPI\Client\Model\OrdersRequestDtoInteger|null $orders_request_dto_integer orders_request_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFilesOrder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileEntryIntegerArrayWrapper
     */
    public function setFilesOrder($orders_request_dto_integer = null, string $contentType = self::contentTypes['setFilesOrder'][0])
    {
        list($response) = $this->setFilesOrderWithHttpInfo($orders_request_dto_integer, $contentType);
        return $response;
    }

    /**
     * Operation setFilesOrderWithHttpInfo
     *
     * REST API Reference for setFilesOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-files-order/
     *
     * @param  \OpenAPI\Client\Model\OrdersRequestDtoInteger|null $orders_request_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFilesOrder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileEntryIntegerArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function setFilesOrderWithHttpInfo($orders_request_dto_integer = null, string $contentType = self::contentTypes['setFilesOrder'][0])
    {
        $request = $this->setFilesOrderRequest($orders_request_dto_integer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileEntryIntegerArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileEntryIntegerArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileEntryIntegerArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setFilesOrderAsync
     *
     * REST API Reference for setFilesOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-files-order/
     *
     * @param  \OpenAPI\Client\Model\OrdersRequestDtoInteger|null $orders_request_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFilesOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFilesOrderAsync($orders_request_dto_integer = null, string $contentType = self::contentTypes['setFilesOrder'][0])
    {
        return $this->setFilesOrderAsyncWithHttpInfo($orders_request_dto_integer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setFilesOrderAsyncWithHttpInfo
     *
     * REST API Reference for setFilesOrder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-files-order/
     *
     * @param  \OpenAPI\Client\Model\OrdersRequestDtoInteger|null $orders_request_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFilesOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setFilesOrderAsyncWithHttpInfo($orders_request_dto_integer = null, string $contentType = self::contentTypes['setFilesOrder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileEntryIntegerArrayWrapper';
        $request = $this->setFilesOrderRequest($orders_request_dto_integer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setFilesOrder'
     *
     * @param  \OpenAPI\Client\Model\OrdersRequestDtoInteger|null $orders_request_dto_integer (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setFilesOrder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setFilesOrderRequest($orders_request_dto_integer = null, string $contentType = self::contentTypes['setFilesOrder'][0])
    {



        $resourcePath = '/api/2.0/files/order';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($orders_request_dto_integer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($orders_request_dto_integer));
            } else {
                $httpBody = $orders_request_dto_integer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startEditFile
     *
     * REST API Reference for startEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-edit-file/
     *
     * @param  int $file_id The file ID to start editing. (required)
     * @param  \OpenAPI\Client\Model\StartEdit $start_edit The file parameters to start editing. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startEditFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringWrapper
     */
    public function startEditFile($file_id, $start_edit, string $contentType = self::contentTypes['startEditFile'][0])
    {
        list($response) = $this->startEditFileWithHttpInfo($file_id, $start_edit, $contentType);
        return $response;
    }

    /**
     * Operation startEditFileWithHttpInfo
     *
     * REST API Reference for startEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-edit-file/
     *
     * @param  int $file_id The file ID to start editing. (required)
     * @param  \OpenAPI\Client\Model\StartEdit $start_edit The file parameters to start editing. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startEditFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function startEditFileWithHttpInfo($file_id, $start_edit, string $contentType = self::contentTypes['startEditFile'][0])
    {
        $request = $this->startEditFileRequest($file_id, $start_edit, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation startEditFileAsync
     *
     * REST API Reference for startEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-edit-file/
     *
     * @param  int $file_id The file ID to start editing. (required)
     * @param  \OpenAPI\Client\Model\StartEdit $start_edit The file parameters to start editing. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startEditFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startEditFileAsync($file_id, $start_edit, string $contentType = self::contentTypes['startEditFile'][0])
    {
        return $this->startEditFileAsyncWithHttpInfo($file_id, $start_edit, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startEditFileAsyncWithHttpInfo
     *
     * REST API Reference for startEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-edit-file/
     *
     * @param  int $file_id The file ID to start editing. (required)
     * @param  \OpenAPI\Client\Model\StartEdit $start_edit The file parameters to start editing. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startEditFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startEditFileAsyncWithHttpInfo($file_id, $start_edit, string $contentType = self::contentTypes['startEditFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StringWrapper';
        $request = $this->startEditFileRequest($file_id, $start_edit, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startEditFile'
     *
     * @param  int $file_id The file ID to start editing. (required)
     * @param  \OpenAPI\Client\Model\StartEdit $start_edit The file parameters to start editing. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startEditFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function startEditFileRequest($file_id, $start_edit, string $contentType = self::contentTypes['startEditFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling startEditFile'
            );
        }

        // verify the required parameter 'start_edit' is set
        if ($start_edit === null || (is_array($start_edit) && count($start_edit) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_edit when calling startEditFile'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/startedit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($start_edit)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($start_edit));
            } else {
                $httpBody = $start_edit;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startFillingFile
     *
     * REST API Reference for startFillingFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-filling-file/
     *
     * @param  int $file_id The file ID to start filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFillingFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function startFillingFile($file_id, string $contentType = self::contentTypes['startFillingFile'][0])
    {
        list($response) = $this->startFillingFileWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation startFillingFileWithHttpInfo
     *
     * REST API Reference for startFillingFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-filling-file/
     *
     * @param  int $file_id The file ID to start filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFillingFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function startFillingFileWithHttpInfo($file_id, string $contentType = self::contentTypes['startFillingFile'][0])
    {
        $request = $this->startFillingFileRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation startFillingFileAsync
     *
     * REST API Reference for startFillingFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-filling-file/
     *
     * @param  int $file_id The file ID to start filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFillingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startFillingFileAsync($file_id, string $contentType = self::contentTypes['startFillingFile'][0])
    {
        return $this->startFillingFileAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startFillingFileAsyncWithHttpInfo
     *
     * REST API Reference for startFillingFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-filling-file/
     *
     * @param  int $file_id The file ID to start filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFillingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startFillingFileAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['startFillingFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->startFillingFileRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startFillingFile'
     *
     * @param  int $file_id The file ID to start filling. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFillingFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function startFillingFileRequest($file_id, string $contentType = self::contentTypes['startFillingFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling startFillingFile'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/startfilling';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation toggleFileFavorite
     *
     * REST API Reference for toggleFileFavorite Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/toggle-file-favorite/
     *
     * @param  int $file_id The file ID. (required)
     * @param  bool|null $favorite Specifies if the file is marked as favorite or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toggleFileFavorite'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function toggleFileFavorite($file_id, $favorite = null, string $contentType = self::contentTypes['toggleFileFavorite'][0])
    {
        list($response) = $this->toggleFileFavoriteWithHttpInfo($file_id, $favorite, $contentType);
        return $response;
    }

    /**
     * Operation toggleFileFavoriteWithHttpInfo
     *
     * REST API Reference for toggleFileFavorite Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/toggle-file-favorite/
     *
     * @param  int $file_id The file ID. (required)
     * @param  bool|null $favorite Specifies if the file is marked as favorite or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toggleFileFavorite'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function toggleFileFavoriteWithHttpInfo($file_id, $favorite = null, string $contentType = self::contentTypes['toggleFileFavorite'][0])
    {
        $request = $this->toggleFileFavoriteRequest($file_id, $favorite, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation toggleFileFavoriteAsync
     *
     * REST API Reference for toggleFileFavorite Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/toggle-file-favorite/
     *
     * @param  int $file_id The file ID. (required)
     * @param  bool|null $favorite Specifies if the file is marked as favorite or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toggleFileFavorite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toggleFileFavoriteAsync($file_id, $favorite = null, string $contentType = self::contentTypes['toggleFileFavorite'][0])
    {
        return $this->toggleFileFavoriteAsyncWithHttpInfo($file_id, $favorite, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation toggleFileFavoriteAsyncWithHttpInfo
     *
     * REST API Reference for toggleFileFavorite Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/toggle-file-favorite/
     *
     * @param  int $file_id The file ID. (required)
     * @param  bool|null $favorite Specifies if the file is marked as favorite or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toggleFileFavorite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function toggleFileFavoriteAsyncWithHttpInfo($file_id, $favorite = null, string $contentType = self::contentTypes['toggleFileFavorite'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->toggleFileFavoriteRequest($file_id, $favorite, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'toggleFileFavorite'
     *
     * @param  int $file_id The file ID. (required)
     * @param  bool|null $favorite Specifies if the file is marked as favorite or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['toggleFileFavorite'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function toggleFileFavoriteRequest($file_id, $favorite = null, string $contentType = self::contentTypes['toggleFileFavorite'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling toggleFileFavorite'
            );
        }



        $resourcePath = '/api/2.0/files/favorites/{fileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $favorite,
            'favorite', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation trackEditFile
     *
     * REST API Reference for trackEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/track-edit-file/
     *
     * @param  int $file_id The file ID to track editing changes. (required)
     * @param  string|null $tab_id The tab ID to track editing changes. (optional)
     * @param  string|null $doc_key_for_track The document key for tracking changes. (optional)
     * @param  bool|null $is_finish Specifies whether to finish file tracking or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['trackEditFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\KeyValuePairBooleanStringWrapper
     */
    public function trackEditFile($file_id, $tab_id = null, $doc_key_for_track = null, $is_finish = null, string $contentType = self::contentTypes['trackEditFile'][0])
    {
        list($response) = $this->trackEditFileWithHttpInfo($file_id, $tab_id, $doc_key_for_track, $is_finish, $contentType);
        return $response;
    }

    /**
     * Operation trackEditFileWithHttpInfo
     *
     * REST API Reference for trackEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/track-edit-file/
     *
     * @param  int $file_id The file ID to track editing changes. (required)
     * @param  string|null $tab_id The tab ID to track editing changes. (optional)
     * @param  string|null $doc_key_for_track The document key for tracking changes. (optional)
     * @param  bool|null $is_finish Specifies whether to finish file tracking or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['trackEditFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\KeyValuePairBooleanStringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function trackEditFileWithHttpInfo($file_id, $tab_id = null, $doc_key_for_track = null, $is_finish = null, string $contentType = self::contentTypes['trackEditFile'][0])
    {
        $request = $this->trackEditFileRequest($file_id, $tab_id, $doc_key_for_track, $is_finish, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\KeyValuePairBooleanStringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\KeyValuePairBooleanStringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\KeyValuePairBooleanStringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation trackEditFileAsync
     *
     * REST API Reference for trackEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/track-edit-file/
     *
     * @param  int $file_id The file ID to track editing changes. (required)
     * @param  string|null $tab_id The tab ID to track editing changes. (optional)
     * @param  string|null $doc_key_for_track The document key for tracking changes. (optional)
     * @param  bool|null $is_finish Specifies whether to finish file tracking or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['trackEditFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function trackEditFileAsync($file_id, $tab_id = null, $doc_key_for_track = null, $is_finish = null, string $contentType = self::contentTypes['trackEditFile'][0])
    {
        return $this->trackEditFileAsyncWithHttpInfo($file_id, $tab_id, $doc_key_for_track, $is_finish, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation trackEditFileAsyncWithHttpInfo
     *
     * REST API Reference for trackEditFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/track-edit-file/
     *
     * @param  int $file_id The file ID to track editing changes. (required)
     * @param  string|null $tab_id The tab ID to track editing changes. (optional)
     * @param  string|null $doc_key_for_track The document key for tracking changes. (optional)
     * @param  bool|null $is_finish Specifies whether to finish file tracking or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['trackEditFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function trackEditFileAsyncWithHttpInfo($file_id, $tab_id = null, $doc_key_for_track = null, $is_finish = null, string $contentType = self::contentTypes['trackEditFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\KeyValuePairBooleanStringWrapper';
        $request = $this->trackEditFileRequest($file_id, $tab_id, $doc_key_for_track, $is_finish, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'trackEditFile'
     *
     * @param  int $file_id The file ID to track editing changes. (required)
     * @param  string|null $tab_id The tab ID to track editing changes. (optional)
     * @param  string|null $doc_key_for_track The document key for tracking changes. (optional)
     * @param  bool|null $is_finish Specifies whether to finish file tracking or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['trackEditFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function trackEditFileRequest($file_id, $tab_id = null, $doc_key_for_track = null, $is_finish = null, string $contentType = self::contentTypes['trackEditFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling trackEditFile'
            );
        }





        $resourcePath = '/api/2.0/files/file/{fileId}/trackeditfile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tab_id,
            'tabId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $doc_key_for_track,
            'docKeyForTrack', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_finish,
            'isFinish', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFile
     *
     * REST API Reference for updateFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file/
     *
     * @param  int $file_id The file ID to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFile $update_file The parameters for updating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileIntegerWrapper
     */
    public function updateFile($file_id, $update_file, string $contentType = self::contentTypes['updateFile'][0])
    {
        list($response) = $this->updateFileWithHttpInfo($file_id, $update_file, $contentType);
        return $response;
    }

    /**
     * Operation updateFileWithHttpInfo
     *
     * REST API Reference for updateFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file/
     *
     * @param  int $file_id The file ID to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFile $update_file The parameters for updating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFileWithHttpInfo($file_id, $update_file, string $contentType = self::contentTypes['updateFile'][0])
    {
        $request = $this->updateFileRequest($file_id, $update_file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateFileAsync
     *
     * REST API Reference for updateFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file/
     *
     * @param  int $file_id The file ID to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFile $update_file The parameters for updating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileAsync($file_id, $update_file, string $contentType = self::contentTypes['updateFile'][0])
    {
        return $this->updateFileAsyncWithHttpInfo($file_id, $update_file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFileAsyncWithHttpInfo
     *
     * REST API Reference for updateFile Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file/
     *
     * @param  int $file_id The file ID to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFile $update_file The parameters for updating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileAsyncWithHttpInfo($file_id, $update_file, string $contentType = self::contentTypes['updateFile'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileIntegerWrapper';
        $request = $this->updateFileRequest($file_id, $update_file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFile'
     *
     * @param  int $file_id The file ID to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFile $update_file The parameters for updating a file. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFileRequest($file_id, $update_file, string $contentType = self::contentTypes['updateFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling updateFile'
            );
        }

        // verify the required parameter 'update_file' is set
        if ($update_file === null || (is_array($update_file) && count($update_file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_file when calling updateFile'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_file)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_file));
            } else {
                $httpBody = $update_file;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
