<?php
/*
 * (c) Copyright Ascensio System SIA 2025
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * onlyoffice/docspace-api-sdk
 *
 * A simple PHP SDK for integrating with the ONLYOFFICE DocSpace API
 *
 * The version of the OpenAPI document: 3.6.0
 * Contact: support@onlyoffice.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */


namespace OpenAPI\Client\Api\Files;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 *  Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class OperationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addFavorites' => [
            'application/json',
        ],
        'bulkDownload' => [
            'application/json',
        ],
        'checkConversionStatus' => [
            'application/json',
        ],
        'checkMoveOrCopyBatchItems' => [
            'application/json',
        ],
        'checkMoveOrCopyDestFolder' => [
            'application/json',
        ],
        'copyBatchItems' => [
            'application/json',
        ],
        'createUploadSession' => [
            'application/json',
        ],
        'deleteBatchItems' => [
            'application/json',
        ],
        'deleteFavoritesFromBody' => [
            'application/json',
        ],
        'deleteFileVersions' => [
            'application/json',
        ],
        'duplicateBatchItems' => [
            'application/json',
        ],
        'emptyTrash' => [
            'application/json',
        ],
        'getOperationStatuses' => [
            'application/json',
        ],
        'getOperationStatusesByType' => [
            'application/json',
        ],
        'markAsRead' => [
            'application/json',
        ],
        'moveBatchItems' => [
            'application/json',
        ],
        'startFileConversion' => [
            'application/json',
        ],
        'terminateTasks' => [
            'application/json',
        ],
        'updateFileComment' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }


    /**
     * Operation addFavorites
     *
     * Add favorite files and folders
     *
     * REST API Reference for addFavorites Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-favorites/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFavorites'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function addFavorites($base_batch_request_dto = null, string $contentType = self::contentTypes['addFavorites'][0])
    {
        list($response) = $this->addFavoritesWithHttpInfo($base_batch_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation addFavoritesWithHttpInfo
     *
     * Add favorite files and folders
     *
     * REST API Reference for addFavorites Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-favorites/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFavorites'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function addFavoritesWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['addFavorites'][0])
    {
        $request = $this->addFavoritesRequest($base_batch_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addFavoritesAsync
     *
     * Add favorite files and folders
     *
     * REST API Reference for addFavorites Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-favorites/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFavorites'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFavoritesAsync($base_batch_request_dto = null, string $contentType = self::contentTypes['addFavorites'][0])
    {
        return $this->addFavoritesAsyncWithHttpInfo($base_batch_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addFavoritesAsyncWithHttpInfo
     *
     * Add favorite files and folders
     *
     * REST API Reference for addFavorites Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-favorites/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFavorites'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addFavoritesAsyncWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['addFavorites'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->addFavoritesRequest($base_batch_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addFavorites'
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addFavorites'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addFavoritesRequest($base_batch_request_dto = null, string $contentType = self::contentTypes['addFavorites'][0])
    {



        $resourcePath = '/api/2.0/files/favorites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($base_batch_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($base_batch_request_dto));
            } else {
                $httpBody = $base_batch_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkDownload
     *
     * Bulk download
     *
     * REST API Reference for bulkDownload Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/bulk-download/
     *
     * @param  \OpenAPI\Client\Model\DownloadRequestDto|null $download_request_dto download_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDownload'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function bulkDownload($download_request_dto = null, string $contentType = self::contentTypes['bulkDownload'][0])
    {
        list($response) = $this->bulkDownloadWithHttpInfo($download_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation bulkDownloadWithHttpInfo
     *
     * Bulk download
     *
     * REST API Reference for bulkDownload Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/bulk-download/
     *
     * @param  \OpenAPI\Client\Model\DownloadRequestDto|null $download_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDownload'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkDownloadWithHttpInfo($download_request_dto = null, string $contentType = self::contentTypes['bulkDownload'][0])
    {
        $request = $this->bulkDownloadRequest($download_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation bulkDownloadAsync
     *
     * Bulk download
     *
     * REST API Reference for bulkDownload Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/bulk-download/
     *
     * @param  \OpenAPI\Client\Model\DownloadRequestDto|null $download_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDownload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkDownloadAsync($download_request_dto = null, string $contentType = self::contentTypes['bulkDownload'][0])
    {
        return $this->bulkDownloadAsyncWithHttpInfo($download_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkDownloadAsyncWithHttpInfo
     *
     * Bulk download
     *
     * REST API Reference for bulkDownload Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/bulk-download/
     *
     * @param  \OpenAPI\Client\Model\DownloadRequestDto|null $download_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDownload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkDownloadAsyncWithHttpInfo($download_request_dto = null, string $contentType = self::contentTypes['bulkDownload'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->bulkDownloadRequest($download_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkDownload'
     *
     * @param  \OpenAPI\Client\Model\DownloadRequestDto|null $download_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkDownload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkDownloadRequest($download_request_dto = null, string $contentType = self::contentTypes['bulkDownload'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/bulkdownload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($download_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($download_request_dto));
            } else {
                $httpBody = $download_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkConversionStatus
     *
     * Get conversion status
     *
     * REST API Reference for checkConversionStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-conversion-status/
     *
     * @param  int $file_id The file ID to check conversion status. (required)
     * @param  bool|null $start Specifies whether a conversion operation is started or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkConversionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConversationResultArrayWrapper
     */
    public function checkConversionStatus($file_id, $start = null, string $contentType = self::contentTypes['checkConversionStatus'][0])
    {
        list($response) = $this->checkConversionStatusWithHttpInfo($file_id, $start, $contentType);
        return $response;
    }

    /**
     * Operation checkConversionStatusWithHttpInfo
     *
     * Get conversion status
     *
     * REST API Reference for checkConversionStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-conversion-status/
     *
     * @param  int $file_id The file ID to check conversion status. (required)
     * @param  bool|null $start Specifies whether a conversion operation is started or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkConversionStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConversationResultArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkConversionStatusWithHttpInfo($file_id, $start = null, string $contentType = self::contentTypes['checkConversionStatus'][0])
    {
        $request = $this->checkConversionStatusRequest($file_id, $start, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ConversationResultArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ConversationResultArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConversationResultArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkConversionStatusAsync
     *
     * Get conversion status
     *
     * REST API Reference for checkConversionStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-conversion-status/
     *
     * @param  int $file_id The file ID to check conversion status. (required)
     * @param  bool|null $start Specifies whether a conversion operation is started or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkConversionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkConversionStatusAsync($file_id, $start = null, string $contentType = self::contentTypes['checkConversionStatus'][0])
    {
        return $this->checkConversionStatusAsyncWithHttpInfo($file_id, $start, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkConversionStatusAsyncWithHttpInfo
     *
     * Get conversion status
     *
     * REST API Reference for checkConversionStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-conversion-status/
     *
     * @param  int $file_id The file ID to check conversion status. (required)
     * @param  bool|null $start Specifies whether a conversion operation is started or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkConversionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkConversionStatusAsyncWithHttpInfo($file_id, $start = null, string $contentType = self::contentTypes['checkConversionStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConversationResultArrayWrapper';
        $request = $this->checkConversionStatusRequest($file_id, $start, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkConversionStatus'
     *
     * @param  int $file_id The file ID to check conversion status. (required)
     * @param  bool|null $start Specifies whether a conversion operation is started or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkConversionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkConversionStatusRequest($file_id, $start = null, string $contentType = self::contentTypes['checkConversionStatus'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling checkConversionStatus'
            );
        }



        $resourcePath = '/api/2.0/files/file/{fileId}/checkconversion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkMoveOrCopyBatchItems
     *
     * Move or copy files to a folder
     *
     * REST API Reference for checkMoveOrCopyBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-move-or-copy-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileEntryBaseArrayWrapper
     */
    public function checkMoveOrCopyBatchItems($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyBatchItems'][0])
    {
        list($response) = $this->checkMoveOrCopyBatchItemsWithHttpInfo($in_dto, $contentType);
        return $response;
    }

    /**
     * Operation checkMoveOrCopyBatchItemsWithHttpInfo
     *
     * Move or copy files to a folder
     *
     * REST API Reference for checkMoveOrCopyBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-move-or-copy-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileEntryBaseArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkMoveOrCopyBatchItemsWithHttpInfo($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyBatchItems'][0])
    {
        $request = $this->checkMoveOrCopyBatchItemsRequest($in_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkMoveOrCopyBatchItemsAsync
     *
     * Move or copy files to a folder
     *
     * REST API Reference for checkMoveOrCopyBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-move-or-copy-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkMoveOrCopyBatchItemsAsync($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyBatchItems'][0])
    {
        return $this->checkMoveOrCopyBatchItemsAsyncWithHttpInfo($in_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkMoveOrCopyBatchItemsAsyncWithHttpInfo
     *
     * Move or copy files to a folder
     *
     * REST API Reference for checkMoveOrCopyBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-move-or-copy-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkMoveOrCopyBatchItemsAsyncWithHttpInfo($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyBatchItems'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileEntryBaseArrayWrapper';
        $request = $this->checkMoveOrCopyBatchItemsRequest($in_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkMoveOrCopyBatchItems'
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkMoveOrCopyBatchItemsRequest($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyBatchItems'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $in_dto,
            'inDto', // param base name
            '\OpenAPIClientModelFileOperationRequestBaseDtoObject', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkMoveOrCopyDestFolder
     *
     * Check for moving or copying files to a folder
     *
     * REST API Reference for checkMoveOrCopyDestFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-move-or-copy-dest-folder/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyDestFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CheckDestFolderWrapper
     */
    public function checkMoveOrCopyDestFolder($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyDestFolder'][0])
    {
        list($response) = $this->checkMoveOrCopyDestFolderWithHttpInfo($in_dto, $contentType);
        return $response;
    }

    /**
     * Operation checkMoveOrCopyDestFolderWithHttpInfo
     *
     * Check for moving or copying files to a folder
     *
     * REST API Reference for checkMoveOrCopyDestFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-move-or-copy-dest-folder/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyDestFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CheckDestFolderWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkMoveOrCopyDestFolderWithHttpInfo($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyDestFolder'][0])
    {
        $request = $this->checkMoveOrCopyDestFolderRequest($in_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CheckDestFolderWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CheckDestFolderWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CheckDestFolderWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkMoveOrCopyDestFolderAsync
     *
     * Check for moving or copying files to a folder
     *
     * REST API Reference for checkMoveOrCopyDestFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-move-or-copy-dest-folder/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyDestFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkMoveOrCopyDestFolderAsync($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyDestFolder'][0])
    {
        return $this->checkMoveOrCopyDestFolderAsyncWithHttpInfo($in_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkMoveOrCopyDestFolderAsyncWithHttpInfo
     *
     * Check for moving or copying files to a folder
     *
     * REST API Reference for checkMoveOrCopyDestFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-move-or-copy-dest-folder/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyDestFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkMoveOrCopyDestFolderAsyncWithHttpInfo($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyDestFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CheckDestFolderWrapper';
        $request = $this->checkMoveOrCopyDestFolderRequest($in_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkMoveOrCopyDestFolder'
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $in_dto The request parameters for copying/moving files. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkMoveOrCopyDestFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkMoveOrCopyDestFolderRequest($in_dto = null, string $contentType = self::contentTypes['checkMoveOrCopyDestFolder'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/checkdestfolder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $in_dto,
            'inDto', // param base name
            '\OpenAPIClientModelFileOperationRequestBaseDtoObject', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation copyBatchItems
     *
     * Copy to the folder
     *
     * REST API Reference for copyBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/copy-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function copyBatchItems($batch_request_dto = null, string $contentType = self::contentTypes['copyBatchItems'][0])
    {
        list($response) = $this->copyBatchItemsWithHttpInfo($batch_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation copyBatchItemsWithHttpInfo
     *
     * Copy to the folder
     *
     * REST API Reference for copyBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/copy-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function copyBatchItemsWithHttpInfo($batch_request_dto = null, string $contentType = self::contentTypes['copyBatchItems'][0])
    {
        $request = $this->copyBatchItemsRequest($batch_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation copyBatchItemsAsync
     *
     * Copy to the folder
     *
     * REST API Reference for copyBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/copy-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyBatchItemsAsync($batch_request_dto = null, string $contentType = self::contentTypes['copyBatchItems'][0])
    {
        return $this->copyBatchItemsAsyncWithHttpInfo($batch_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation copyBatchItemsAsyncWithHttpInfo
     *
     * Copy to the folder
     *
     * REST API Reference for copyBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/copy-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function copyBatchItemsAsyncWithHttpInfo($batch_request_dto = null, string $contentType = self::contentTypes['copyBatchItems'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->copyBatchItemsRequest($batch_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'copyBatchItems'
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['copyBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function copyBatchItemsRequest($batch_request_dto = null, string $contentType = self::contentTypes['copyBatchItems'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/copy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_request_dto));
            } else {
                $httpBody = $batch_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createUploadSession
     *
     * Chunked upload
     *
     * REST API Reference for createUploadSession Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-upload-session/
     *
     * @param  int $folder_id The session folder ID. (required)
     * @param  \OpenAPI\Client\Model\SessionRequest $session_request The session parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUploadSession'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectWrapper
     */
    public function createUploadSession($folder_id, $session_request, string $contentType = self::contentTypes['createUploadSession'][0])
    {
        list($response) = $this->createUploadSessionWithHttpInfo($folder_id, $session_request, $contentType);
        return $response;
    }

    /**
     * Operation createUploadSessionWithHttpInfo
     *
     * Chunked upload
     *
     * REST API Reference for createUploadSession Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-upload-session/
     *
     * @param  int $folder_id The session folder ID. (required)
     * @param  \OpenAPI\Client\Model\SessionRequest $session_request The session parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUploadSession'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createUploadSessionWithHttpInfo($folder_id, $session_request, string $contentType = self::contentTypes['createUploadSession'][0])
    {
        $request = $this->createUploadSessionRequest($folder_id, $session_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ObjectWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createUploadSessionAsync
     *
     * Chunked upload
     *
     * REST API Reference for createUploadSession Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-upload-session/
     *
     * @param  int $folder_id The session folder ID. (required)
     * @param  \OpenAPI\Client\Model\SessionRequest $session_request The session parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUploadSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadSessionAsync($folder_id, $session_request, string $contentType = self::contentTypes['createUploadSession'][0])
    {
        return $this->createUploadSessionAsyncWithHttpInfo($folder_id, $session_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createUploadSessionAsyncWithHttpInfo
     *
     * Chunked upload
     *
     * REST API Reference for createUploadSession Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-upload-session/
     *
     * @param  int $folder_id The session folder ID. (required)
     * @param  \OpenAPI\Client\Model\SessionRequest $session_request The session parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUploadSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createUploadSessionAsyncWithHttpInfo($folder_id, $session_request, string $contentType = self::contentTypes['createUploadSession'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectWrapper';
        $request = $this->createUploadSessionRequest($folder_id, $session_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createUploadSession'
     *
     * @param  int $folder_id The session folder ID. (required)
     * @param  \OpenAPI\Client\Model\SessionRequest $session_request The session parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createUploadSession'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createUploadSessionRequest($folder_id, $session_request, string $contentType = self::contentTypes['createUploadSession'][0])
    {

        // verify the required parameter 'folder_id' is set
        if ($folder_id === null || (is_array($folder_id) && count($folder_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $folder_id when calling createUploadSession'
            );
        }

        // verify the required parameter 'session_request' is set
        if ($session_request === null || (is_array($session_request) && count($session_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $session_request when calling createUploadSession'
            );
        }


        $resourcePath = '/api/2.0/files/{folderId}/upload/create_session';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($folder_id !== null) {
            $resourcePath = str_replace(
                '{' . 'folderId' . '}',
                ObjectSerializer::toPathValue($folder_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($session_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($session_request));
            } else {
                $httpBody = $session_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteBatchItems
     *
     * Delete files and folders
     *
     * REST API Reference for deleteBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-batch-items/
     *
     * @param  \OpenAPI\Client\Model\DeleteBatchRequestDto|null $delete_batch_request_dto delete_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function deleteBatchItems($delete_batch_request_dto = null, string $contentType = self::contentTypes['deleteBatchItems'][0])
    {
        list($response) = $this->deleteBatchItemsWithHttpInfo($delete_batch_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation deleteBatchItemsWithHttpInfo
     *
     * Delete files and folders
     *
     * REST API Reference for deleteBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-batch-items/
     *
     * @param  \OpenAPI\Client\Model\DeleteBatchRequestDto|null $delete_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteBatchItemsWithHttpInfo($delete_batch_request_dto = null, string $contentType = self::contentTypes['deleteBatchItems'][0])
    {
        $request = $this->deleteBatchItemsRequest($delete_batch_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteBatchItemsAsync
     *
     * Delete files and folders
     *
     * REST API Reference for deleteBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-batch-items/
     *
     * @param  \OpenAPI\Client\Model\DeleteBatchRequestDto|null $delete_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBatchItemsAsync($delete_batch_request_dto = null, string $contentType = self::contentTypes['deleteBatchItems'][0])
    {
        return $this->deleteBatchItemsAsyncWithHttpInfo($delete_batch_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteBatchItemsAsyncWithHttpInfo
     *
     * Delete files and folders
     *
     * REST API Reference for deleteBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-batch-items/
     *
     * @param  \OpenAPI\Client\Model\DeleteBatchRequestDto|null $delete_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteBatchItemsAsyncWithHttpInfo($delete_batch_request_dto = null, string $contentType = self::contentTypes['deleteBatchItems'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->deleteBatchItemsRequest($delete_batch_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteBatchItems'
     *
     * @param  \OpenAPI\Client\Model\DeleteBatchRequestDto|null $delete_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteBatchItemsRequest($delete_batch_request_dto = null, string $contentType = self::contentTypes['deleteBatchItems'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/delete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($delete_batch_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($delete_batch_request_dto));
            } else {
                $httpBody = $delete_batch_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFavoritesFromBody
     *
     * Delete favorite files and folders (using body parameters)
     *
     * REST API Reference for deleteFavoritesFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-favorites-from-body/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFavoritesFromBody'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function deleteFavoritesFromBody($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteFavoritesFromBody'][0])
    {
        list($response) = $this->deleteFavoritesFromBodyWithHttpInfo($base_batch_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation deleteFavoritesFromBodyWithHttpInfo
     *
     * Delete favorite files and folders (using body parameters)
     *
     * REST API Reference for deleteFavoritesFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-favorites-from-body/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFavoritesFromBody'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFavoritesFromBodyWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteFavoritesFromBody'][0])
    {
        $request = $this->deleteFavoritesFromBodyRequest($base_batch_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFavoritesFromBodyAsync
     *
     * Delete favorite files and folders (using body parameters)
     *
     * REST API Reference for deleteFavoritesFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-favorites-from-body/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFavoritesFromBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFavoritesFromBodyAsync($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteFavoritesFromBody'][0])
    {
        return $this->deleteFavoritesFromBodyAsyncWithHttpInfo($base_batch_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFavoritesFromBodyAsyncWithHttpInfo
     *
     * Delete favorite files and folders (using body parameters)
     *
     * REST API Reference for deleteFavoritesFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-favorites-from-body/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFavoritesFromBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFavoritesFromBodyAsyncWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteFavoritesFromBody'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->deleteFavoritesFromBodyRequest($base_batch_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFavoritesFromBody'
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFavoritesFromBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFavoritesFromBodyRequest($base_batch_request_dto = null, string $contentType = self::contentTypes['deleteFavoritesFromBody'][0])
    {



        $resourcePath = '/api/2.0/files/favorites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($base_batch_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($base_batch_request_dto));
            } else {
                $httpBody = $base_batch_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFileVersions
     *
     * Delete file versions
     *
     * REST API Reference for deleteFileVersions Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-file-versions/
     *
     * @param  \OpenAPI\Client\Model\DeleteVersionBatchRequestDto|null $delete_version_batch_request_dto delete_version_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileVersions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationWrapper
     */
    public function deleteFileVersions($delete_version_batch_request_dto = null, string $contentType = self::contentTypes['deleteFileVersions'][0])
    {
        list($response) = $this->deleteFileVersionsWithHttpInfo($delete_version_batch_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation deleteFileVersionsWithHttpInfo
     *
     * Delete file versions
     *
     * REST API Reference for deleteFileVersions Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-file-versions/
     *
     * @param  \OpenAPI\Client\Model\DeleteVersionBatchRequestDto|null $delete_version_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileVersions'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFileVersionsWithHttpInfo($delete_version_batch_request_dto = null, string $contentType = self::contentTypes['deleteFileVersions'][0])
    {
        $request = $this->deleteFileVersionsRequest($delete_version_batch_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteFileVersionsAsync
     *
     * Delete file versions
     *
     * REST API Reference for deleteFileVersions Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-file-versions/
     *
     * @param  \OpenAPI\Client\Model\DeleteVersionBatchRequestDto|null $delete_version_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileVersionsAsync($delete_version_batch_request_dto = null, string $contentType = self::contentTypes['deleteFileVersions'][0])
    {
        return $this->deleteFileVersionsAsyncWithHttpInfo($delete_version_batch_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFileVersionsAsyncWithHttpInfo
     *
     * Delete file versions
     *
     * REST API Reference for deleteFileVersions Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-file-versions/
     *
     * @param  \OpenAPI\Client\Model\DeleteVersionBatchRequestDto|null $delete_version_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFileVersionsAsyncWithHttpInfo($delete_version_batch_request_dto = null, string $contentType = self::contentTypes['deleteFileVersions'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationWrapper';
        $request = $this->deleteFileVersionsRequest($delete_version_batch_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFileVersions'
     *
     * @param  \OpenAPI\Client\Model\DeleteVersionBatchRequestDto|null $delete_version_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteFileVersions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFileVersionsRequest($delete_version_batch_request_dto = null, string $contentType = self::contentTypes['deleteFileVersions'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/deleteversion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($delete_version_batch_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($delete_version_batch_request_dto));
            } else {
                $httpBody = $delete_version_batch_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation duplicateBatchItems
     *
     * Duplicate files and folders
     *
     * REST API Reference for duplicateBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/duplicate-batch-items/
     *
     * @param  \OpenAPI\Client\Model\DuplicateRequestDto|null $duplicate_request_dto duplicate_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function duplicateBatchItems($duplicate_request_dto = null, string $contentType = self::contentTypes['duplicateBatchItems'][0])
    {
        list($response) = $this->duplicateBatchItemsWithHttpInfo($duplicate_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation duplicateBatchItemsWithHttpInfo
     *
     * Duplicate files and folders
     *
     * REST API Reference for duplicateBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/duplicate-batch-items/
     *
     * @param  \OpenAPI\Client\Model\DuplicateRequestDto|null $duplicate_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function duplicateBatchItemsWithHttpInfo($duplicate_request_dto = null, string $contentType = self::contentTypes['duplicateBatchItems'][0])
    {
        $request = $this->duplicateBatchItemsRequest($duplicate_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation duplicateBatchItemsAsync
     *
     * Duplicate files and folders
     *
     * REST API Reference for duplicateBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/duplicate-batch-items/
     *
     * @param  \OpenAPI\Client\Model\DuplicateRequestDto|null $duplicate_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function duplicateBatchItemsAsync($duplicate_request_dto = null, string $contentType = self::contentTypes['duplicateBatchItems'][0])
    {
        return $this->duplicateBatchItemsAsyncWithHttpInfo($duplicate_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation duplicateBatchItemsAsyncWithHttpInfo
     *
     * Duplicate files and folders
     *
     * REST API Reference for duplicateBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/duplicate-batch-items/
     *
     * @param  \OpenAPI\Client\Model\DuplicateRequestDto|null $duplicate_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function duplicateBatchItemsAsyncWithHttpInfo($duplicate_request_dto = null, string $contentType = self::contentTypes['duplicateBatchItems'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->duplicateBatchItemsRequest($duplicate_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'duplicateBatchItems'
     *
     * @param  \OpenAPI\Client\Model\DuplicateRequestDto|null $duplicate_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['duplicateBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function duplicateBatchItemsRequest($duplicate_request_dto = null, string $contentType = self::contentTypes['duplicateBatchItems'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/duplicate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($duplicate_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($duplicate_request_dto));
            } else {
                $httpBody = $duplicate_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation emptyTrash
     *
     * Empty the Trash folder
     *
     * REST API Reference for emptyTrash Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/empty-trash/
     *
     * @param  bool|null $single Specifies whether to return only the current operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emptyTrash'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function emptyTrash($single = null, string $contentType = self::contentTypes['emptyTrash'][0])
    {
        list($response) = $this->emptyTrashWithHttpInfo($single, $contentType);
        return $response;
    }

    /**
     * Operation emptyTrashWithHttpInfo
     *
     * Empty the Trash folder
     *
     * REST API Reference for emptyTrash Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/empty-trash/
     *
     * @param  bool|null $single Specifies whether to return only the current operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emptyTrash'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function emptyTrashWithHttpInfo($single = null, string $contentType = self::contentTypes['emptyTrash'][0])
    {
        $request = $this->emptyTrashRequest($single, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation emptyTrashAsync
     *
     * Empty the Trash folder
     *
     * REST API Reference for emptyTrash Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/empty-trash/
     *
     * @param  bool|null $single Specifies whether to return only the current operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emptyTrash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emptyTrashAsync($single = null, string $contentType = self::contentTypes['emptyTrash'][0])
    {
        return $this->emptyTrashAsyncWithHttpInfo($single, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation emptyTrashAsyncWithHttpInfo
     *
     * Empty the Trash folder
     *
     * REST API Reference for emptyTrash Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/empty-trash/
     *
     * @param  bool|null $single Specifies whether to return only the current operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emptyTrash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function emptyTrashAsyncWithHttpInfo($single = null, string $contentType = self::contentTypes['emptyTrash'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->emptyTrashRequest($single, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'emptyTrash'
     *
     * @param  bool|null $single Specifies whether to return only the current operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['emptyTrash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function emptyTrashRequest($single = null, string $contentType = self::contentTypes['emptyTrash'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/emptytrash';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $single,
            'Single', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOperationStatuses
     *
     * Get active file operations
     *
     * REST API Reference for getOperationStatuses Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-operation-statuses/
     *
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatuses'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function getOperationStatuses($id = null, string $contentType = self::contentTypes['getOperationStatuses'][0])
    {
        list($response) = $this->getOperationStatusesWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getOperationStatusesWithHttpInfo
     *
     * Get active file operations
     *
     * REST API Reference for getOperationStatuses Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-operation-statuses/
     *
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatuses'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOperationStatusesWithHttpInfo($id = null, string $contentType = self::contentTypes['getOperationStatuses'][0])
    {
        $request = $this->getOperationStatusesRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOperationStatusesAsync
     *
     * Get active file operations
     *
     * REST API Reference for getOperationStatuses Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-operation-statuses/
     *
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperationStatusesAsync($id = null, string $contentType = self::contentTypes['getOperationStatuses'][0])
    {
        return $this->getOperationStatusesAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOperationStatusesAsyncWithHttpInfo
     *
     * Get active file operations
     *
     * REST API Reference for getOperationStatuses Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-operation-statuses/
     *
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperationStatusesAsyncWithHttpInfo($id = null, string $contentType = self::contentTypes['getOperationStatuses'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->getOperationStatusesRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOperationStatuses'
     *
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatuses'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOperationStatusesRequest($id = null, string $contentType = self::contentTypes['getOperationStatuses'][0])
    {



        $resourcePath = '/api/2.0/files/fileops';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOperationStatusesByType
     *
     * Get file operation statuses
     *
     * REST API Reference for getOperationStatusesByType Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-operation-statuses-by-type/
     *
     * @param  \OpenAPI\Client\Model\FileOperationType $operation_type Specifies the type of file operation to be retrieved. (required)
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatusesByType'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function getOperationStatusesByType($operation_type, $id = null, string $contentType = self::contentTypes['getOperationStatusesByType'][0])
    {
        list($response) = $this->getOperationStatusesByTypeWithHttpInfo($operation_type, $id, $contentType);
        return $response;
    }

    /**
     * Operation getOperationStatusesByTypeWithHttpInfo
     *
     * Get file operation statuses
     *
     * REST API Reference for getOperationStatusesByType Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-operation-statuses-by-type/
     *
     * @param  \OpenAPI\Client\Model\FileOperationType $operation_type Specifies the type of file operation to be retrieved. (required)
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatusesByType'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOperationStatusesByTypeWithHttpInfo($operation_type, $id = null, string $contentType = self::contentTypes['getOperationStatusesByType'][0])
    {
        $request = $this->getOperationStatusesByTypeRequest($operation_type, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getOperationStatusesByTypeAsync
     *
     * Get file operation statuses
     *
     * REST API Reference for getOperationStatusesByType Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-operation-statuses-by-type/
     *
     * @param  \OpenAPI\Client\Model\FileOperationType $operation_type Specifies the type of file operation to be retrieved. (required)
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatusesByType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperationStatusesByTypeAsync($operation_type, $id = null, string $contentType = self::contentTypes['getOperationStatusesByType'][0])
    {
        return $this->getOperationStatusesByTypeAsyncWithHttpInfo($operation_type, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOperationStatusesByTypeAsyncWithHttpInfo
     *
     * Get file operation statuses
     *
     * REST API Reference for getOperationStatusesByType Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-operation-statuses-by-type/
     *
     * @param  \OpenAPI\Client\Model\FileOperationType $operation_type Specifies the type of file operation to be retrieved. (required)
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatusesByType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperationStatusesByTypeAsyncWithHttpInfo($operation_type, $id = null, string $contentType = self::contentTypes['getOperationStatusesByType'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->getOperationStatusesByTypeRequest($operation_type, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOperationStatusesByType'
     *
     * @param  \OpenAPI\Client\Model\FileOperationType $operation_type Specifies the type of file operation to be retrieved. (required)
     * @param  string|null $id The ID of the file operation. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getOperationStatusesByType'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOperationStatusesByTypeRequest($operation_type, $id = null, string $contentType = self::contentTypes['getOperationStatusesByType'][0])
    {

        // verify the required parameter 'operation_type' is set
        if ($operation_type === null || (is_array($operation_type) && count($operation_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $operation_type when calling getOperationStatusesByType'
            );
        }



        $resourcePath = '/api/2.0/files/fileops/{operationType}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($operation_type !== null) {
            $resourcePath = str_replace(
                '{' . 'operationType' . '}',
                ObjectSerializer::toPathValue($operation_type),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markAsRead
     *
     * Mark as read
     *
     * REST API Reference for markAsRead Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/mark-as-read/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markAsRead'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function markAsRead($base_batch_request_dto = null, string $contentType = self::contentTypes['markAsRead'][0])
    {
        list($response) = $this->markAsReadWithHttpInfo($base_batch_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation markAsReadWithHttpInfo
     *
     * Mark as read
     *
     * REST API Reference for markAsRead Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/mark-as-read/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markAsRead'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function markAsReadWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['markAsRead'][0])
    {
        $request = $this->markAsReadRequest($base_batch_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation markAsReadAsync
     *
     * Mark as read
     *
     * REST API Reference for markAsRead Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/mark-as-read/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markAsRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markAsReadAsync($base_batch_request_dto = null, string $contentType = self::contentTypes['markAsRead'][0])
    {
        return $this->markAsReadAsyncWithHttpInfo($base_batch_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation markAsReadAsyncWithHttpInfo
     *
     * Mark as read
     *
     * REST API Reference for markAsRead Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/mark-as-read/
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markAsRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markAsReadAsyncWithHttpInfo($base_batch_request_dto = null, string $contentType = self::contentTypes['markAsRead'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->markAsReadRequest($base_batch_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'markAsRead'
     *
     * @param  \OpenAPI\Client\Model\BaseBatchRequestDto|null $base_batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['markAsRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function markAsReadRequest($base_batch_request_dto = null, string $contentType = self::contentTypes['markAsRead'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/markasread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($base_batch_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($base_batch_request_dto));
            } else {
                $httpBody = $base_batch_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation moveBatchItems
     *
     * Move or copy to a folder
     *
     * REST API Reference for moveBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/move-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function moveBatchItems($batch_request_dto = null, string $contentType = self::contentTypes['moveBatchItems'][0])
    {
        list($response) = $this->moveBatchItemsWithHttpInfo($batch_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation moveBatchItemsWithHttpInfo
     *
     * Move or copy to a folder
     *
     * REST API Reference for moveBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/move-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveBatchItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function moveBatchItemsWithHttpInfo($batch_request_dto = null, string $contentType = self::contentTypes['moveBatchItems'][0])
    {
        $request = $this->moveBatchItemsRequest($batch_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation moveBatchItemsAsync
     *
     * Move or copy to a folder
     *
     * REST API Reference for moveBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/move-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveBatchItemsAsync($batch_request_dto = null, string $contentType = self::contentTypes['moveBatchItems'][0])
    {
        return $this->moveBatchItemsAsyncWithHttpInfo($batch_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation moveBatchItemsAsyncWithHttpInfo
     *
     * Move or copy to a folder
     *
     * REST API Reference for moveBatchItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/move-batch-items/
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function moveBatchItemsAsyncWithHttpInfo($batch_request_dto = null, string $contentType = self::contentTypes['moveBatchItems'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->moveBatchItemsRequest($batch_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'moveBatchItems'
     *
     * @param  \OpenAPI\Client\Model\BatchRequestDto|null $batch_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['moveBatchItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function moveBatchItemsRequest($batch_request_dto = null, string $contentType = self::contentTypes['moveBatchItems'][0])
    {



        $resourcePath = '/api/2.0/files/fileops/move';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_request_dto));
            } else {
                $httpBody = $batch_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startFileConversion
     *
     * Start file conversion
     *
     * REST API Reference for startFileConversion Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-file-conversion/
     *
     * @param  int $file_id The file ID to start conversion proccess. (required)
     * @param  \OpenAPI\Client\Model\CheckConversionRequestDtoInteger|null $check_conversion_request_dto_integer The parameters for checking file conversion. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFileConversion'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ConversationResultArrayWrapper
     */
    public function startFileConversion($file_id, $check_conversion_request_dto_integer = null, string $contentType = self::contentTypes['startFileConversion'][0])
    {
        list($response) = $this->startFileConversionWithHttpInfo($file_id, $check_conversion_request_dto_integer, $contentType);
        return $response;
    }

    /**
     * Operation startFileConversionWithHttpInfo
     *
     * Start file conversion
     *
     * REST API Reference for startFileConversion Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-file-conversion/
     *
     * @param  int $file_id The file ID to start conversion proccess. (required)
     * @param  \OpenAPI\Client\Model\CheckConversionRequestDtoInteger|null $check_conversion_request_dto_integer The parameters for checking file conversion. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFileConversion'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ConversationResultArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function startFileConversionWithHttpInfo($file_id, $check_conversion_request_dto_integer = null, string $contentType = self::contentTypes['startFileConversion'][0])
    {
        $request = $this->startFileConversionRequest($file_id, $check_conversion_request_dto_integer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ConversationResultArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ConversationResultArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ConversationResultArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation startFileConversionAsync
     *
     * Start file conversion
     *
     * REST API Reference for startFileConversion Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-file-conversion/
     *
     * @param  int $file_id The file ID to start conversion proccess. (required)
     * @param  \OpenAPI\Client\Model\CheckConversionRequestDtoInteger|null $check_conversion_request_dto_integer The parameters for checking file conversion. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFileConversion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startFileConversionAsync($file_id, $check_conversion_request_dto_integer = null, string $contentType = self::contentTypes['startFileConversion'][0])
    {
        return $this->startFileConversionAsyncWithHttpInfo($file_id, $check_conversion_request_dto_integer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startFileConversionAsyncWithHttpInfo
     *
     * Start file conversion
     *
     * REST API Reference for startFileConversion Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-file-conversion/
     *
     * @param  int $file_id The file ID to start conversion proccess. (required)
     * @param  \OpenAPI\Client\Model\CheckConversionRequestDtoInteger|null $check_conversion_request_dto_integer The parameters for checking file conversion. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFileConversion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startFileConversionAsyncWithHttpInfo($file_id, $check_conversion_request_dto_integer = null, string $contentType = self::contentTypes['startFileConversion'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ConversationResultArrayWrapper';
        $request = $this->startFileConversionRequest($file_id, $check_conversion_request_dto_integer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startFileConversion'
     *
     * @param  int $file_id The file ID to start conversion proccess. (required)
     * @param  \OpenAPI\Client\Model\CheckConversionRequestDtoInteger|null $check_conversion_request_dto_integer The parameters for checking file conversion. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startFileConversion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function startFileConversionRequest($file_id, $check_conversion_request_dto_integer = null, string $contentType = self::contentTypes['startFileConversion'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling startFileConversion'
            );
        }



        $resourcePath = '/api/2.0/files/file/{fileId}/checkconversion';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($check_conversion_request_dto_integer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($check_conversion_request_dto_integer));
            } else {
                $httpBody = $check_conversion_request_dto_integer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation terminateTasks
     *
     * Finish active operations
     *
     * REST API Reference for terminateTasks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/terminate-tasks/
     *
     * @param  string $id The operation unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateTasks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationArrayWrapper
     */
    public function terminateTasks($id, string $contentType = self::contentTypes['terminateTasks'][0])
    {
        list($response) = $this->terminateTasksWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation terminateTasksWithHttpInfo
     *
     * Finish active operations
     *
     * REST API Reference for terminateTasks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/terminate-tasks/
     *
     * @param  string $id The operation unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateTasks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function terminateTasksWithHttpInfo($id, string $contentType = self::contentTypes['terminateTasks'][0])
    {
        $request = $this->terminateTasksRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation terminateTasksAsync
     *
     * Finish active operations
     *
     * REST API Reference for terminateTasks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/terminate-tasks/
     *
     * @param  string $id The operation unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function terminateTasksAsync($id, string $contentType = self::contentTypes['terminateTasks'][0])
    {
        return $this->terminateTasksAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation terminateTasksAsyncWithHttpInfo
     *
     * Finish active operations
     *
     * REST API Reference for terminateTasks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/terminate-tasks/
     *
     * @param  string $id The operation unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function terminateTasksAsyncWithHttpInfo($id, string $contentType = self::contentTypes['terminateTasks'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationArrayWrapper';
        $request = $this->terminateTasksRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'terminateTasks'
     *
     * @param  string $id The operation unique identifier. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateTasks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function terminateTasksRequest($id, string $contentType = self::contentTypes['terminateTasks'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling terminateTasks'
            );
        }


        $resourcePath = '/api/2.0/files/fileops/terminate/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFileComment
     *
     * Update a comment
     *
     * REST API Reference for updateFileComment Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file-comment/
     *
     * @param  int $file_id The file ID where the comment is located. (required)
     * @param  \OpenAPI\Client\Model\UpdateComment $update_comment The parameters for updating a comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringWrapper
     */
    public function updateFileComment($file_id, $update_comment, string $contentType = self::contentTypes['updateFileComment'][0])
    {
        list($response) = $this->updateFileCommentWithHttpInfo($file_id, $update_comment, $contentType);
        return $response;
    }

    /**
     * Operation updateFileCommentWithHttpInfo
     *
     * Update a comment
     *
     * REST API Reference for updateFileComment Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file-comment/
     *
     * @param  int $file_id The file ID where the comment is located. (required)
     * @param  \OpenAPI\Client\Model\UpdateComment $update_comment The parameters for updating a comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileComment'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFileCommentWithHttpInfo($file_id, $update_comment, string $contentType = self::contentTypes['updateFileComment'][0])
    {
        $request = $this->updateFileCommentRequest($file_id, $update_comment, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateFileCommentAsync
     *
     * Update a comment
     *
     * REST API Reference for updateFileComment Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file-comment/
     *
     * @param  int $file_id The file ID where the comment is located. (required)
     * @param  \OpenAPI\Client\Model\UpdateComment $update_comment The parameters for updating a comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileCommentAsync($file_id, $update_comment, string $contentType = self::contentTypes['updateFileComment'][0])
    {
        return $this->updateFileCommentAsyncWithHttpInfo($file_id, $update_comment, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFileCommentAsyncWithHttpInfo
     *
     * Update a comment
     *
     * REST API Reference for updateFileComment Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file-comment/
     *
     * @param  int $file_id The file ID where the comment is located. (required)
     * @param  \OpenAPI\Client\Model\UpdateComment $update_comment The parameters for updating a comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileCommentAsyncWithHttpInfo($file_id, $update_comment, string $contentType = self::contentTypes['updateFileComment'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StringWrapper';
        $request = $this->updateFileCommentRequest($file_id, $update_comment, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFileComment'
     *
     * @param  int $file_id The file ID where the comment is located. (required)
     * @param  \OpenAPI\Client\Model\UpdateComment $update_comment The parameters for updating a comment. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileComment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFileCommentRequest($file_id, $update_comment, string $contentType = self::contentTypes['updateFileComment'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling updateFileComment'
            );
        }

        // verify the required parameter 'update_comment' is set
        if ($update_comment === null || (is_array($update_comment) && count($update_comment) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_comment when calling updateFileComment'
            );
        }


        $resourcePath = '/api/2.0/files/file/{fileId}/comment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_comment)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_comment));
            } else {
                $httpBody = $update_comment;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
