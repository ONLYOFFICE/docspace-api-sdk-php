<?php
/*
 * (c) Copyright Ascensio System SIA 2025
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * onlyoffice/docspace-api-sdk
 *
 * A simple PHP SDK for integrating with the ONLYOFFICE DocSpace API
 *
 * The version of the OpenAPI document: 3.6.0
 * Contact: support@onlyoffice.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */


namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 *  Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SettingsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'changeAccessToThirdparty' => [
            'application/json',
        ],
        'changeAutomaticallyCleanUp' => [
            'application/json',
        ],
        'changeDefaultAccessRights' => [
            'application/json',
        ],
        'changeDeleteConfirm' => [
            'application/json',
        ],
        'changeDownloadZipFromBody' => [
            'application/json',
        ],
        'checkDocServiceUrl' => [
            'application/json',
        ],
        'displayFileExtension' => [
            'application/json',
        ],
        'displayRecent' => [
            'application/json',
        ],
        'externalShare' => [
            'application/json',
        ],
        'externalShareSocialMedia' => [
            'application/json',
        ],
        'forcesave' => [
            'application/json',
        ],
        'getAutomaticallyCleanUp' => [
            'application/json',
        ],
        'getDocServiceUrl' => [
            'application/json',
        ],
        'getFilesModule' => [
            'application/json',
        ],
        'getFilesSettings' => [
            'application/json',
        ],
        'hideConfirmCancelOperation' => [
            'application/json',
        ],
        'hideConfirmConvert' => [
            'application/json',
        ],
        'hideConfirmRoomLifetime' => [
            'application/json',
        ],
        'isAvailablePrivacyRoomSettings' => [
            'application/json',
        ],
        'keepNewFileName' => [
            'application/json',
        ],
        'setOpenEditorInSameTab' => [
            'application/json',
        ],
        'storeForcesave' => [
            'application/json',
        ],
        'storeOriginal' => [
            'application/json',
        ],
        'updateFileIfExist' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }


    /**
     * Operation changeAccessToThirdparty
     *
     * Change the third-party settings access
     *
     * REST API Reference for changeAccessToThirdparty Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-access-to-thirdparty/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessToThirdparty'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function changeAccessToThirdparty($settings_request_dto = null, string $contentType = self::contentTypes['changeAccessToThirdparty'][0])
    {
        list($response) = $this->changeAccessToThirdpartyWithHttpInfo($settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation changeAccessToThirdpartyWithHttpInfo
     *
     * Change the third-party settings access
     *
     * REST API Reference for changeAccessToThirdparty Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-access-to-thirdparty/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessToThirdparty'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeAccessToThirdpartyWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['changeAccessToThirdparty'][0])
    {
        $request = $this->changeAccessToThirdpartyRequest($settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation changeAccessToThirdpartyAsync
     *
     * Change the third-party settings access
     *
     * REST API Reference for changeAccessToThirdparty Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-access-to-thirdparty/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessToThirdparty'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeAccessToThirdpartyAsync($settings_request_dto = null, string $contentType = self::contentTypes['changeAccessToThirdparty'][0])
    {
        return $this->changeAccessToThirdpartyAsyncWithHttpInfo($settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeAccessToThirdpartyAsyncWithHttpInfo
     *
     * Change the third-party settings access
     *
     * REST API Reference for changeAccessToThirdparty Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-access-to-thirdparty/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessToThirdparty'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeAccessToThirdpartyAsyncWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['changeAccessToThirdparty'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->changeAccessToThirdpartyRequest($settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeAccessToThirdparty'
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAccessToThirdparty'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function changeAccessToThirdpartyRequest($settings_request_dto = null, string $contentType = self::contentTypes['changeAccessToThirdparty'][0])
    {



        $resourcePath = '/api/2.0/files/thirdparty';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings_request_dto));
            } else {
                $httpBody = $settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeAutomaticallyCleanUp
     *
     * Update the trash bin auto-clearing setting
     *
     * REST API Reference for changeAutomaticallyCleanUp Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-automatically-clean-up/
     *
     * @param  \OpenAPI\Client\Model\AutoCleanupRequestDto|null $auto_cleanup_request_dto auto_cleanup_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AutoCleanUpDataWrapper
     */
    public function changeAutomaticallyCleanUp($auto_cleanup_request_dto = null, string $contentType = self::contentTypes['changeAutomaticallyCleanUp'][0])
    {
        list($response) = $this->changeAutomaticallyCleanUpWithHttpInfo($auto_cleanup_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation changeAutomaticallyCleanUpWithHttpInfo
     *
     * Update the trash bin auto-clearing setting
     *
     * REST API Reference for changeAutomaticallyCleanUp Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-automatically-clean-up/
     *
     * @param  \OpenAPI\Client\Model\AutoCleanupRequestDto|null $auto_cleanup_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AutoCleanUpDataWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeAutomaticallyCleanUpWithHttpInfo($auto_cleanup_request_dto = null, string $contentType = self::contentTypes['changeAutomaticallyCleanUp'][0])
    {
        $request = $this->changeAutomaticallyCleanUpRequest($auto_cleanup_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AutoCleanUpDataWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AutoCleanUpDataWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AutoCleanUpDataWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation changeAutomaticallyCleanUpAsync
     *
     * Update the trash bin auto-clearing setting
     *
     * REST API Reference for changeAutomaticallyCleanUp Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-automatically-clean-up/
     *
     * @param  \OpenAPI\Client\Model\AutoCleanupRequestDto|null $auto_cleanup_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeAutomaticallyCleanUpAsync($auto_cleanup_request_dto = null, string $contentType = self::contentTypes['changeAutomaticallyCleanUp'][0])
    {
        return $this->changeAutomaticallyCleanUpAsyncWithHttpInfo($auto_cleanup_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeAutomaticallyCleanUpAsyncWithHttpInfo
     *
     * Update the trash bin auto-clearing setting
     *
     * REST API Reference for changeAutomaticallyCleanUp Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-automatically-clean-up/
     *
     * @param  \OpenAPI\Client\Model\AutoCleanupRequestDto|null $auto_cleanup_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeAutomaticallyCleanUpAsyncWithHttpInfo($auto_cleanup_request_dto = null, string $contentType = self::contentTypes['changeAutomaticallyCleanUp'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AutoCleanUpDataWrapper';
        $request = $this->changeAutomaticallyCleanUpRequest($auto_cleanup_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeAutomaticallyCleanUp'
     *
     * @param  \OpenAPI\Client\Model\AutoCleanupRequestDto|null $auto_cleanup_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function changeAutomaticallyCleanUpRequest($auto_cleanup_request_dto = null, string $contentType = self::contentTypes['changeAutomaticallyCleanUp'][0])
    {



        $resourcePath = '/api/2.0/files/settings/autocleanup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($auto_cleanup_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($auto_cleanup_request_dto));
            } else {
                $httpBody = $auto_cleanup_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeDefaultAccessRights
     *
     * Change the default access rights
     *
     * REST API Reference for changeDefaultAccessRights Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-default-access-rights/
     *
     * @param  int[]|null $request_body Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDefaultAccessRights'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareArrayWrapper
     */
    public function changeDefaultAccessRights($request_body = null, string $contentType = self::contentTypes['changeDefaultAccessRights'][0])
    {
        list($response) = $this->changeDefaultAccessRightsWithHttpInfo($request_body, $contentType);
        return $response;
    }

    /**
     * Operation changeDefaultAccessRightsWithHttpInfo
     *
     * Change the default access rights
     *
     * REST API Reference for changeDefaultAccessRights Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-default-access-rights/
     *
     * @param  int[]|null $request_body Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDefaultAccessRights'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeDefaultAccessRightsWithHttpInfo($request_body = null, string $contentType = self::contentTypes['changeDefaultAccessRights'][0])
    {
        $request = $this->changeDefaultAccessRightsRequest($request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation changeDefaultAccessRightsAsync
     *
     * Change the default access rights
     *
     * REST API Reference for changeDefaultAccessRights Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-default-access-rights/
     *
     * @param  int[]|null $request_body Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDefaultAccessRights'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeDefaultAccessRightsAsync($request_body = null, string $contentType = self::contentTypes['changeDefaultAccessRights'][0])
    {
        return $this->changeDefaultAccessRightsAsyncWithHttpInfo($request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeDefaultAccessRightsAsyncWithHttpInfo
     *
     * Change the default access rights
     *
     * REST API Reference for changeDefaultAccessRights Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-default-access-rights/
     *
     * @param  int[]|null $request_body Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDefaultAccessRights'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeDefaultAccessRightsAsyncWithHttpInfo($request_body = null, string $contentType = self::contentTypes['changeDefaultAccessRights'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareArrayWrapper';
        $request = $this->changeDefaultAccessRightsRequest($request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeDefaultAccessRights'
     *
     * @param  int[]|null $request_body Sharing rights (None, ReadWrite, Read, Restrict, Varies, Review, Comment, FillForms, CustomFilter, RoomAdmin, Editing, Collaborator). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDefaultAccessRights'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function changeDefaultAccessRightsRequest($request_body = null, string $contentType = self::contentTypes['changeDefaultAccessRights'][0])
    {



        $resourcePath = '/api/2.0/files/settings/dafaultaccessrights';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeDeleteConfirm
     *
     * Confirm the file deletion
     *
     * REST API Reference for changeDeleteConfirm Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-delete-confirm/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDeleteConfirm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function changeDeleteConfirm($settings_request_dto = null, string $contentType = self::contentTypes['changeDeleteConfirm'][0])
    {
        list($response) = $this->changeDeleteConfirmWithHttpInfo($settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation changeDeleteConfirmWithHttpInfo
     *
     * Confirm the file deletion
     *
     * REST API Reference for changeDeleteConfirm Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-delete-confirm/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDeleteConfirm'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeDeleteConfirmWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['changeDeleteConfirm'][0])
    {
        $request = $this->changeDeleteConfirmRequest($settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation changeDeleteConfirmAsync
     *
     * Confirm the file deletion
     *
     * REST API Reference for changeDeleteConfirm Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-delete-confirm/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDeleteConfirm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeDeleteConfirmAsync($settings_request_dto = null, string $contentType = self::contentTypes['changeDeleteConfirm'][0])
    {
        return $this->changeDeleteConfirmAsyncWithHttpInfo($settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeDeleteConfirmAsyncWithHttpInfo
     *
     * Confirm the file deletion
     *
     * REST API Reference for changeDeleteConfirm Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-delete-confirm/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDeleteConfirm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeDeleteConfirmAsyncWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['changeDeleteConfirm'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->changeDeleteConfirmRequest($settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeDeleteConfirm'
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDeleteConfirm'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function changeDeleteConfirmRequest($settings_request_dto = null, string $contentType = self::contentTypes['changeDeleteConfirm'][0])
    {



        $resourcePath = '/api/2.0/files/changedeleteconfrim';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings_request_dto));
            } else {
                $httpBody = $settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeDownloadZipFromBody
     *
     * Change the archive format (using body parameters)
     *
     * REST API Reference for changeDownloadZipFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-download-zip-from-body/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDownloadZipFromBody'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ICompressWrapper
     */
    public function changeDownloadZipFromBody($display_request_dto = null, string $contentType = self::contentTypes['changeDownloadZipFromBody'][0])
    {
        list($response) = $this->changeDownloadZipFromBodyWithHttpInfo($display_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation changeDownloadZipFromBodyWithHttpInfo
     *
     * Change the archive format (using body parameters)
     *
     * REST API Reference for changeDownloadZipFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-download-zip-from-body/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDownloadZipFromBody'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ICompressWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeDownloadZipFromBodyWithHttpInfo($display_request_dto = null, string $contentType = self::contentTypes['changeDownloadZipFromBody'][0])
    {
        $request = $this->changeDownloadZipFromBodyRequest($display_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ICompressWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ICompressWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ICompressWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation changeDownloadZipFromBodyAsync
     *
     * Change the archive format (using body parameters)
     *
     * REST API Reference for changeDownloadZipFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-download-zip-from-body/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDownloadZipFromBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeDownloadZipFromBodyAsync($display_request_dto = null, string $contentType = self::contentTypes['changeDownloadZipFromBody'][0])
    {
        return $this->changeDownloadZipFromBodyAsyncWithHttpInfo($display_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeDownloadZipFromBodyAsyncWithHttpInfo
     *
     * Change the archive format (using body parameters)
     *
     * REST API Reference for changeDownloadZipFromBody Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-download-zip-from-body/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDownloadZipFromBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeDownloadZipFromBodyAsyncWithHttpInfo($display_request_dto = null, string $contentType = self::contentTypes['changeDownloadZipFromBody'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ICompressWrapper';
        $request = $this->changeDownloadZipFromBodyRequest($display_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeDownloadZipFromBody'
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeDownloadZipFromBody'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function changeDownloadZipFromBodyRequest($display_request_dto = null, string $contentType = self::contentTypes['changeDownloadZipFromBody'][0])
    {



        $resourcePath = '/api/2.0/files/settings/downloadtargz';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($display_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($display_request_dto));
            } else {
                $httpBody = $display_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation checkDocServiceUrl
     *
     * Check the document service URL
     *
     * REST API Reference for checkDocServiceUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-doc-service-url/
     *
     * @param  \OpenAPI\Client\Model\CheckDocServiceUrlRequestDto|null $check_doc_service_url_request_dto check_doc_service_url_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\DocServiceUrlWrapper
     */
    public function checkDocServiceUrl($check_doc_service_url_request_dto = null, string $contentType = self::contentTypes['checkDocServiceUrl'][0])
    {
        list($response) = $this->checkDocServiceUrlWithHttpInfo($check_doc_service_url_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation checkDocServiceUrlWithHttpInfo
     *
     * Check the document service URL
     *
     * REST API Reference for checkDocServiceUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-doc-service-url/
     *
     * @param  \OpenAPI\Client\Model\CheckDocServiceUrlRequestDto|null $check_doc_service_url_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\DocServiceUrlWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkDocServiceUrlWithHttpInfo($check_doc_service_url_request_dto = null, string $contentType = self::contentTypes['checkDocServiceUrl'][0])
    {
        $request = $this->checkDocServiceUrlRequest($check_doc_service_url_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\DocServiceUrlWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\DocServiceUrlWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DocServiceUrlWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation checkDocServiceUrlAsync
     *
     * Check the document service URL
     *
     * REST API Reference for checkDocServiceUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-doc-service-url/
     *
     * @param  \OpenAPI\Client\Model\CheckDocServiceUrlRequestDto|null $check_doc_service_url_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkDocServiceUrlAsync($check_doc_service_url_request_dto = null, string $contentType = self::contentTypes['checkDocServiceUrl'][0])
    {
        return $this->checkDocServiceUrlAsyncWithHttpInfo($check_doc_service_url_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkDocServiceUrlAsyncWithHttpInfo
     *
     * Check the document service URL
     *
     * REST API Reference for checkDocServiceUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/check-doc-service-url/
     *
     * @param  \OpenAPI\Client\Model\CheckDocServiceUrlRequestDto|null $check_doc_service_url_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkDocServiceUrlAsyncWithHttpInfo($check_doc_service_url_request_dto = null, string $contentType = self::contentTypes['checkDocServiceUrl'][0])
    {
        $returnType = '\OpenAPI\Client\Model\DocServiceUrlWrapper';
        $request = $this->checkDocServiceUrlRequest($check_doc_service_url_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkDocServiceUrl'
     *
     * @param  \OpenAPI\Client\Model\CheckDocServiceUrlRequestDto|null $check_doc_service_url_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkDocServiceUrlRequest($check_doc_service_url_request_dto = null, string $contentType = self::contentTypes['checkDocServiceUrl'][0])
    {



        $resourcePath = '/api/2.0/files/docservice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($check_doc_service_url_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($check_doc_service_url_request_dto));
            } else {
                $httpBody = $check_doc_service_url_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation displayFileExtension
     *
     * Display a file extension
     *
     * REST API Reference for displayFileExtension Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/display-file-extension/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayFileExtension'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function displayFileExtension($settings_request_dto = null, string $contentType = self::contentTypes['displayFileExtension'][0])
    {
        list($response) = $this->displayFileExtensionWithHttpInfo($settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation displayFileExtensionWithHttpInfo
     *
     * Display a file extension
     *
     * REST API Reference for displayFileExtension Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/display-file-extension/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayFileExtension'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function displayFileExtensionWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['displayFileExtension'][0])
    {
        $request = $this->displayFileExtensionRequest($settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation displayFileExtensionAsync
     *
     * Display a file extension
     *
     * REST API Reference for displayFileExtension Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/display-file-extension/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayFileExtension'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function displayFileExtensionAsync($settings_request_dto = null, string $contentType = self::contentTypes['displayFileExtension'][0])
    {
        return $this->displayFileExtensionAsyncWithHttpInfo($settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation displayFileExtensionAsyncWithHttpInfo
     *
     * Display a file extension
     *
     * REST API Reference for displayFileExtension Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/display-file-extension/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayFileExtension'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function displayFileExtensionAsyncWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['displayFileExtension'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->displayFileExtensionRequest($settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'displayFileExtension'
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayFileExtension'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function displayFileExtensionRequest($settings_request_dto = null, string $contentType = self::contentTypes['displayFileExtension'][0])
    {



        $resourcePath = '/api/2.0/files/displayfileextension';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings_request_dto));
            } else {
                $httpBody = $settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation displayRecent
     *
     * Display the Recent folder
     *
     * REST API Reference for displayRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/display-recent/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayRecent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function displayRecent($display_request_dto = null, string $contentType = self::contentTypes['displayRecent'][0])
    {
        list($response) = $this->displayRecentWithHttpInfo($display_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation displayRecentWithHttpInfo
     *
     * Display the Recent folder
     *
     * REST API Reference for displayRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/display-recent/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayRecent'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function displayRecentWithHttpInfo($display_request_dto = null, string $contentType = self::contentTypes['displayRecent'][0])
    {
        $request = $this->displayRecentRequest($display_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation displayRecentAsync
     *
     * Display the Recent folder
     *
     * REST API Reference for displayRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/display-recent/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayRecent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function displayRecentAsync($display_request_dto = null, string $contentType = self::contentTypes['displayRecent'][0])
    {
        return $this->displayRecentAsyncWithHttpInfo($display_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation displayRecentAsyncWithHttpInfo
     *
     * Display the Recent folder
     *
     * REST API Reference for displayRecent Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/display-recent/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayRecent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function displayRecentAsyncWithHttpInfo($display_request_dto = null, string $contentType = self::contentTypes['displayRecent'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->displayRecentRequest($display_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'displayRecent'
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['displayRecent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function displayRecentRequest($display_request_dto = null, string $contentType = self::contentTypes['displayRecent'][0])
    {



        $resourcePath = '/api/2.0/files/displayrecent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($display_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($display_request_dto));
            } else {
                $httpBody = $display_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation externalShare
     *
     * Change the external sharing ability
     *
     * REST API Reference for externalShare Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/external-share/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShare'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function externalShare($display_request_dto = null, string $contentType = self::contentTypes['externalShare'][0])
    {
        list($response) = $this->externalShareWithHttpInfo($display_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation externalShareWithHttpInfo
     *
     * Change the external sharing ability
     *
     * REST API Reference for externalShare Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/external-share/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShare'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function externalShareWithHttpInfo($display_request_dto = null, string $contentType = self::contentTypes['externalShare'][0])
    {
        $request = $this->externalShareRequest($display_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation externalShareAsync
     *
     * Change the external sharing ability
     *
     * REST API Reference for externalShare Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/external-share/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function externalShareAsync($display_request_dto = null, string $contentType = self::contentTypes['externalShare'][0])
    {
        return $this->externalShareAsyncWithHttpInfo($display_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation externalShareAsyncWithHttpInfo
     *
     * Change the external sharing ability
     *
     * REST API Reference for externalShare Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/external-share/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function externalShareAsyncWithHttpInfo($display_request_dto = null, string $contentType = self::contentTypes['externalShare'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->externalShareRequest($display_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'externalShare'
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShare'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function externalShareRequest($display_request_dto = null, string $contentType = self::contentTypes['externalShare'][0])
    {



        $resourcePath = '/api/2.0/files/settings/external';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($display_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($display_request_dto));
            } else {
                $httpBody = $display_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation externalShareSocialMedia
     *
     * Change the external sharing ability on social networks
     *
     * REST API Reference for externalShareSocialMedia Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/external-share-social-media/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShareSocialMedia'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function externalShareSocialMedia($display_request_dto = null, string $contentType = self::contentTypes['externalShareSocialMedia'][0])
    {
        list($response) = $this->externalShareSocialMediaWithHttpInfo($display_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation externalShareSocialMediaWithHttpInfo
     *
     * Change the external sharing ability on social networks
     *
     * REST API Reference for externalShareSocialMedia Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/external-share-social-media/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShareSocialMedia'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function externalShareSocialMediaWithHttpInfo($display_request_dto = null, string $contentType = self::contentTypes['externalShareSocialMedia'][0])
    {
        $request = $this->externalShareSocialMediaRequest($display_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation externalShareSocialMediaAsync
     *
     * Change the external sharing ability on social networks
     *
     * REST API Reference for externalShareSocialMedia Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/external-share-social-media/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShareSocialMedia'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function externalShareSocialMediaAsync($display_request_dto = null, string $contentType = self::contentTypes['externalShareSocialMedia'][0])
    {
        return $this->externalShareSocialMediaAsyncWithHttpInfo($display_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation externalShareSocialMediaAsyncWithHttpInfo
     *
     * Change the external sharing ability on social networks
     *
     * REST API Reference for externalShareSocialMedia Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/external-share-social-media/
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShareSocialMedia'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function externalShareSocialMediaAsyncWithHttpInfo($display_request_dto = null, string $contentType = self::contentTypes['externalShareSocialMedia'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->externalShareSocialMediaRequest($display_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'externalShareSocialMedia'
     *
     * @param  \OpenAPI\Client\Model\DisplayRequestDto|null $display_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['externalShareSocialMedia'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function externalShareSocialMediaRequest($display_request_dto = null, string $contentType = self::contentTypes['externalShareSocialMedia'][0])
    {



        $resourcePath = '/api/2.0/files/settings/externalsocialmedia';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($display_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($display_request_dto));
            } else {
                $httpBody = $display_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation forcesave
     *
     * Change the forcesaving ability
     *
     * REST API Reference for forcesave Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/forcesave/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forcesave'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function forcesave(string $contentType = self::contentTypes['forcesave'][0])
    {
        list($response) = $this->forcesaveWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation forcesaveWithHttpInfo
     *
     * Change the forcesaving ability
     *
     * REST API Reference for forcesave Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/forcesave/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forcesave'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function forcesaveWithHttpInfo(string $contentType = self::contentTypes['forcesave'][0])
    {
        $request = $this->forcesaveRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation forcesaveAsync
     *
     * Change the forcesaving ability
     *
     * REST API Reference for forcesave Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/forcesave/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forcesave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forcesaveAsync(string $contentType = self::contentTypes['forcesave'][0])
    {
        return $this->forcesaveAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation forcesaveAsyncWithHttpInfo
     *
     * Change the forcesaving ability
     *
     * REST API Reference for forcesave Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/forcesave/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forcesave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function forcesaveAsyncWithHttpInfo(string $contentType = self::contentTypes['forcesave'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->forcesaveRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'forcesave'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['forcesave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function forcesaveRequest(string $contentType = self::contentTypes['forcesave'][0])
    {


        $resourcePath = '/api/2.0/files/forcesave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAutomaticallyCleanUp
     *
     * Get the trash bin auto-clearing setting
     *
     * REST API Reference for getAutomaticallyCleanUp Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-automatically-clean-up/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AutoCleanUpDataWrapper
     */
    public function getAutomaticallyCleanUp(string $contentType = self::contentTypes['getAutomaticallyCleanUp'][0])
    {
        list($response) = $this->getAutomaticallyCleanUpWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getAutomaticallyCleanUpWithHttpInfo
     *
     * Get the trash bin auto-clearing setting
     *
     * REST API Reference for getAutomaticallyCleanUp Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-automatically-clean-up/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AutoCleanUpDataWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAutomaticallyCleanUpWithHttpInfo(string $contentType = self::contentTypes['getAutomaticallyCleanUp'][0])
    {
        $request = $this->getAutomaticallyCleanUpRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AutoCleanUpDataWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AutoCleanUpDataWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AutoCleanUpDataWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAutomaticallyCleanUpAsync
     *
     * Get the trash bin auto-clearing setting
     *
     * REST API Reference for getAutomaticallyCleanUp Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-automatically-clean-up/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAutomaticallyCleanUpAsync(string $contentType = self::contentTypes['getAutomaticallyCleanUp'][0])
    {
        return $this->getAutomaticallyCleanUpAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAutomaticallyCleanUpAsyncWithHttpInfo
     *
     * Get the trash bin auto-clearing setting
     *
     * REST API Reference for getAutomaticallyCleanUp Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-automatically-clean-up/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAutomaticallyCleanUpAsyncWithHttpInfo(string $contentType = self::contentTypes['getAutomaticallyCleanUp'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AutoCleanUpDataWrapper';
        $request = $this->getAutomaticallyCleanUpRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAutomaticallyCleanUp'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAutomaticallyCleanUp'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAutomaticallyCleanUpRequest(string $contentType = self::contentTypes['getAutomaticallyCleanUp'][0])
    {


        $resourcePath = '/api/2.0/files/settings/autocleanup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDocServiceUrl
     *
     * Get the document service URL
     *
     * REST API Reference for getDocServiceUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-doc-service-url/
     *
     * @param  bool|null $version Specifies whether to return the editor version or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\DocServiceUrlWrapper
     */
    public function getDocServiceUrl($version = null, string $contentType = self::contentTypes['getDocServiceUrl'][0])
    {
        list($response) = $this->getDocServiceUrlWithHttpInfo($version, $contentType);
        return $response;
    }

    /**
     * Operation getDocServiceUrlWithHttpInfo
     *
     * Get the document service URL
     *
     * REST API Reference for getDocServiceUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-doc-service-url/
     *
     * @param  bool|null $version Specifies whether to return the editor version or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\DocServiceUrlWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDocServiceUrlWithHttpInfo($version = null, string $contentType = self::contentTypes['getDocServiceUrl'][0])
    {
        $request = $this->getDocServiceUrlRequest($version, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\DocServiceUrlWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\DocServiceUrlWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DocServiceUrlWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDocServiceUrlAsync
     *
     * Get the document service URL
     *
     * REST API Reference for getDocServiceUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-doc-service-url/
     *
     * @param  bool|null $version Specifies whether to return the editor version or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocServiceUrlAsync($version = null, string $contentType = self::contentTypes['getDocServiceUrl'][0])
    {
        return $this->getDocServiceUrlAsyncWithHttpInfo($version, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDocServiceUrlAsyncWithHttpInfo
     *
     * Get the document service URL
     *
     * REST API Reference for getDocServiceUrl Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-doc-service-url/
     *
     * @param  bool|null $version Specifies whether to return the editor version or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDocServiceUrlAsyncWithHttpInfo($version = null, string $contentType = self::contentTypes['getDocServiceUrl'][0])
    {
        $returnType = '\OpenAPI\Client\Model\DocServiceUrlWrapper';
        $request = $this->getDocServiceUrlRequest($version, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDocServiceUrl'
     *
     * @param  bool|null $version Specifies whether to return the editor version or not. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDocServiceUrl'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDocServiceUrlRequest($version = null, string $contentType = self::contentTypes['getDocServiceUrl'][0])
    {



        $resourcePath = '/api/2.0/files/docservice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $version,
            'version', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFilesModule
     *
     * Get the Documents information
     *
     * REST API Reference for getFilesModule Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-module/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesModule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModuleWrapper
     */
    public function getFilesModule(string $contentType = self::contentTypes['getFilesModule'][0])
    {
        list($response) = $this->getFilesModuleWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getFilesModuleWithHttpInfo
     *
     * Get the Documents information
     *
     * REST API Reference for getFilesModule Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-module/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesModule'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModuleWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesModuleWithHttpInfo(string $contentType = self::contentTypes['getFilesModule'][0])
    {
        $request = $this->getFilesModuleRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ModuleWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ModuleWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModuleWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFilesModuleAsync
     *
     * Get the Documents information
     *
     * REST API Reference for getFilesModule Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-module/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesModule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesModuleAsync(string $contentType = self::contentTypes['getFilesModule'][0])
    {
        return $this->getFilesModuleAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesModuleAsyncWithHttpInfo
     *
     * Get the Documents information
     *
     * REST API Reference for getFilesModule Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-module/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesModule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesModuleAsyncWithHttpInfo(string $contentType = self::contentTypes['getFilesModule'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModuleWrapper';
        $request = $this->getFilesModuleRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFilesModule'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesModule'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFilesModuleRequest(string $contentType = self::contentTypes['getFilesModule'][0])
    {


        $resourcePath = '/api/2.0/files/info';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFilesSettings
     *
     * Get file settings
     *
     * REST API Reference for getFilesSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FilesSettingsWrapper
     */
    public function getFilesSettings(string $contentType = self::contentTypes['getFilesSettings'][0])
    {
        list($response) = $this->getFilesSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getFilesSettingsWithHttpInfo
     *
     * Get file settings
     *
     * REST API Reference for getFilesSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FilesSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFilesSettingsWithHttpInfo(string $contentType = self::contentTypes['getFilesSettings'][0])
    {
        $request = $this->getFilesSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FilesSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FilesSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FilesSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getFilesSettingsAsync
     *
     * Get file settings
     *
     * REST API Reference for getFilesSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesSettingsAsync(string $contentType = self::contentTypes['getFilesSettings'][0])
    {
        return $this->getFilesSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFilesSettingsAsyncWithHttpInfo
     *
     * Get file settings
     *
     * REST API Reference for getFilesSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-files-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFilesSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['getFilesSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FilesSettingsWrapper';
        $request = $this->getFilesSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFilesSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFilesSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFilesSettingsRequest(string $contentType = self::contentTypes['getFilesSettings'][0])
    {


        $resourcePath = '/api/2.0/files/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hideConfirmCancelOperation
     *
     * Hide confirmation dialog when canceling operations
     *
     * REST API Reference for hideConfirmCancelOperation Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-cancel-operation/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmCancelOperation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function hideConfirmCancelOperation($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmCancelOperation'][0])
    {
        list($response) = $this->hideConfirmCancelOperationWithHttpInfo($settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation hideConfirmCancelOperationWithHttpInfo
     *
     * Hide confirmation dialog when canceling operations
     *
     * REST API Reference for hideConfirmCancelOperation Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-cancel-operation/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmCancelOperation'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function hideConfirmCancelOperationWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmCancelOperation'][0])
    {
        $request = $this->hideConfirmCancelOperationRequest($settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation hideConfirmCancelOperationAsync
     *
     * Hide confirmation dialog when canceling operations
     *
     * REST API Reference for hideConfirmCancelOperation Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-cancel-operation/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmCancelOperation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideConfirmCancelOperationAsync($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmCancelOperation'][0])
    {
        return $this->hideConfirmCancelOperationAsyncWithHttpInfo($settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation hideConfirmCancelOperationAsyncWithHttpInfo
     *
     * Hide confirmation dialog when canceling operations
     *
     * REST API Reference for hideConfirmCancelOperation Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-cancel-operation/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmCancelOperation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideConfirmCancelOperationAsyncWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmCancelOperation'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->hideConfirmCancelOperationRequest($settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hideConfirmCancelOperation'
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmCancelOperation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function hideConfirmCancelOperationRequest($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmCancelOperation'][0])
    {



        $resourcePath = '/api/2.0/files/hideconfirmcanceloperation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings_request_dto));
            } else {
                $httpBody = $settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hideConfirmConvert
     *
     * Hide the confirmation dialog when converting
     *
     * REST API Reference for hideConfirmConvert Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-convert/
     *
     * @param  \OpenAPI\Client\Model\HideConfirmConvertRequestDto|null $hide_confirm_convert_request_dto hide_confirm_convert_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmConvert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ModuleWrapper
     */
    public function hideConfirmConvert($hide_confirm_convert_request_dto = null, string $contentType = self::contentTypes['hideConfirmConvert'][0])
    {
        list($response) = $this->hideConfirmConvertWithHttpInfo($hide_confirm_convert_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation hideConfirmConvertWithHttpInfo
     *
     * Hide the confirmation dialog when converting
     *
     * REST API Reference for hideConfirmConvert Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-convert/
     *
     * @param  \OpenAPI\Client\Model\HideConfirmConvertRequestDto|null $hide_confirm_convert_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmConvert'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ModuleWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function hideConfirmConvertWithHttpInfo($hide_confirm_convert_request_dto = null, string $contentType = self::contentTypes['hideConfirmConvert'][0])
    {
        $request = $this->hideConfirmConvertRequest($hide_confirm_convert_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ModuleWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ModuleWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ModuleWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation hideConfirmConvertAsync
     *
     * Hide the confirmation dialog when converting
     *
     * REST API Reference for hideConfirmConvert Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-convert/
     *
     * @param  \OpenAPI\Client\Model\HideConfirmConvertRequestDto|null $hide_confirm_convert_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmConvert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideConfirmConvertAsync($hide_confirm_convert_request_dto = null, string $contentType = self::contentTypes['hideConfirmConvert'][0])
    {
        return $this->hideConfirmConvertAsyncWithHttpInfo($hide_confirm_convert_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation hideConfirmConvertAsyncWithHttpInfo
     *
     * Hide the confirmation dialog when converting
     *
     * REST API Reference for hideConfirmConvert Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-convert/
     *
     * @param  \OpenAPI\Client\Model\HideConfirmConvertRequestDto|null $hide_confirm_convert_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmConvert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideConfirmConvertAsyncWithHttpInfo($hide_confirm_convert_request_dto = null, string $contentType = self::contentTypes['hideConfirmConvert'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ModuleWrapper';
        $request = $this->hideConfirmConvertRequest($hide_confirm_convert_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hideConfirmConvert'
     *
     * @param  \OpenAPI\Client\Model\HideConfirmConvertRequestDto|null $hide_confirm_convert_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmConvert'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function hideConfirmConvertRequest($hide_confirm_convert_request_dto = null, string $contentType = self::contentTypes['hideConfirmConvert'][0])
    {



        $resourcePath = '/api/2.0/files/hideconfirmconvert';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($hide_confirm_convert_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($hide_confirm_convert_request_dto));
            } else {
                $httpBody = $hide_confirm_convert_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hideConfirmRoomLifetime
     *
     * Hide confirmation dialog when changing room lifetime settings
     *
     * REST API Reference for hideConfirmRoomLifetime Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-room-lifetime/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmRoomLifetime'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function hideConfirmRoomLifetime($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmRoomLifetime'][0])
    {
        list($response) = $this->hideConfirmRoomLifetimeWithHttpInfo($settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation hideConfirmRoomLifetimeWithHttpInfo
     *
     * Hide confirmation dialog when changing room lifetime settings
     *
     * REST API Reference for hideConfirmRoomLifetime Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-room-lifetime/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmRoomLifetime'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function hideConfirmRoomLifetimeWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmRoomLifetime'][0])
    {
        $request = $this->hideConfirmRoomLifetimeRequest($settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation hideConfirmRoomLifetimeAsync
     *
     * Hide confirmation dialog when changing room lifetime settings
     *
     * REST API Reference for hideConfirmRoomLifetime Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-room-lifetime/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmRoomLifetime'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideConfirmRoomLifetimeAsync($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmRoomLifetime'][0])
    {
        return $this->hideConfirmRoomLifetimeAsyncWithHttpInfo($settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation hideConfirmRoomLifetimeAsyncWithHttpInfo
     *
     * Hide confirmation dialog when changing room lifetime settings
     *
     * REST API Reference for hideConfirmRoomLifetime Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/hide-confirm-room-lifetime/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmRoomLifetime'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideConfirmRoomLifetimeAsyncWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmRoomLifetime'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->hideConfirmRoomLifetimeRequest($settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hideConfirmRoomLifetime'
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideConfirmRoomLifetime'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function hideConfirmRoomLifetimeRequest($settings_request_dto = null, string $contentType = self::contentTypes['hideConfirmRoomLifetime'][0])
    {



        $resourcePath = '/api/2.0/files/hideconfirmroomlifetime';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings_request_dto));
            } else {
                $httpBody = $settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation isAvailablePrivacyRoomSettings
     *
     * Check the Private Room availability
     *
     * REST API Reference for isAvailablePrivacyRoomSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/is-available-privacy-room-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isAvailablePrivacyRoomSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function isAvailablePrivacyRoomSettings(string $contentType = self::contentTypes['isAvailablePrivacyRoomSettings'][0])
    {
        list($response) = $this->isAvailablePrivacyRoomSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation isAvailablePrivacyRoomSettingsWithHttpInfo
     *
     * Check the Private Room availability
     *
     * REST API Reference for isAvailablePrivacyRoomSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/is-available-privacy-room-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isAvailablePrivacyRoomSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function isAvailablePrivacyRoomSettingsWithHttpInfo(string $contentType = self::contentTypes['isAvailablePrivacyRoomSettings'][0])
    {
        $request = $this->isAvailablePrivacyRoomSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation isAvailablePrivacyRoomSettingsAsync
     *
     * Check the Private Room availability
     *
     * REST API Reference for isAvailablePrivacyRoomSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/is-available-privacy-room-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isAvailablePrivacyRoomSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function isAvailablePrivacyRoomSettingsAsync(string $contentType = self::contentTypes['isAvailablePrivacyRoomSettings'][0])
    {
        return $this->isAvailablePrivacyRoomSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation isAvailablePrivacyRoomSettingsAsyncWithHttpInfo
     *
     * Check the Private Room availability
     *
     * REST API Reference for isAvailablePrivacyRoomSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/is-available-privacy-room-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isAvailablePrivacyRoomSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function isAvailablePrivacyRoomSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['isAvailablePrivacyRoomSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->isAvailablePrivacyRoomSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'isAvailablePrivacyRoomSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['isAvailablePrivacyRoomSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function isAvailablePrivacyRoomSettingsRequest(string $contentType = self::contentTypes['isAvailablePrivacyRoomSettings'][0])
    {


        $resourcePath = '/api/2.0/files/@privacy/available';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation keepNewFileName
     *
     * Ask a new file name
     *
     * REST API Reference for keepNewFileName Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/keep-new-file-name/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['keepNewFileName'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function keepNewFileName($settings_request_dto = null, string $contentType = self::contentTypes['keepNewFileName'][0])
    {
        list($response) = $this->keepNewFileNameWithHttpInfo($settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation keepNewFileNameWithHttpInfo
     *
     * Ask a new file name
     *
     * REST API Reference for keepNewFileName Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/keep-new-file-name/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['keepNewFileName'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function keepNewFileNameWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['keepNewFileName'][0])
    {
        $request = $this->keepNewFileNameRequest($settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation keepNewFileNameAsync
     *
     * Ask a new file name
     *
     * REST API Reference for keepNewFileName Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/keep-new-file-name/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['keepNewFileName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function keepNewFileNameAsync($settings_request_dto = null, string $contentType = self::contentTypes['keepNewFileName'][0])
    {
        return $this->keepNewFileNameAsyncWithHttpInfo($settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation keepNewFileNameAsyncWithHttpInfo
     *
     * Ask a new file name
     *
     * REST API Reference for keepNewFileName Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/keep-new-file-name/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['keepNewFileName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function keepNewFileNameAsyncWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['keepNewFileName'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->keepNewFileNameRequest($settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'keepNewFileName'
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['keepNewFileName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function keepNewFileNameRequest($settings_request_dto = null, string $contentType = self::contentTypes['keepNewFileName'][0])
    {



        $resourcePath = '/api/2.0/files/keepnewfilename';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings_request_dto));
            } else {
                $httpBody = $settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setOpenEditorInSameTab
     *
     * Open document in the same browser tab
     *
     * REST API Reference for setOpenEditorInSameTab Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-open-editor-in-same-tab/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setOpenEditorInSameTab'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function setOpenEditorInSameTab($settings_request_dto = null, string $contentType = self::contentTypes['setOpenEditorInSameTab'][0])
    {
        list($response) = $this->setOpenEditorInSameTabWithHttpInfo($settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation setOpenEditorInSameTabWithHttpInfo
     *
     * Open document in the same browser tab
     *
     * REST API Reference for setOpenEditorInSameTab Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-open-editor-in-same-tab/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setOpenEditorInSameTab'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function setOpenEditorInSameTabWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['setOpenEditorInSameTab'][0])
    {
        $request = $this->setOpenEditorInSameTabRequest($settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setOpenEditorInSameTabAsync
     *
     * Open document in the same browser tab
     *
     * REST API Reference for setOpenEditorInSameTab Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-open-editor-in-same-tab/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setOpenEditorInSameTab'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setOpenEditorInSameTabAsync($settings_request_dto = null, string $contentType = self::contentTypes['setOpenEditorInSameTab'][0])
    {
        return $this->setOpenEditorInSameTabAsyncWithHttpInfo($settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setOpenEditorInSameTabAsyncWithHttpInfo
     *
     * Open document in the same browser tab
     *
     * REST API Reference for setOpenEditorInSameTab Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-open-editor-in-same-tab/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setOpenEditorInSameTab'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setOpenEditorInSameTabAsyncWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['setOpenEditorInSameTab'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->setOpenEditorInSameTabRequest($settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setOpenEditorInSameTab'
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setOpenEditorInSameTab'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setOpenEditorInSameTabRequest($settings_request_dto = null, string $contentType = self::contentTypes['setOpenEditorInSameTab'][0])
    {



        $resourcePath = '/api/2.0/files/settings/openeditorinsametab';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings_request_dto));
            } else {
                $httpBody = $settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeForcesave
     *
     * Change the ability to store the forcesaved files
     *
     * REST API Reference for storeForcesave Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/store-forcesave/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeForcesave'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function storeForcesave(string $contentType = self::contentTypes['storeForcesave'][0])
    {
        list($response) = $this->storeForcesaveWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation storeForcesaveWithHttpInfo
     *
     * Change the ability to store the forcesaved files
     *
     * REST API Reference for storeForcesave Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/store-forcesave/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeForcesave'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeForcesaveWithHttpInfo(string $contentType = self::contentTypes['storeForcesave'][0])
    {
        $request = $this->storeForcesaveRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeForcesaveAsync
     *
     * Change the ability to store the forcesaved files
     *
     * REST API Reference for storeForcesave Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/store-forcesave/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeForcesave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeForcesaveAsync(string $contentType = self::contentTypes['storeForcesave'][0])
    {
        return $this->storeForcesaveAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeForcesaveAsyncWithHttpInfo
     *
     * Change the ability to store the forcesaved files
     *
     * REST API Reference for storeForcesave Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/store-forcesave/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeForcesave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeForcesaveAsyncWithHttpInfo(string $contentType = self::contentTypes['storeForcesave'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->storeForcesaveRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeForcesave'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeForcesave'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeForcesaveRequest(string $contentType = self::contentTypes['storeForcesave'][0])
    {


        $resourcePath = '/api/2.0/files/storeforcesave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation storeOriginal
     *
     * Change the ability to upload original formats
     *
     * REST API Reference for storeOriginal Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/store-original/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOriginal'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function storeOriginal($settings_request_dto = null, string $contentType = self::contentTypes['storeOriginal'][0])
    {
        list($response) = $this->storeOriginalWithHttpInfo($settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation storeOriginalWithHttpInfo
     *
     * Change the ability to upload original formats
     *
     * REST API Reference for storeOriginal Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/store-original/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOriginal'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function storeOriginalWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['storeOriginal'][0])
    {
        $request = $this->storeOriginalRequest($settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation storeOriginalAsync
     *
     * Change the ability to upload original formats
     *
     * REST API Reference for storeOriginal Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/store-original/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOriginal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOriginalAsync($settings_request_dto = null, string $contentType = self::contentTypes['storeOriginal'][0])
    {
        return $this->storeOriginalAsyncWithHttpInfo($settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation storeOriginalAsyncWithHttpInfo
     *
     * Change the ability to upload original formats
     *
     * REST API Reference for storeOriginal Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/store-original/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOriginal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function storeOriginalAsyncWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['storeOriginal'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->storeOriginalRequest($settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'storeOriginal'
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['storeOriginal'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function storeOriginalRequest($settings_request_dto = null, string $contentType = self::contentTypes['storeOriginal'][0])
    {



        $resourcePath = '/api/2.0/files/storeoriginal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings_request_dto));
            } else {
                $httpBody = $settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateFileIfExist
     *
     * Update a file version if it exists
     *
     * REST API Reference for updateFileIfExist Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file-if-exist/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileIfExist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function updateFileIfExist($settings_request_dto = null, string $contentType = self::contentTypes['updateFileIfExist'][0])
    {
        list($response) = $this->updateFileIfExistWithHttpInfo($settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation updateFileIfExistWithHttpInfo
     *
     * Update a file version if it exists
     *
     * REST API Reference for updateFileIfExist Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file-if-exist/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileIfExist'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFileIfExistWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['updateFileIfExist'][0])
    {
        $request = $this->updateFileIfExistRequest($settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateFileIfExistAsync
     *
     * Update a file version if it exists
     *
     * REST API Reference for updateFileIfExist Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file-if-exist/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileIfExist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileIfExistAsync($settings_request_dto = null, string $contentType = self::contentTypes['updateFileIfExist'][0])
    {
        return $this->updateFileIfExistAsyncWithHttpInfo($settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFileIfExistAsyncWithHttpInfo
     *
     * Update a file version if it exists
     *
     * REST API Reference for updateFileIfExist Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-file-if-exist/
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileIfExist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFileIfExistAsyncWithHttpInfo($settings_request_dto = null, string $contentType = self::contentTypes['updateFileIfExist'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->updateFileIfExistRequest($settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateFileIfExist'
     *
     * @param  \OpenAPI\Client\Model\SettingsRequestDto|null $settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateFileIfExist'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFileIfExistRequest($settings_request_dto = null, string $contentType = self::contentTypes['updateFileIfExist'][0])
    {



        $resourcePath = '/api/2.0/files/updateifexist';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($settings_request_dto));
            } else {
                $httpBody = $settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
