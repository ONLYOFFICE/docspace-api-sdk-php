<?php
/*
 * (c) Copyright Ascensio System SIA 2025
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * onlyoffice/docspace-api-sdk
 *
 * A simple PHP SDK for integrating with the ONLYOFFICE DocSpace API
 *
 * The version of the OpenAPI document: 3.6.0
 * Contact: support@onlyoffice.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */


namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 *  Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class RoomsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'addRoomTags' => [
            'application/json',
        ],
        'archiveRoom' => [
            'application/json',
        ],
        'changeRoomCover' => [
            'application/json',
        ],
        'createRoom' => [
            'application/json',
        ],
        'createRoomFromTemplate' => [
            'application/json',
        ],
        'createRoomLogo' => [
            'application/json',
        ],
        'createRoomTag' => [
            'application/json',
        ],
        'createRoomTemplate' => [
            'application/json',
        ],
        'createRoomThirdParty' => [
            'application/json',
        ],
        'deleteCustomTags' => [
            'application/json',
        ],
        'deleteRoom' => [
            'application/json',
        ],
        'deleteRoomLogo' => [
            'application/json',
        ],
        'deleteRoomTags' => [
            'application/json',
        ],
        'getNewRoomItems' => [
            'application/json',
        ],
        'getPublicSettings' => [
            'application/json',
        ],
        'getRoomCovers' => [
            'application/json',
        ],
        'getRoomCreatingStatus' => [
            'application/json',
        ],
        'getRoomIndexExport' => [
            'application/json',
        ],
        'getRoomInfo' => [
            'application/json',
        ],
        'getRoomLinks' => [
            'application/json',
        ],
        'getRoomSecurityInfo' => [
            'application/json',
        ],
        'getRoomTagsInfo' => [
            'application/json',
        ],
        'getRoomTemplateCreatingStatus' => [
            'application/json',
        ],
        'getRoomsFolder' => [
            'application/json',
        ],
        'getRoomsNewItems' => [
            'application/json',
        ],
        'getRoomsPrimaryExternalLink' => [
            'application/json',
        ],
        'pinRoom' => [
            'application/json',
        ],
        'reorderRoom' => [
            'application/json',
        ],
        'resendEmailInvitations' => [
            'application/json',
        ],
        'setPublicSettings' => [
            'application/json',
        ],
        'setRoomLink' => [
            'application/json',
        ],
        'setRoomSecurity' => [
            'application/json',
        ],
        'startRoomIndexExport' => [
            'application/json',
        ],
        'terminateRoomIndexExport' => [
            'application/json',
        ],
        'unarchiveRoom' => [
            'application/json',
        ],
        'unpinRoom' => [
            'application/json',
        ],
        'updateRoom' => [
            'application/json',
        ],
        'uploadRoomLogo' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    private ?string $fields = null;

    public function withFields(string $fields): self
    {
        $this->fields = $fields;
        return $this;
    }

    /**
     * Operation addRoomTags
     *
     * Add the room tags
     *
     * REST API Reference for addRoomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-room-tags/
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addRoomTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function addRoomTags($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['addRoomTags'][0])
    {
        list($response) = $this->addRoomTagsWithHttpInfo($id, $batch_tags_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation addRoomTagsWithHttpInfo
     *
     * Add the room tags
     *
     * REST API Reference for addRoomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-room-tags/
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addRoomTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function addRoomTagsWithHttpInfo($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['addRoomTags'][0])
    {
        $request = $this->addRoomTagsRequest($id, $batch_tags_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation addRoomTagsAsync
     *
     * Add the room tags
     *
     * REST API Reference for addRoomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-room-tags/
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addRoomTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addRoomTagsAsync($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['addRoomTags'][0])
    {
        return $this->addRoomTagsAsyncWithHttpInfo($id, $batch_tags_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation addRoomTagsAsyncWithHttpInfo
     *
     * Add the room tags
     *
     * REST API Reference for addRoomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/add-room-tags/
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addRoomTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function addRoomTagsAsyncWithHttpInfo($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['addRoomTags'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->addRoomTagsRequest($id, $batch_tags_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'addRoomTags'
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['addRoomTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function addRoomTagsRequest($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['addRoomTags'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling addRoomTags'
            );
        }



        $resourcePath = '/api/2.0/files/rooms/{id}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_tags_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_tags_request_dto));
            } else {
                $httpBody = $batch_tags_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation archiveRoom
     *
     * Archive a room
     *
     * REST API Reference for archiveRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/archive-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationWrapper
     */
    public function archiveRoom($id, $archive_room_request = null, string $contentType = self::contentTypes['archiveRoom'][0])
    {
        list($response) = $this->archiveRoomWithHttpInfo($id, $archive_room_request, $contentType);
        return $response;
    }

    /**
     * Operation archiveRoomWithHttpInfo
     *
     * Archive a room
     *
     * REST API Reference for archiveRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/archive-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function archiveRoomWithHttpInfo($id, $archive_room_request = null, string $contentType = self::contentTypes['archiveRoom'][0])
    {
        $request = $this->archiveRoomRequest($id, $archive_room_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation archiveRoomAsync
     *
     * Archive a room
     *
     * REST API Reference for archiveRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/archive-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveRoomAsync($id, $archive_room_request = null, string $contentType = self::contentTypes['archiveRoom'][0])
    {
        return $this->archiveRoomAsyncWithHttpInfo($id, $archive_room_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation archiveRoomAsyncWithHttpInfo
     *
     * Archive a room
     *
     * REST API Reference for archiveRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/archive-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function archiveRoomAsyncWithHttpInfo($id, $archive_room_request = null, string $contentType = self::contentTypes['archiveRoom'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationWrapper';
        $request = $this->archiveRoomRequest($id, $archive_room_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'archiveRoom'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['archiveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function archiveRoomRequest($id, $archive_room_request = null, string $contentType = self::contentTypes['archiveRoom'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling archiveRoom'
            );
        }



        $resourcePath = '/api/2.0/files/rooms/{id}/archive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($archive_room_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($archive_room_request));
            } else {
                $httpBody = $archive_room_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation changeRoomCover
     *
     * Change the room cover
     *
     * REST API Reference for changeRoomCover Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-room-cover/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\CoverRequestDto $cover_request_dto The request parameters to change the room cover. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRoomCover'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function changeRoomCover($id, $cover_request_dto, string $contentType = self::contentTypes['changeRoomCover'][0])
    {
        list($response) = $this->changeRoomCoverWithHttpInfo($id, $cover_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation changeRoomCoverWithHttpInfo
     *
     * Change the room cover
     *
     * REST API Reference for changeRoomCover Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-room-cover/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\CoverRequestDto $cover_request_dto The request parameters to change the room cover. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRoomCover'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function changeRoomCoverWithHttpInfo($id, $cover_request_dto, string $contentType = self::contentTypes['changeRoomCover'][0])
    {
        $request = $this->changeRoomCoverRequest($id, $cover_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation changeRoomCoverAsync
     *
     * Change the room cover
     *
     * REST API Reference for changeRoomCover Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-room-cover/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\CoverRequestDto $cover_request_dto The request parameters to change the room cover. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRoomCover'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeRoomCoverAsync($id, $cover_request_dto, string $contentType = self::contentTypes['changeRoomCover'][0])
    {
        return $this->changeRoomCoverAsyncWithHttpInfo($id, $cover_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation changeRoomCoverAsyncWithHttpInfo
     *
     * Change the room cover
     *
     * REST API Reference for changeRoomCover Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/change-room-cover/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\CoverRequestDto $cover_request_dto The request parameters to change the room cover. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRoomCover'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function changeRoomCoverAsyncWithHttpInfo($id, $cover_request_dto, string $contentType = self::contentTypes['changeRoomCover'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->changeRoomCoverRequest($id, $cover_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'changeRoomCover'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\CoverRequestDto $cover_request_dto The request parameters to change the room cover. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['changeRoomCover'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function changeRoomCoverRequest($id, $cover_request_dto, string $contentType = self::contentTypes['changeRoomCover'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling changeRoomCover'
            );
        }

        // verify the required parameter 'cover_request_dto' is set
        if ($cover_request_dto === null || (is_array($cover_request_dto) && count($cover_request_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cover_request_dto when calling changeRoomCover'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/cover';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($cover_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cover_request_dto));
            } else {
                $httpBody = $cover_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRoom
     *
     * Create a room
     *
     * REST API Reference for createRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room/
     *
     * @param  \OpenAPI\Client\Model\CreateRoomRequestDto|null $create_room_request_dto create_room_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function createRoom($create_room_request_dto = null, string $contentType = self::contentTypes['createRoom'][0])
    {
        list($response) = $this->createRoomWithHttpInfo($create_room_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation createRoomWithHttpInfo
     *
     * Create a room
     *
     * REST API Reference for createRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room/
     *
     * @param  \OpenAPI\Client\Model\CreateRoomRequestDto|null $create_room_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRoomWithHttpInfo($create_room_request_dto = null, string $contentType = self::contentTypes['createRoom'][0])
    {
        $request = $this->createRoomRequest($create_room_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createRoomAsync
     *
     * Create a room
     *
     * REST API Reference for createRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room/
     *
     * @param  \OpenAPI\Client\Model\CreateRoomRequestDto|null $create_room_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomAsync($create_room_request_dto = null, string $contentType = self::contentTypes['createRoom'][0])
    {
        return $this->createRoomAsyncWithHttpInfo($create_room_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRoomAsyncWithHttpInfo
     *
     * Create a room
     *
     * REST API Reference for createRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room/
     *
     * @param  \OpenAPI\Client\Model\CreateRoomRequestDto|null $create_room_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomAsyncWithHttpInfo($create_room_request_dto = null, string $contentType = self::contentTypes['createRoom'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->createRoomRequest($create_room_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRoom'
     *
     * @param  \OpenAPI\Client\Model\CreateRoomRequestDto|null $create_room_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRoomRequest($create_room_request_dto = null, string $contentType = self::contentTypes['createRoom'][0])
    {



        $resourcePath = '/api/2.0/files/rooms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_room_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_room_request_dto));
            } else {
                $httpBody = $create_room_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRoomFromTemplate
     *
     * Create a room from the template
     *
     * REST API Reference for createRoomFromTemplate Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-from-template/
     *
     * @param  \OpenAPI\Client\Model\CreateRoomFromTemplateDto|null $create_room_from_template_dto create_room_from_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomFromTemplate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RoomFromTemplateStatusWrapper
     */
    public function createRoomFromTemplate($create_room_from_template_dto = null, string $contentType = self::contentTypes['createRoomFromTemplate'][0])
    {
        list($response) = $this->createRoomFromTemplateWithHttpInfo($create_room_from_template_dto, $contentType);
        return $response;
    }

    /**
     * Operation createRoomFromTemplateWithHttpInfo
     *
     * Create a room from the template
     *
     * REST API Reference for createRoomFromTemplate Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-from-template/
     *
     * @param  \OpenAPI\Client\Model\CreateRoomFromTemplateDto|null $create_room_from_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomFromTemplate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RoomFromTemplateStatusWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRoomFromTemplateWithHttpInfo($create_room_from_template_dto = null, string $contentType = self::contentTypes['createRoomFromTemplate'][0])
    {
        $request = $this->createRoomFromTemplateRequest($create_room_from_template_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RoomFromTemplateStatusWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\RoomFromTemplateStatusWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RoomFromTemplateStatusWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createRoomFromTemplateAsync
     *
     * Create a room from the template
     *
     * REST API Reference for createRoomFromTemplate Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-from-template/
     *
     * @param  \OpenAPI\Client\Model\CreateRoomFromTemplateDto|null $create_room_from_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomFromTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomFromTemplateAsync($create_room_from_template_dto = null, string $contentType = self::contentTypes['createRoomFromTemplate'][0])
    {
        return $this->createRoomFromTemplateAsyncWithHttpInfo($create_room_from_template_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRoomFromTemplateAsyncWithHttpInfo
     *
     * Create a room from the template
     *
     * REST API Reference for createRoomFromTemplate Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-from-template/
     *
     * @param  \OpenAPI\Client\Model\CreateRoomFromTemplateDto|null $create_room_from_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomFromTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomFromTemplateAsyncWithHttpInfo($create_room_from_template_dto = null, string $contentType = self::contentTypes['createRoomFromTemplate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RoomFromTemplateStatusWrapper';
        $request = $this->createRoomFromTemplateRequest($create_room_from_template_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRoomFromTemplate'
     *
     * @param  \OpenAPI\Client\Model\CreateRoomFromTemplateDto|null $create_room_from_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomFromTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRoomFromTemplateRequest($create_room_from_template_dto = null, string $contentType = self::contentTypes['createRoomFromTemplate'][0])
    {



        $resourcePath = '/api/2.0/files/rooms/fromtemplate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_room_from_template_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_room_from_template_dto));
            } else {
                $httpBody = $create_room_from_template_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRoomLogo
     *
     * Create a room logo
     *
     * REST API Reference for createRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-logo/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LogoRequest $logo_request The logo request parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomLogo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function createRoomLogo($id, $logo_request, string $contentType = self::contentTypes['createRoomLogo'][0])
    {
        list($response) = $this->createRoomLogoWithHttpInfo($id, $logo_request, $contentType);
        return $response;
    }

    /**
     * Operation createRoomLogoWithHttpInfo
     *
     * Create a room logo
     *
     * REST API Reference for createRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-logo/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LogoRequest $logo_request The logo request parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomLogo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRoomLogoWithHttpInfo($id, $logo_request, string $contentType = self::contentTypes['createRoomLogo'][0])
    {
        $request = $this->createRoomLogoRequest($id, $logo_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createRoomLogoAsync
     *
     * Create a room logo
     *
     * REST API Reference for createRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-logo/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LogoRequest $logo_request The logo request parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomLogoAsync($id, $logo_request, string $contentType = self::contentTypes['createRoomLogo'][0])
    {
        return $this->createRoomLogoAsyncWithHttpInfo($id, $logo_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRoomLogoAsyncWithHttpInfo
     *
     * Create a room logo
     *
     * REST API Reference for createRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-logo/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LogoRequest $logo_request The logo request parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomLogoAsyncWithHttpInfo($id, $logo_request, string $contentType = self::contentTypes['createRoomLogo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->createRoomLogoRequest($id, $logo_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRoomLogo'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LogoRequest $logo_request The logo request parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRoomLogoRequest($id, $logo_request, string $contentType = self::contentTypes['createRoomLogo'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createRoomLogo'
            );
        }

        // verify the required parameter 'logo_request' is set
        if ($logo_request === null || (is_array($logo_request) && count($logo_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $logo_request when calling createRoomLogo'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/logo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($logo_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($logo_request));
            } else {
                $httpBody = $logo_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRoomTag
     *
     * Create a room tag
     *
     * REST API Reference for createRoomTag Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-tag/
     *
     * @param  \OpenAPI\Client\Model\CreateTagRequestDto|null $create_tag_request_dto create_tag_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectWrapper
     */
    public function createRoomTag($create_tag_request_dto = null, string $contentType = self::contentTypes['createRoomTag'][0])
    {
        list($response) = $this->createRoomTagWithHttpInfo($create_tag_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation createRoomTagWithHttpInfo
     *
     * Create a room tag
     *
     * REST API Reference for createRoomTag Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-tag/
     *
     * @param  \OpenAPI\Client\Model\CreateTagRequestDto|null $create_tag_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTag'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRoomTagWithHttpInfo($create_tag_request_dto = null, string $contentType = self::contentTypes['createRoomTag'][0])
    {
        $request = $this->createRoomTagRequest($create_tag_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ObjectWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createRoomTagAsync
     *
     * Create a room tag
     *
     * REST API Reference for createRoomTag Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-tag/
     *
     * @param  \OpenAPI\Client\Model\CreateTagRequestDto|null $create_tag_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomTagAsync($create_tag_request_dto = null, string $contentType = self::contentTypes['createRoomTag'][0])
    {
        return $this->createRoomTagAsyncWithHttpInfo($create_tag_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRoomTagAsyncWithHttpInfo
     *
     * Create a room tag
     *
     * REST API Reference for createRoomTag Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-tag/
     *
     * @param  \OpenAPI\Client\Model\CreateTagRequestDto|null $create_tag_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomTagAsyncWithHttpInfo($create_tag_request_dto = null, string $contentType = self::contentTypes['createRoomTag'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectWrapper';
        $request = $this->createRoomTagRequest($create_tag_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRoomTag'
     *
     * @param  \OpenAPI\Client\Model\CreateTagRequestDto|null $create_tag_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTag'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRoomTagRequest($create_tag_request_dto = null, string $contentType = self::contentTypes['createRoomTag'][0])
    {



        $resourcePath = '/api/2.0/files/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_tag_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_tag_request_dto));
            } else {
                $httpBody = $create_tag_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRoomTemplate
     *
     * Start creating room template
     *
     * REST API Reference for createRoomTemplate Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-template/
     *
     * @param  \OpenAPI\Client\Model\RoomTemplateDto|null $room_template_dto room_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTemplate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RoomTemplateStatusWrapper
     */
    public function createRoomTemplate($room_template_dto = null, string $contentType = self::contentTypes['createRoomTemplate'][0])
    {
        list($response) = $this->createRoomTemplateWithHttpInfo($room_template_dto, $contentType);
        return $response;
    }

    /**
     * Operation createRoomTemplateWithHttpInfo
     *
     * Start creating room template
     *
     * REST API Reference for createRoomTemplate Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-template/
     *
     * @param  \OpenAPI\Client\Model\RoomTemplateDto|null $room_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTemplate'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RoomTemplateStatusWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRoomTemplateWithHttpInfo($room_template_dto = null, string $contentType = self::contentTypes['createRoomTemplate'][0])
    {
        $request = $this->createRoomTemplateRequest($room_template_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RoomTemplateStatusWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\RoomTemplateStatusWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RoomTemplateStatusWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createRoomTemplateAsync
     *
     * Start creating room template
     *
     * REST API Reference for createRoomTemplate Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-template/
     *
     * @param  \OpenAPI\Client\Model\RoomTemplateDto|null $room_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomTemplateAsync($room_template_dto = null, string $contentType = self::contentTypes['createRoomTemplate'][0])
    {
        return $this->createRoomTemplateAsyncWithHttpInfo($room_template_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRoomTemplateAsyncWithHttpInfo
     *
     * Start creating room template
     *
     * REST API Reference for createRoomTemplate Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-template/
     *
     * @param  \OpenAPI\Client\Model\RoomTemplateDto|null $room_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomTemplateAsyncWithHttpInfo($room_template_dto = null, string $contentType = self::contentTypes['createRoomTemplate'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RoomTemplateStatusWrapper';
        $request = $this->createRoomTemplateRequest($room_template_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRoomTemplate'
     *
     * @param  \OpenAPI\Client\Model\RoomTemplateDto|null $room_template_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomTemplate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRoomTemplateRequest($room_template_dto = null, string $contentType = self::contentTypes['createRoomTemplate'][0])
    {



        $resourcePath = '/api/2.0/files/roomtemplate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($room_template_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($room_template_dto));
            } else {
                $httpBody = $room_template_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createRoomThirdParty
     *
     * Create a third-party room
     *
     * REST API Reference for createRoomThirdParty Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-third-party/
     *
     * @param  string $id The ID of the folder in the third-party storage in which the contents of the room will be stored. (required)
     * @param  \OpenAPI\Client\Model\CreateThirdPartyRoom $create_third_party_room The third-party room information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomThirdParty'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderStringWrapper
     */
    public function createRoomThirdParty($id, $create_third_party_room, string $contentType = self::contentTypes['createRoomThirdParty'][0])
    {
        list($response) = $this->createRoomThirdPartyWithHttpInfo($id, $create_third_party_room, $contentType);
        return $response;
    }

    /**
     * Operation createRoomThirdPartyWithHttpInfo
     *
     * Create a third-party room
     *
     * REST API Reference for createRoomThirdParty Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-third-party/
     *
     * @param  string $id The ID of the folder in the third-party storage in which the contents of the room will be stored. (required)
     * @param  \OpenAPI\Client\Model\CreateThirdPartyRoom $create_third_party_room The third-party room information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomThirdParty'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderStringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRoomThirdPartyWithHttpInfo($id, $create_third_party_room, string $contentType = self::contentTypes['createRoomThirdParty'][0])
    {
        $request = $this->createRoomThirdPartyRequest($id, $create_third_party_room, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderStringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderStringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderStringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createRoomThirdPartyAsync
     *
     * Create a third-party room
     *
     * REST API Reference for createRoomThirdParty Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-third-party/
     *
     * @param  string $id The ID of the folder in the third-party storage in which the contents of the room will be stored. (required)
     * @param  \OpenAPI\Client\Model\CreateThirdPartyRoom $create_third_party_room The third-party room information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomThirdParty'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomThirdPartyAsync($id, $create_third_party_room, string $contentType = self::contentTypes['createRoomThirdParty'][0])
    {
        return $this->createRoomThirdPartyAsyncWithHttpInfo($id, $create_third_party_room, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRoomThirdPartyAsyncWithHttpInfo
     *
     * Create a third-party room
     *
     * REST API Reference for createRoomThirdParty Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/create-room-third-party/
     *
     * @param  string $id The ID of the folder in the third-party storage in which the contents of the room will be stored. (required)
     * @param  \OpenAPI\Client\Model\CreateThirdPartyRoom $create_third_party_room The third-party room information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomThirdParty'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRoomThirdPartyAsyncWithHttpInfo($id, $create_third_party_room, string $contentType = self::contentTypes['createRoomThirdParty'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderStringWrapper';
        $request = $this->createRoomThirdPartyRequest($id, $create_third_party_room, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRoomThirdParty'
     *
     * @param  string $id The ID of the folder in the third-party storage in which the contents of the room will be stored. (required)
     * @param  \OpenAPI\Client\Model\CreateThirdPartyRoom $create_third_party_room The third-party room information. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createRoomThirdParty'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRoomThirdPartyRequest($id, $create_third_party_room, string $contentType = self::contentTypes['createRoomThirdParty'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createRoomThirdParty'
            );
        }

        // verify the required parameter 'create_third_party_room' is set
        if ($create_third_party_room === null || (is_array($create_third_party_room) && count($create_third_party_room) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_third_party_room when calling createRoomThirdParty'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/thirdparty/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_third_party_room)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_third_party_room));
            } else {
                $httpBody = $create_third_party_room;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCustomTags
     *
     * Delete the custom room tags
     *
     * REST API Reference for deleteCustomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-custom-tags/
     *
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto batch_tags_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteCustomTags($batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteCustomTags'][0])
    {
        $this->deleteCustomTagsWithHttpInfo($batch_tags_request_dto, $contentType);
    }

    /**
     * Operation deleteCustomTagsWithHttpInfo
     *
     * Delete the custom room tags
     *
     * REST API Reference for deleteCustomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-custom-tags/
     *
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCustomTagsWithHttpInfo($batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteCustomTags'][0])
    {
        $request = $this->deleteCustomTagsRequest($batch_tags_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteCustomTagsAsync
     *
     * Delete the custom room tags
     *
     * REST API Reference for deleteCustomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-custom-tags/
     *
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomTagsAsync($batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteCustomTags'][0])
    {
        return $this->deleteCustomTagsAsyncWithHttpInfo($batch_tags_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCustomTagsAsyncWithHttpInfo
     *
     * Delete the custom room tags
     *
     * REST API Reference for deleteCustomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-custom-tags/
     *
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCustomTagsAsyncWithHttpInfo($batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteCustomTags'][0])
    {
        $returnType = '';
        $request = $this->deleteCustomTagsRequest($batch_tags_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCustomTags'
     *
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteCustomTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteCustomTagsRequest($batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteCustomTags'][0])
    {



        $resourcePath = '/api/2.0/files/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_tags_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_tags_request_dto));
            } else {
                $httpBody = $batch_tags_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRoom
     *
     * Remove a room
     *
     * REST API Reference for deleteRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\DeleteRoomRequest $delete_room_request The parameters for deleting a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationWrapper
     */
    public function deleteRoom($id, $delete_room_request, string $contentType = self::contentTypes['deleteRoom'][0])
    {
        list($response) = $this->deleteRoomWithHttpInfo($id, $delete_room_request, $contentType);
        return $response;
    }

    /**
     * Operation deleteRoomWithHttpInfo
     *
     * Remove a room
     *
     * REST API Reference for deleteRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\DeleteRoomRequest $delete_room_request The parameters for deleting a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRoomWithHttpInfo($id, $delete_room_request, string $contentType = self::contentTypes['deleteRoom'][0])
    {
        $request = $this->deleteRoomRequest($id, $delete_room_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRoomAsync
     *
     * Remove a room
     *
     * REST API Reference for deleteRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\DeleteRoomRequest $delete_room_request The parameters for deleting a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoomAsync($id, $delete_room_request, string $contentType = self::contentTypes['deleteRoom'][0])
    {
        return $this->deleteRoomAsyncWithHttpInfo($id, $delete_room_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRoomAsyncWithHttpInfo
     *
     * Remove a room
     *
     * REST API Reference for deleteRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\DeleteRoomRequest $delete_room_request The parameters for deleting a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoomAsyncWithHttpInfo($id, $delete_room_request, string $contentType = self::contentTypes['deleteRoom'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationWrapper';
        $request = $this->deleteRoomRequest($id, $delete_room_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRoom'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\DeleteRoomRequest $delete_room_request The parameters for deleting a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRoomRequest($id, $delete_room_request, string $contentType = self::contentTypes['deleteRoom'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRoom'
            );
        }

        // verify the required parameter 'delete_room_request' is set
        if ($delete_room_request === null || (is_array($delete_room_request) && count($delete_room_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $delete_room_request when calling deleteRoom'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($delete_room_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($delete_room_request));
            } else {
                $httpBody = $delete_room_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRoomLogo
     *
     * Remove a room logo
     *
     * REST API Reference for deleteRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room-logo/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomLogo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function deleteRoomLogo($id, string $contentType = self::contentTypes['deleteRoomLogo'][0])
    {
        list($response) = $this->deleteRoomLogoWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation deleteRoomLogoWithHttpInfo
     *
     * Remove a room logo
     *
     * REST API Reference for deleteRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room-logo/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomLogo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRoomLogoWithHttpInfo($id, string $contentType = self::contentTypes['deleteRoomLogo'][0])
    {
        $request = $this->deleteRoomLogoRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRoomLogoAsync
     *
     * Remove a room logo
     *
     * REST API Reference for deleteRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room-logo/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoomLogoAsync($id, string $contentType = self::contentTypes['deleteRoomLogo'][0])
    {
        return $this->deleteRoomLogoAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRoomLogoAsyncWithHttpInfo
     *
     * Remove a room logo
     *
     * REST API Reference for deleteRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room-logo/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoomLogoAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteRoomLogo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->deleteRoomLogoRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRoomLogo'
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRoomLogoRequest($id, string $contentType = self::contentTypes['deleteRoomLogo'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRoomLogo'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/logo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRoomTags
     *
     * Remove the room tags
     *
     * REST API Reference for deleteRoomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room-tags/
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function deleteRoomTags($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteRoomTags'][0])
    {
        list($response) = $this->deleteRoomTagsWithHttpInfo($id, $batch_tags_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation deleteRoomTagsWithHttpInfo
     *
     * Remove the room tags
     *
     * REST API Reference for deleteRoomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room-tags/
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomTags'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRoomTagsWithHttpInfo($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteRoomTags'][0])
    {
        $request = $this->deleteRoomTagsRequest($id, $batch_tags_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deleteRoomTagsAsync
     *
     * Remove the room tags
     *
     * REST API Reference for deleteRoomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room-tags/
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoomTagsAsync($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteRoomTags'][0])
    {
        return $this->deleteRoomTagsAsyncWithHttpInfo($id, $batch_tags_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRoomTagsAsyncWithHttpInfo
     *
     * Remove the room tags
     *
     * REST API Reference for deleteRoomTags Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-room-tags/
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRoomTagsAsyncWithHttpInfo($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteRoomTags'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->deleteRoomTagsRequest($id, $batch_tags_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRoomTags'
     *
     * @param  int $id The room Id. (required)
     * @param  \OpenAPI\Client\Model\BatchTagsRequestDto|null $batch_tags_request_dto The parameters for managing tags. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteRoomTags'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRoomTagsRequest($id, $batch_tags_request_dto = null, string $contentType = self::contentTypes['deleteRoomTags'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteRoomTags'
            );
        }



        $resourcePath = '/api/2.0/files/rooms/{id}/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_tags_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_tags_request_dto));
            } else {
                $httpBody = $batch_tags_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNewRoomItems
     *
     * Get the new room items
     *
     * REST API Reference for getNewRoomItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-new-room-items/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewRoomItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\NewItemsFileEntryBaseArrayWrapper
     */
    public function getNewRoomItems($id, string $contentType = self::contentTypes['getNewRoomItems'][0])
    {
        list($response) = $this->getNewRoomItemsWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getNewRoomItemsWithHttpInfo
     *
     * Get the new room items
     *
     * REST API Reference for getNewRoomItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-new-room-items/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewRoomItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\NewItemsFileEntryBaseArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNewRoomItemsWithHttpInfo($id, string $contentType = self::contentTypes['getNewRoomItems'][0])
    {
        $request = $this->getNewRoomItemsRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\NewItemsFileEntryBaseArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\NewItemsFileEntryBaseArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\NewItemsFileEntryBaseArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getNewRoomItemsAsync
     *
     * Get the new room items
     *
     * REST API Reference for getNewRoomItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-new-room-items/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewRoomItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewRoomItemsAsync($id, string $contentType = self::contentTypes['getNewRoomItems'][0])
    {
        return $this->getNewRoomItemsAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNewRoomItemsAsyncWithHttpInfo
     *
     * Get the new room items
     *
     * REST API Reference for getNewRoomItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-new-room-items/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewRoomItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNewRoomItemsAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getNewRoomItems'][0])
    {
        $returnType = '\OpenAPI\Client\Model\NewItemsFileEntryBaseArrayWrapper';
        $request = $this->getNewRoomItemsRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNewRoomItems'
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNewRoomItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNewRoomItemsRequest($id, string $contentType = self::contentTypes['getNewRoomItems'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getNewRoomItems'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/news';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPublicSettings
     *
     * Get public settings
     *
     * REST API Reference for getPublicSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-public-settings/
     *
     * @param  int $id The room template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BooleanWrapper
     */
    public function getPublicSettings($id, string $contentType = self::contentTypes['getPublicSettings'][0])
    {
        list($response) = $this->getPublicSettingsWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getPublicSettingsWithHttpInfo
     *
     * Get public settings
     *
     * REST API Reference for getPublicSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-public-settings/
     *
     * @param  int $id The room template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BooleanWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPublicSettingsWithHttpInfo($id, string $contentType = self::contentTypes['getPublicSettings'][0])
    {
        $request = $this->getPublicSettingsRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BooleanWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BooleanWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPublicSettingsAsync
     *
     * Get public settings
     *
     * REST API Reference for getPublicSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-public-settings/
     *
     * @param  int $id The room template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicSettingsAsync($id, string $contentType = self::contentTypes['getPublicSettings'][0])
    {
        return $this->getPublicSettingsAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPublicSettingsAsyncWithHttpInfo
     *
     * Get public settings
     *
     * REST API Reference for getPublicSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-public-settings/
     *
     * @param  int $id The room template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPublicSettingsAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getPublicSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BooleanWrapper';
        $request = $this->getPublicSettingsRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPublicSettings'
     *
     * @param  int $id The room template ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPublicSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPublicSettingsRequest($id, string $contentType = self::contentTypes['getPublicSettings'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getPublicSettings'
            );
        }


        $resourcePath = '/api/2.0/files/roomtemplate/{id}/public';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomCovers
     *
     * Get covers
     *
     * REST API Reference for getRoomCovers Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-covers/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCovers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CoversResultArrayWrapper
     */
    public function getRoomCovers(string $contentType = self::contentTypes['getRoomCovers'][0])
    {
        list($response) = $this->getRoomCoversWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRoomCoversWithHttpInfo
     *
     * Get covers
     *
     * REST API Reference for getRoomCovers Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-covers/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCovers'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CoversResultArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomCoversWithHttpInfo(string $contentType = self::contentTypes['getRoomCovers'][0])
    {
        $request = $this->getRoomCoversRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CoversResultArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CoversResultArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CoversResultArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomCoversAsync
     *
     * Get covers
     *
     * REST API Reference for getRoomCovers Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-covers/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCovers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomCoversAsync(string $contentType = self::contentTypes['getRoomCovers'][0])
    {
        return $this->getRoomCoversAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomCoversAsyncWithHttpInfo
     *
     * Get covers
     *
     * REST API Reference for getRoomCovers Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-covers/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCovers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomCoversAsyncWithHttpInfo(string $contentType = self::contentTypes['getRoomCovers'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CoversResultArrayWrapper';
        $request = $this->getRoomCoversRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomCovers'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCovers'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomCoversRequest(string $contentType = self::contentTypes['getRoomCovers'][0])
    {


        $resourcePath = '/api/2.0/files/rooms/covers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomCreatingStatus
     *
     * Get the room creation progress
     *
     * REST API Reference for getRoomCreatingStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-creating-status/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCreatingStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RoomFromTemplateStatusWrapper
     */
    public function getRoomCreatingStatus(string $contentType = self::contentTypes['getRoomCreatingStatus'][0])
    {
        list($response) = $this->getRoomCreatingStatusWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRoomCreatingStatusWithHttpInfo
     *
     * Get the room creation progress
     *
     * REST API Reference for getRoomCreatingStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-creating-status/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCreatingStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RoomFromTemplateStatusWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomCreatingStatusWithHttpInfo(string $contentType = self::contentTypes['getRoomCreatingStatus'][0])
    {
        $request = $this->getRoomCreatingStatusRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RoomFromTemplateStatusWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\RoomFromTemplateStatusWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RoomFromTemplateStatusWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomCreatingStatusAsync
     *
     * Get the room creation progress
     *
     * REST API Reference for getRoomCreatingStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-creating-status/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCreatingStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomCreatingStatusAsync(string $contentType = self::contentTypes['getRoomCreatingStatus'][0])
    {
        return $this->getRoomCreatingStatusAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomCreatingStatusAsyncWithHttpInfo
     *
     * Get the room creation progress
     *
     * REST API Reference for getRoomCreatingStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-creating-status/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCreatingStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomCreatingStatusAsyncWithHttpInfo(string $contentType = self::contentTypes['getRoomCreatingStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RoomFromTemplateStatusWrapper';
        $request = $this->getRoomCreatingStatusRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomCreatingStatus'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomCreatingStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomCreatingStatusRequest(string $contentType = self::contentTypes['getRoomCreatingStatus'][0])
    {


        $resourcePath = '/api/2.0/files/rooms/fromtemplate/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomIndexExport
     *
     * Get the room index export
     *
     * REST API Reference for getRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-index-export/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\DocumentBuilderTaskWrapper
     */
    public function getRoomIndexExport(string $contentType = self::contentTypes['getRoomIndexExport'][0])
    {
        list($response) = $this->getRoomIndexExportWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRoomIndexExportWithHttpInfo
     *
     * Get the room index export
     *
     * REST API Reference for getRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-index-export/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\DocumentBuilderTaskWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomIndexExportWithHttpInfo(string $contentType = self::contentTypes['getRoomIndexExport'][0])
    {
        $request = $this->getRoomIndexExportRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\DocumentBuilderTaskWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\DocumentBuilderTaskWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DocumentBuilderTaskWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomIndexExportAsync
     *
     * Get the room index export
     *
     * REST API Reference for getRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-index-export/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomIndexExportAsync(string $contentType = self::contentTypes['getRoomIndexExport'][0])
    {
        return $this->getRoomIndexExportAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomIndexExportAsyncWithHttpInfo
     *
     * Get the room index export
     *
     * REST API Reference for getRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-index-export/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomIndexExportAsyncWithHttpInfo(string $contentType = self::contentTypes['getRoomIndexExport'][0])
    {
        $returnType = '\OpenAPI\Client\Model\DocumentBuilderTaskWrapper';
        $request = $this->getRoomIndexExportRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomIndexExport'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomIndexExportRequest(string $contentType = self::contentTypes['getRoomIndexExport'][0])
    {


        $resourcePath = '/api/2.0/files/rooms/indexexport';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomInfo
     *
     * Get room information
     *
     * REST API Reference for getRoomInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-info/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function getRoomInfo($id, string $contentType = self::contentTypes['getRoomInfo'][0])
    {
        list($response) = $this->getRoomInfoWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getRoomInfoWithHttpInfo
     *
     * Get room information
     *
     * REST API Reference for getRoomInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-info/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomInfoWithHttpInfo($id, string $contentType = self::contentTypes['getRoomInfo'][0])
    {
        $request = $this->getRoomInfoRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomInfoAsync
     *
     * Get room information
     *
     * REST API Reference for getRoomInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-info/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomInfoAsync($id, string $contentType = self::contentTypes['getRoomInfo'][0])
    {
        return $this->getRoomInfoAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomInfoAsyncWithHttpInfo
     *
     * Get room information
     *
     * REST API Reference for getRoomInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-info/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomInfoAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getRoomInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->getRoomInfoRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomInfo'
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomInfoRequest($id, string $contentType = self::contentTypes['getRoomInfo'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRoomInfo'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomLinks
     *
     * Get the room links
     *
     * REST API Reference for getRoomLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-links/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LinkType|null $type The link type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomLinks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareArrayWrapper
     */
    public function getRoomLinks($id, $type = null, string $contentType = self::contentTypes['getRoomLinks'][0])
    {
        list($response) = $this->getRoomLinksWithHttpInfo($id, $type, $contentType);
        return $response;
    }

    /**
     * Operation getRoomLinksWithHttpInfo
     *
     * Get the room links
     *
     * REST API Reference for getRoomLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-links/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LinkType|null $type The link type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomLinks'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomLinksWithHttpInfo($id, $type = null, string $contentType = self::contentTypes['getRoomLinks'][0])
    {
        $request = $this->getRoomLinksRequest($id, $type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomLinksAsync
     *
     * Get the room links
     *
     * REST API Reference for getRoomLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-links/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LinkType|null $type The link type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomLinksAsync($id, $type = null, string $contentType = self::contentTypes['getRoomLinks'][0])
    {
        return $this->getRoomLinksAsyncWithHttpInfo($id, $type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomLinksAsyncWithHttpInfo
     *
     * Get the room links
     *
     * REST API Reference for getRoomLinks Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-links/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LinkType|null $type The link type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomLinksAsyncWithHttpInfo($id, $type = null, string $contentType = self::contentTypes['getRoomLinks'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareArrayWrapper';
        $request = $this->getRoomLinksRequest($id, $type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomLinks'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\LinkType|null $type The link type. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomLinks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomLinksRequest($id, $type = null, string $contentType = self::contentTypes['getRoomLinks'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRoomLinks'
            );
        }



        $resourcePath = '/api/2.0/files/rooms/{id}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'LinkType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomSecurityInfo
     *
     * Get the room access rights
     *
     * REST API Reference for getRoomSecurityInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-security-info/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ShareFilterType|null $filter_type The filter type of the access rights. (optional)
     * @param  int|null $count The number of items to be retrieved or processed. (optional)
     * @param  int|null $start_index The starting index of the items to retrieve in a paginated request. (optional)
     * @param  string|null $filter_value The text filter value used for filtering room security information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomSecurityInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareArrayWrapper
     */
    public function getRoomSecurityInfo($id, $filter_type = null, $count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomSecurityInfo'][0])
    {
        list($response) = $this->getRoomSecurityInfoWithHttpInfo($id, $filter_type, $count, $start_index, $filter_value, $contentType);
        return $response;
    }

    /**
     * Operation getRoomSecurityInfoWithHttpInfo
     *
     * Get the room access rights
     *
     * REST API Reference for getRoomSecurityInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-security-info/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ShareFilterType|null $filter_type The filter type of the access rights. (optional)
     * @param  int|null $count The number of items to be retrieved or processed. (optional)
     * @param  int|null $start_index The starting index of the items to retrieve in a paginated request. (optional)
     * @param  string|null $filter_value The text filter value used for filtering room security information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomSecurityInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomSecurityInfoWithHttpInfo($id, $filter_type = null, $count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomSecurityInfo'][0])
    {
        $request = $this->getRoomSecurityInfoRequest($id, $filter_type, $count, $start_index, $filter_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomSecurityInfoAsync
     *
     * Get the room access rights
     *
     * REST API Reference for getRoomSecurityInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-security-info/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ShareFilterType|null $filter_type The filter type of the access rights. (optional)
     * @param  int|null $count The number of items to be retrieved or processed. (optional)
     * @param  int|null $start_index The starting index of the items to retrieve in a paginated request. (optional)
     * @param  string|null $filter_value The text filter value used for filtering room security information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomSecurityInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomSecurityInfoAsync($id, $filter_type = null, $count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomSecurityInfo'][0])
    {
        return $this->getRoomSecurityInfoAsyncWithHttpInfo($id, $filter_type, $count, $start_index, $filter_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomSecurityInfoAsyncWithHttpInfo
     *
     * Get the room access rights
     *
     * REST API Reference for getRoomSecurityInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-security-info/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ShareFilterType|null $filter_type The filter type of the access rights. (optional)
     * @param  int|null $count The number of items to be retrieved or processed. (optional)
     * @param  int|null $start_index The starting index of the items to retrieve in a paginated request. (optional)
     * @param  string|null $filter_value The text filter value used for filtering room security information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomSecurityInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomSecurityInfoAsyncWithHttpInfo($id, $filter_type = null, $count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomSecurityInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareArrayWrapper';
        $request = $this->getRoomSecurityInfoRequest($id, $filter_type, $count, $start_index, $filter_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomSecurityInfo'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ShareFilterType|null $filter_type The filter type of the access rights. (optional)
     * @param  int|null $count The number of items to be retrieved or processed. (optional)
     * @param  int|null $start_index The starting index of the items to retrieve in a paginated request. (optional)
     * @param  string|null $filter_value The text filter value used for filtering room security information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomSecurityInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomSecurityInfoRequest($id, $filter_type = null, $count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomSecurityInfo'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRoomSecurityInfo'
            );
        }


        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling RoomsApi.getRoomSecurityInfo, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling RoomsApi.getRoomSecurityInfo, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/api/2.0/files/rooms/{id}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_type,
            'filterType', // param base name
            'ShareFilterType', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomTagsInfo
     *
     * Get the room tags
     *
     * REST API Reference for getRoomTagsInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-tags-info/
     *
     * @param  int|null $count Gets or sets the number of tag results to retrieve.  This property specifies the maximum amount of tag data to be included in the result set. (optional)
     * @param  int|null $start_index Represents the starting index from which the tags&#39; information will be retrieved.  This property is used to define the offset for pagination when retrieving a list of tags. It determines  the point in the data set from which the retrieval begins. (optional)
     * @param  string|null $filter_value Gets or sets the text value used for searching tags.  This property is typically used as a filter value when retrieving tag information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTagsInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectArrayWrapper
     */
    public function getRoomTagsInfo($count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomTagsInfo'][0])
    {
        list($response) = $this->getRoomTagsInfoWithHttpInfo($count, $start_index, $filter_value, $contentType);
        return $response;
    }

    /**
     * Operation getRoomTagsInfoWithHttpInfo
     *
     * Get the room tags
     *
     * REST API Reference for getRoomTagsInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-tags-info/
     *
     * @param  int|null $count Gets or sets the number of tag results to retrieve.  This property specifies the maximum amount of tag data to be included in the result set. (optional)
     * @param  int|null $start_index Represents the starting index from which the tags&#39; information will be retrieved.  This property is used to define the offset for pagination when retrieving a list of tags. It determines  the point in the data set from which the retrieval begins. (optional)
     * @param  string|null $filter_value Gets or sets the text value used for searching tags.  This property is typically used as a filter value when retrieving tag information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTagsInfo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomTagsInfoWithHttpInfo($count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomTagsInfo'][0])
    {
        $request = $this->getRoomTagsInfoRequest($count, $start_index, $filter_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ObjectArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ObjectArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomTagsInfoAsync
     *
     * Get the room tags
     *
     * REST API Reference for getRoomTagsInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-tags-info/
     *
     * @param  int|null $count Gets or sets the number of tag results to retrieve.  This property specifies the maximum amount of tag data to be included in the result set. (optional)
     * @param  int|null $start_index Represents the starting index from which the tags&#39; information will be retrieved.  This property is used to define the offset for pagination when retrieving a list of tags. It determines  the point in the data set from which the retrieval begins. (optional)
     * @param  string|null $filter_value Gets or sets the text value used for searching tags.  This property is typically used as a filter value when retrieving tag information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTagsInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomTagsInfoAsync($count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomTagsInfo'][0])
    {
        return $this->getRoomTagsInfoAsyncWithHttpInfo($count, $start_index, $filter_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomTagsInfoAsyncWithHttpInfo
     *
     * Get the room tags
     *
     * REST API Reference for getRoomTagsInfo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-tags-info/
     *
     * @param  int|null $count Gets or sets the number of tag results to retrieve.  This property specifies the maximum amount of tag data to be included in the result set. (optional)
     * @param  int|null $start_index Represents the starting index from which the tags&#39; information will be retrieved.  This property is used to define the offset for pagination when retrieving a list of tags. It determines  the point in the data set from which the retrieval begins. (optional)
     * @param  string|null $filter_value Gets or sets the text value used for searching tags.  This property is typically used as a filter value when retrieving tag information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTagsInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomTagsInfoAsyncWithHttpInfo($count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomTagsInfo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectArrayWrapper';
        $request = $this->getRoomTagsInfoRequest($count, $start_index, $filter_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomTagsInfo'
     *
     * @param  int|null $count Gets or sets the number of tag results to retrieve.  This property specifies the maximum amount of tag data to be included in the result set. (optional)
     * @param  int|null $start_index Represents the starting index from which the tags&#39; information will be retrieved.  This property is used to define the offset for pagination when retrieving a list of tags. It determines  the point in the data set from which the retrieval begins. (optional)
     * @param  string|null $filter_value Gets or sets the text value used for searching tags.  This property is typically used as a filter value when retrieving tag information. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTagsInfo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomTagsInfoRequest($count = null, $start_index = null, $filter_value = null, string $contentType = self::contentTypes['getRoomTagsInfo'][0])
    {

        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling RoomsApi.getRoomTagsInfo, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling RoomsApi.getRoomTagsInfo, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/api/2.0/files/tags';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        if ($this->fields !== null) {
            $headerParams['fields'] = $this->fields;
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomTemplateCreatingStatus
     *
     * Get status of room template creation
     *
     * REST API Reference for getRoomTemplateCreatingStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-template-creating-status/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTemplateCreatingStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RoomTemplateStatusWrapper
     */
    public function getRoomTemplateCreatingStatus(string $contentType = self::contentTypes['getRoomTemplateCreatingStatus'][0])
    {
        list($response) = $this->getRoomTemplateCreatingStatusWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRoomTemplateCreatingStatusWithHttpInfo
     *
     * Get status of room template creation
     *
     * REST API Reference for getRoomTemplateCreatingStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-template-creating-status/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTemplateCreatingStatus'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RoomTemplateStatusWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomTemplateCreatingStatusWithHttpInfo(string $contentType = self::contentTypes['getRoomTemplateCreatingStatus'][0])
    {
        $request = $this->getRoomTemplateCreatingStatusRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RoomTemplateStatusWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\RoomTemplateStatusWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RoomTemplateStatusWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomTemplateCreatingStatusAsync
     *
     * Get status of room template creation
     *
     * REST API Reference for getRoomTemplateCreatingStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-template-creating-status/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTemplateCreatingStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomTemplateCreatingStatusAsync(string $contentType = self::contentTypes['getRoomTemplateCreatingStatus'][0])
    {
        return $this->getRoomTemplateCreatingStatusAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomTemplateCreatingStatusAsyncWithHttpInfo
     *
     * Get status of room template creation
     *
     * REST API Reference for getRoomTemplateCreatingStatus Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-room-template-creating-status/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTemplateCreatingStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomTemplateCreatingStatusAsyncWithHttpInfo(string $contentType = self::contentTypes['getRoomTemplateCreatingStatus'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RoomTemplateStatusWrapper';
        $request = $this->getRoomTemplateCreatingStatusRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomTemplateCreatingStatus'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomTemplateCreatingStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomTemplateCreatingStatusRequest(string $contentType = self::contentTypes['getRoomTemplateCreatingStatus'][0])
    {


        $resourcePath = '/api/2.0/files/roomtemplate/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomsFolder
     *
     * Get rooms
     *
     * REST API Reference for getRoomsFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-folder/
     *
     * @param  \OpenAPI\Client\Model\RoomType[]|null $type The filter by room type. (optional)
     * @param  string|null $subject_id The filter by user ID. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The room search area (Active, Archive, Any, Recent by links). (optional)
     * @param  bool|null $without_tags Specifies whether to search by tags or not. (optional)
     * @param  string|null $tags The tags in the serialized format. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ProviderFilter|null $provider The filter by provider name (None, Box, DropBox, GoogleDrive, kDrive, OneDrive, SharePoint, WebDav, Yandex, Storage). (optional)
     * @param  \OpenAPI\Client\Model\SubjectFilter|null $subject_filter The filter by user (Owner - 0, Member - 1). (optional)
     * @param  \OpenAPI\Client\Model\QuotaFilter|null $quota_filter The filter by quota (All - 0, Default - 1, Custom - 2). (optional)
     * @param  \OpenAPI\Client\Model\StorageFilter|null $storage_filter The filter by storage (None - 0, Internal - 1, ThirdParty - 2). (optional)
     * @param  int|null $count Specifies the maximum number of items to retrieve. (optional)
     * @param  int|null $start_index The index from which to start retrieving the room content. (optional)
     * @param  string|null $sort_by Specifies the field by which the room content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text filter value used to refine search or query operations. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderContentIntegerWrapper
     */
    public function getRoomsFolder($type = null, $subject_id = null, $search_area = null, $without_tags = null, $tags = null, $exclude_subject = null, $provider = null, $subject_filter = null, $quota_filter = null, $storage_filter = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRoomsFolder'][0])
    {
        list($response) = $this->getRoomsFolderWithHttpInfo($type, $subject_id, $search_area, $without_tags, $tags, $exclude_subject, $provider, $subject_filter, $quota_filter, $storage_filter, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);
        return $response;
    }

    /**
     * Operation getRoomsFolderWithHttpInfo
     *
     * Get rooms
     *
     * REST API Reference for getRoomsFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-folder/
     *
     * @param  \OpenAPI\Client\Model\RoomType[]|null $type The filter by room type. (optional)
     * @param  string|null $subject_id The filter by user ID. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The room search area (Active, Archive, Any, Recent by links). (optional)
     * @param  bool|null $without_tags Specifies whether to search by tags or not. (optional)
     * @param  string|null $tags The tags in the serialized format. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ProviderFilter|null $provider The filter by provider name (None, Box, DropBox, GoogleDrive, kDrive, OneDrive, SharePoint, WebDav, Yandex, Storage). (optional)
     * @param  \OpenAPI\Client\Model\SubjectFilter|null $subject_filter The filter by user (Owner - 0, Member - 1). (optional)
     * @param  \OpenAPI\Client\Model\QuotaFilter|null $quota_filter The filter by quota (All - 0, Default - 1, Custom - 2). (optional)
     * @param  \OpenAPI\Client\Model\StorageFilter|null $storage_filter The filter by storage (None - 0, Internal - 1, ThirdParty - 2). (optional)
     * @param  int|null $count Specifies the maximum number of items to retrieve. (optional)
     * @param  int|null $start_index The index from which to start retrieving the room content. (optional)
     * @param  string|null $sort_by Specifies the field by which the room content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text filter value used to refine search or query operations. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsFolder'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderContentIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomsFolderWithHttpInfo($type = null, $subject_id = null, $search_area = null, $without_tags = null, $tags = null, $exclude_subject = null, $provider = null, $subject_filter = null, $quota_filter = null, $storage_filter = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRoomsFolder'][0])
    {
        $request = $this->getRoomsFolderRequest($type, $subject_id, $search_area, $without_tags, $tags, $exclude_subject, $provider, $subject_filter, $quota_filter, $storage_filter, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderContentIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomsFolderAsync
     *
     * Get rooms
     *
     * REST API Reference for getRoomsFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-folder/
     *
     * @param  \OpenAPI\Client\Model\RoomType[]|null $type The filter by room type. (optional)
     * @param  string|null $subject_id The filter by user ID. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The room search area (Active, Archive, Any, Recent by links). (optional)
     * @param  bool|null $without_tags Specifies whether to search by tags or not. (optional)
     * @param  string|null $tags The tags in the serialized format. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ProviderFilter|null $provider The filter by provider name (None, Box, DropBox, GoogleDrive, kDrive, OneDrive, SharePoint, WebDav, Yandex, Storage). (optional)
     * @param  \OpenAPI\Client\Model\SubjectFilter|null $subject_filter The filter by user (Owner - 0, Member - 1). (optional)
     * @param  \OpenAPI\Client\Model\QuotaFilter|null $quota_filter The filter by quota (All - 0, Default - 1, Custom - 2). (optional)
     * @param  \OpenAPI\Client\Model\StorageFilter|null $storage_filter The filter by storage (None - 0, Internal - 1, ThirdParty - 2). (optional)
     * @param  int|null $count Specifies the maximum number of items to retrieve. (optional)
     * @param  int|null $start_index The index from which to start retrieving the room content. (optional)
     * @param  string|null $sort_by Specifies the field by which the room content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text filter value used to refine search or query operations. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomsFolderAsync($type = null, $subject_id = null, $search_area = null, $without_tags = null, $tags = null, $exclude_subject = null, $provider = null, $subject_filter = null, $quota_filter = null, $storage_filter = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRoomsFolder'][0])
    {
        return $this->getRoomsFolderAsyncWithHttpInfo($type, $subject_id, $search_area, $without_tags, $tags, $exclude_subject, $provider, $subject_filter, $quota_filter, $storage_filter, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomsFolderAsyncWithHttpInfo
     *
     * Get rooms
     *
     * REST API Reference for getRoomsFolder Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-folder/
     *
     * @param  \OpenAPI\Client\Model\RoomType[]|null $type The filter by room type. (optional)
     * @param  string|null $subject_id The filter by user ID. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The room search area (Active, Archive, Any, Recent by links). (optional)
     * @param  bool|null $without_tags Specifies whether to search by tags or not. (optional)
     * @param  string|null $tags The tags in the serialized format. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ProviderFilter|null $provider The filter by provider name (None, Box, DropBox, GoogleDrive, kDrive, OneDrive, SharePoint, WebDav, Yandex, Storage). (optional)
     * @param  \OpenAPI\Client\Model\SubjectFilter|null $subject_filter The filter by user (Owner - 0, Member - 1). (optional)
     * @param  \OpenAPI\Client\Model\QuotaFilter|null $quota_filter The filter by quota (All - 0, Default - 1, Custom - 2). (optional)
     * @param  \OpenAPI\Client\Model\StorageFilter|null $storage_filter The filter by storage (None - 0, Internal - 1, ThirdParty - 2). (optional)
     * @param  int|null $count Specifies the maximum number of items to retrieve. (optional)
     * @param  int|null $start_index The index from which to start retrieving the room content. (optional)
     * @param  string|null $sort_by Specifies the field by which the room content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text filter value used to refine search or query operations. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomsFolderAsyncWithHttpInfo($type = null, $subject_id = null, $search_area = null, $without_tags = null, $tags = null, $exclude_subject = null, $provider = null, $subject_filter = null, $quota_filter = null, $storage_filter = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRoomsFolder'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderContentIntegerWrapper';
        $request = $this->getRoomsFolderRequest($type, $subject_id, $search_area, $without_tags, $tags, $exclude_subject, $provider, $subject_filter, $quota_filter, $storage_filter, $count, $start_index, $sort_by, $sort_order, $filter_value, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomsFolder'
     *
     * @param  \OpenAPI\Client\Model\RoomType[]|null $type The filter by room type. (optional)
     * @param  string|null $subject_id The filter by user ID. (optional)
     * @param  \OpenAPI\Client\Model\SearchArea|null $search_area The room search area (Active, Archive, Any, Recent by links). (optional)
     * @param  bool|null $without_tags Specifies whether to search by tags or not. (optional)
     * @param  string|null $tags The tags in the serialized format. (optional)
     * @param  bool|null $exclude_subject Specifies whether to exclude search by user or group ID. (optional)
     * @param  \OpenAPI\Client\Model\ProviderFilter|null $provider The filter by provider name (None, Box, DropBox, GoogleDrive, kDrive, OneDrive, SharePoint, WebDav, Yandex, Storage). (optional)
     * @param  \OpenAPI\Client\Model\SubjectFilter|null $subject_filter The filter by user (Owner - 0, Member - 1). (optional)
     * @param  \OpenAPI\Client\Model\QuotaFilter|null $quota_filter The filter by quota (All - 0, Default - 1, Custom - 2). (optional)
     * @param  \OpenAPI\Client\Model\StorageFilter|null $storage_filter The filter by storage (None - 0, Internal - 1, ThirdParty - 2). (optional)
     * @param  int|null $count Specifies the maximum number of items to retrieve. (optional)
     * @param  int|null $start_index The index from which to start retrieving the room content. (optional)
     * @param  string|null $sort_by Specifies the field by which the room content should be sorted. (optional)
     * @param  \OpenAPI\Client\Model\SortOrder|null $sort_order The order in which the results are sorted. (optional)
     * @param  string|null $filter_value The text filter value used to refine search or query operations. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsFolder'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomsFolderRequest($type = null, $subject_id = null, $search_area = null, $without_tags = null, $tags = null, $exclude_subject = null, $provider = null, $subject_filter = null, $quota_filter = null, $storage_filter = null, $count = null, $start_index = null, $sort_by = null, $sort_order = null, $filter_value = null, string $contentType = self::contentTypes['getRoomsFolder'][0])
    {











        if ($count !== null && $count > 100) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling RoomsApi.getRoomsFolder, must be smaller than or equal to 100.');
        }
        if ($count !== null && $count < 1) {
            throw new \InvalidArgumentException('invalid value for "$count" when calling RoomsApi.getRoomsFolder, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/api/2.0/files/rooms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'array', // openApiType
            'deepObject', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subject_id,
            'subjectId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_area,
            'searchArea', // param base name
            'SearchArea', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $without_tags,
            'withoutTags', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_subject,
            'excludeSubject', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider,
            'provider', // param base name
            'ProviderFilter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $subject_filter,
            'subjectFilter', // param base name
            'SubjectFilter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quota_filter,
            'quotaFilter', // param base name
            'QuotaFilter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $storage_filter,
            'storageFilter', // param base name
            'StorageFilter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $count,
            'count', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_index,
            'startIndex', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sortBy', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_order,
            'sortOrder', // param base name
            'SortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $filter_value,
            'filterValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        if ($this->fields !== null) {
            $headerParams['fields'] = $this->fields;
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomsNewItems
     *
     * Get the room new items
     *
     * REST API Reference for getRoomsNewItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-new-items/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsNewItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\NewItemsRoomNewItemsArrayWrapper
     */
    public function getRoomsNewItems(string $contentType = self::contentTypes['getRoomsNewItems'][0])
    {
        list($response) = $this->getRoomsNewItemsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getRoomsNewItemsWithHttpInfo
     *
     * Get the room new items
     *
     * REST API Reference for getRoomsNewItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-new-items/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsNewItems'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\NewItemsRoomNewItemsArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomsNewItemsWithHttpInfo(string $contentType = self::contentTypes['getRoomsNewItems'][0])
    {
        $request = $this->getRoomsNewItemsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\NewItemsRoomNewItemsArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\NewItemsRoomNewItemsArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\NewItemsRoomNewItemsArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomsNewItemsAsync
     *
     * Get the room new items
     *
     * REST API Reference for getRoomsNewItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-new-items/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsNewItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomsNewItemsAsync(string $contentType = self::contentTypes['getRoomsNewItems'][0])
    {
        return $this->getRoomsNewItemsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomsNewItemsAsyncWithHttpInfo
     *
     * Get the room new items
     *
     * REST API Reference for getRoomsNewItems Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-new-items/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsNewItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomsNewItemsAsyncWithHttpInfo(string $contentType = self::contentTypes['getRoomsNewItems'][0])
    {
        $returnType = '\OpenAPI\Client\Model\NewItemsRoomNewItemsArrayWrapper';
        $request = $this->getRoomsNewItemsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomsNewItems'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsNewItems'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomsNewItemsRequest(string $contentType = self::contentTypes['getRoomsNewItems'][0])
    {


        $resourcePath = '/api/2.0/files/rooms/news';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoomsPrimaryExternalLink
     *
     * Get the room primary external link
     *
     * REST API Reference for getRoomsPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-primary-external-link/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareWrapper
     */
    public function getRoomsPrimaryExternalLink($id, string $contentType = self::contentTypes['getRoomsPrimaryExternalLink'][0])
    {
        list($response) = $this->getRoomsPrimaryExternalLinkWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getRoomsPrimaryExternalLinkWithHttpInfo
     *
     * Get the room primary external link
     *
     * REST API Reference for getRoomsPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-primary-external-link/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoomsPrimaryExternalLinkWithHttpInfo($id, string $contentType = self::contentTypes['getRoomsPrimaryExternalLink'][0])
    {
        $request = $this->getRoomsPrimaryExternalLinkRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getRoomsPrimaryExternalLinkAsync
     *
     * Get the room primary external link
     *
     * REST API Reference for getRoomsPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-primary-external-link/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomsPrimaryExternalLinkAsync($id, string $contentType = self::contentTypes['getRoomsPrimaryExternalLink'][0])
    {
        return $this->getRoomsPrimaryExternalLinkAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoomsPrimaryExternalLinkAsyncWithHttpInfo
     *
     * Get the room primary external link
     *
     * REST API Reference for getRoomsPrimaryExternalLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-rooms-primary-external-link/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoomsPrimaryExternalLinkAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getRoomsPrimaryExternalLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareWrapper';
        $request = $this->getRoomsPrimaryExternalLinkRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoomsPrimaryExternalLink'
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getRoomsPrimaryExternalLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRoomsPrimaryExternalLinkRequest($id, string $contentType = self::contentTypes['getRoomsPrimaryExternalLink'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRoomsPrimaryExternalLink'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/link';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pinRoom
     *
     * Pin a room
     *
     * REST API Reference for pinRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/pin-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function pinRoom($id, string $contentType = self::contentTypes['pinRoom'][0])
    {
        list($response) = $this->pinRoomWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation pinRoomWithHttpInfo
     *
     * Pin a room
     *
     * REST API Reference for pinRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/pin-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function pinRoomWithHttpInfo($id, string $contentType = self::contentTypes['pinRoom'][0])
    {
        $request = $this->pinRoomRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation pinRoomAsync
     *
     * Pin a room
     *
     * REST API Reference for pinRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/pin-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinRoomAsync($id, string $contentType = self::contentTypes['pinRoom'][0])
    {
        return $this->pinRoomAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pinRoomAsyncWithHttpInfo
     *
     * Pin a room
     *
     * REST API Reference for pinRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/pin-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinRoomAsyncWithHttpInfo($id, string $contentType = self::contentTypes['pinRoom'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->pinRoomRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pinRoom'
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pinRoomRequest($id, string $contentType = self::contentTypes['pinRoom'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling pinRoom'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/pin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation reorderRoom
     *
     * Reorder the room
     *
     * REST API Reference for reorderRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/reorder-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reorderRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function reorderRoom($id, string $contentType = self::contentTypes['reorderRoom'][0])
    {
        list($response) = $this->reorderRoomWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation reorderRoomWithHttpInfo
     *
     * Reorder the room
     *
     * REST API Reference for reorderRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/reorder-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reorderRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function reorderRoomWithHttpInfo($id, string $contentType = self::contentTypes['reorderRoom'][0])
    {
        $request = $this->reorderRoomRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation reorderRoomAsync
     *
     * Reorder the room
     *
     * REST API Reference for reorderRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/reorder-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reorderRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reorderRoomAsync($id, string $contentType = self::contentTypes['reorderRoom'][0])
    {
        return $this->reorderRoomAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation reorderRoomAsyncWithHttpInfo
     *
     * Reorder the room
     *
     * REST API Reference for reorderRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/reorder-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reorderRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function reorderRoomAsyncWithHttpInfo($id, string $contentType = self::contentTypes['reorderRoom'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->reorderRoomRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'reorderRoom'
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['reorderRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function reorderRoomRequest($id, string $contentType = self::contentTypes['reorderRoom'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling reorderRoom'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/reorder';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resendEmailInvitations
     *
     * Resend the room invitations
     *
     * REST API Reference for resendEmailInvitations Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/resend-email-invitations/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UserInvitation $user_invitation The user invitation parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendEmailInvitations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resendEmailInvitations($id, $user_invitation, string $contentType = self::contentTypes['resendEmailInvitations'][0])
    {
        $this->resendEmailInvitationsWithHttpInfo($id, $user_invitation, $contentType);
    }

    /**
     * Operation resendEmailInvitationsWithHttpInfo
     *
     * Resend the room invitations
     *
     * REST API Reference for resendEmailInvitations Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/resend-email-invitations/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UserInvitation $user_invitation The user invitation parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendEmailInvitations'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resendEmailInvitationsWithHttpInfo($id, $user_invitation, string $contentType = self::contentTypes['resendEmailInvitations'][0])
    {
        $request = $this->resendEmailInvitationsRequest($id, $user_invitation, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation resendEmailInvitationsAsync
     *
     * Resend the room invitations
     *
     * REST API Reference for resendEmailInvitations Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/resend-email-invitations/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UserInvitation $user_invitation The user invitation parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendEmailInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resendEmailInvitationsAsync($id, $user_invitation, string $contentType = self::contentTypes['resendEmailInvitations'][0])
    {
        return $this->resendEmailInvitationsAsyncWithHttpInfo($id, $user_invitation, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resendEmailInvitationsAsyncWithHttpInfo
     *
     * Resend the room invitations
     *
     * REST API Reference for resendEmailInvitations Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/resend-email-invitations/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UserInvitation $user_invitation The user invitation parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendEmailInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resendEmailInvitationsAsyncWithHttpInfo($id, $user_invitation, string $contentType = self::contentTypes['resendEmailInvitations'][0])
    {
        $returnType = '';
        $request = $this->resendEmailInvitationsRequest($id, $user_invitation, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resendEmailInvitations'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UserInvitation $user_invitation The user invitation parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['resendEmailInvitations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function resendEmailInvitationsRequest($id, $user_invitation, string $contentType = self::contentTypes['resendEmailInvitations'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling resendEmailInvitations'
            );
        }

        // verify the required parameter 'user_invitation' is set
        if ($user_invitation === null || (is_array($user_invitation) && count($user_invitation) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user_invitation when calling resendEmailInvitations'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/resend';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user_invitation)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user_invitation));
            } else {
                $httpBody = $user_invitation;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setPublicSettings
     *
     * Set public settings
     *
     * REST API Reference for setPublicSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-public-settings/
     *
     * @param  \OpenAPI\Client\Model\SetPublicDto|null $set_public_dto set_public_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPublicSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setPublicSettings($set_public_dto = null, string $contentType = self::contentTypes['setPublicSettings'][0])
    {
        $this->setPublicSettingsWithHttpInfo($set_public_dto, $contentType);
    }

    /**
     * Operation setPublicSettingsWithHttpInfo
     *
     * Set public settings
     *
     * REST API Reference for setPublicSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-public-settings/
     *
     * @param  \OpenAPI\Client\Model\SetPublicDto|null $set_public_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPublicSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setPublicSettingsWithHttpInfo($set_public_dto = null, string $contentType = self::contentTypes['setPublicSettings'][0])
    {
        $request = $this->setPublicSettingsRequest($set_public_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation setPublicSettingsAsync
     *
     * Set public settings
     *
     * REST API Reference for setPublicSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-public-settings/
     *
     * @param  \OpenAPI\Client\Model\SetPublicDto|null $set_public_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPublicSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPublicSettingsAsync($set_public_dto = null, string $contentType = self::contentTypes['setPublicSettings'][0])
    {
        return $this->setPublicSettingsAsyncWithHttpInfo($set_public_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setPublicSettingsAsyncWithHttpInfo
     *
     * Set public settings
     *
     * REST API Reference for setPublicSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-public-settings/
     *
     * @param  \OpenAPI\Client\Model\SetPublicDto|null $set_public_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPublicSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setPublicSettingsAsyncWithHttpInfo($set_public_dto = null, string $contentType = self::contentTypes['setPublicSettings'][0])
    {
        $returnType = '';
        $request = $this->setPublicSettingsRequest($set_public_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setPublicSettings'
     *
     * @param  \OpenAPI\Client\Model\SetPublicDto|null $set_public_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setPublicSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setPublicSettingsRequest($set_public_dto = null, string $contentType = self::contentTypes['setPublicSettings'][0])
    {



        $resourcePath = '/api/2.0/files/roomtemplate/public';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($set_public_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($set_public_dto));
            } else {
                $httpBody = $set_public_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setRoomLink
     *
     * Set the room external or invitation link
     *
     * REST API Reference for setRoomLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-room-link/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomLinkRequest $room_link_request The room link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileShareWrapper
     */
    public function setRoomLink($id, $room_link_request, string $contentType = self::contentTypes['setRoomLink'][0])
    {
        list($response) = $this->setRoomLinkWithHttpInfo($id, $room_link_request, $contentType);
        return $response;
    }

    /**
     * Operation setRoomLinkWithHttpInfo
     *
     * Set the room external or invitation link
     *
     * REST API Reference for setRoomLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-room-link/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomLinkRequest $room_link_request The room link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileShareWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRoomLinkWithHttpInfo($id, $room_link_request, string $contentType = self::contentTypes['setRoomLink'][0])
    {
        $request = $this->setRoomLinkRequest($id, $room_link_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileShareWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileShareWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setRoomLinkAsync
     *
     * Set the room external or invitation link
     *
     * REST API Reference for setRoomLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-room-link/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomLinkRequest $room_link_request The room link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRoomLinkAsync($id, $room_link_request, string $contentType = self::contentTypes['setRoomLink'][0])
    {
        return $this->setRoomLinkAsyncWithHttpInfo($id, $room_link_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setRoomLinkAsyncWithHttpInfo
     *
     * Set the room external or invitation link
     *
     * REST API Reference for setRoomLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-room-link/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomLinkRequest $room_link_request The room link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRoomLinkAsyncWithHttpInfo($id, $room_link_request, string $contentType = self::contentTypes['setRoomLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileShareWrapper';
        $request = $this->setRoomLinkRequest($id, $room_link_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setRoomLink'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomLinkRequest $room_link_request The room link parameters. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setRoomLinkRequest($id, $room_link_request, string $contentType = self::contentTypes['setRoomLink'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setRoomLink'
            );
        }

        // verify the required parameter 'room_link_request' is set
        if ($room_link_request === null || (is_array($room_link_request) && count($room_link_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_link_request when calling setRoomLink'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/links';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($room_link_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($room_link_request));
            } else {
                $httpBody = $room_link_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setRoomSecurity
     *
     * Set the room access rights
     *
     * REST API Reference for setRoomSecurity Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-room-security/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomInvitationRequest $room_invitation_request The room invitation request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomSecurity'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\RoomSecurityWrapper
     */
    public function setRoomSecurity($id, $room_invitation_request, string $contentType = self::contentTypes['setRoomSecurity'][0])
    {
        list($response) = $this->setRoomSecurityWithHttpInfo($id, $room_invitation_request, $contentType);
        return $response;
    }

    /**
     * Operation setRoomSecurityWithHttpInfo
     *
     * Set the room access rights
     *
     * REST API Reference for setRoomSecurity Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-room-security/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomInvitationRequest $room_invitation_request The room invitation request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomSecurity'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\RoomSecurityWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRoomSecurityWithHttpInfo($id, $room_invitation_request, string $contentType = self::contentTypes['setRoomSecurity'][0])
    {
        $request = $this->setRoomSecurityRequest($id, $room_invitation_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\RoomSecurityWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\RoomSecurityWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\RoomSecurityWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation setRoomSecurityAsync
     *
     * Set the room access rights
     *
     * REST API Reference for setRoomSecurity Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-room-security/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomInvitationRequest $room_invitation_request The room invitation request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomSecurity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRoomSecurityAsync($id, $room_invitation_request, string $contentType = self::contentTypes['setRoomSecurity'][0])
    {
        return $this->setRoomSecurityAsyncWithHttpInfo($id, $room_invitation_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setRoomSecurityAsyncWithHttpInfo
     *
     * Set the room access rights
     *
     * REST API Reference for setRoomSecurity Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/set-room-security/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomInvitationRequest $room_invitation_request The room invitation request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomSecurity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setRoomSecurityAsyncWithHttpInfo($id, $room_invitation_request, string $contentType = self::contentTypes['setRoomSecurity'][0])
    {
        $returnType = '\OpenAPI\Client\Model\RoomSecurityWrapper';
        $request = $this->setRoomSecurityRequest($id, $room_invitation_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setRoomSecurity'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\RoomInvitationRequest $room_invitation_request The room invitation request. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['setRoomSecurity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function setRoomSecurityRequest($id, $room_invitation_request, string $contentType = self::contentTypes['setRoomSecurity'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setRoomSecurity'
            );
        }

        // verify the required parameter 'room_invitation_request' is set
        if ($room_invitation_request === null || (is_array($room_invitation_request) && count($room_invitation_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $room_invitation_request when calling setRoomSecurity'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/share';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($room_invitation_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($room_invitation_request));
            } else {
                $httpBody = $room_invitation_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startRoomIndexExport
     *
     * Start the room index export
     *
     * REST API Reference for startRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-room-index-export/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\DocumentBuilderTaskWrapper
     */
    public function startRoomIndexExport($id, string $contentType = self::contentTypes['startRoomIndexExport'][0])
    {
        list($response) = $this->startRoomIndexExportWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation startRoomIndexExportWithHttpInfo
     *
     * Start the room index export
     *
     * REST API Reference for startRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-room-index-export/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\DocumentBuilderTaskWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function startRoomIndexExportWithHttpInfo($id, string $contentType = self::contentTypes['startRoomIndexExport'][0])
    {
        $request = $this->startRoomIndexExportRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\DocumentBuilderTaskWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\DocumentBuilderTaskWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DocumentBuilderTaskWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation startRoomIndexExportAsync
     *
     * Start the room index export
     *
     * REST API Reference for startRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-room-index-export/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startRoomIndexExportAsync($id, string $contentType = self::contentTypes['startRoomIndexExport'][0])
    {
        return $this->startRoomIndexExportAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startRoomIndexExportAsyncWithHttpInfo
     *
     * Start the room index export
     *
     * REST API Reference for startRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/start-room-index-export/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startRoomIndexExportAsyncWithHttpInfo($id, string $contentType = self::contentTypes['startRoomIndexExport'][0])
    {
        $returnType = '\OpenAPI\Client\Model\DocumentBuilderTaskWrapper';
        $request = $this->startRoomIndexExportRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startRoomIndexExport'
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['startRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function startRoomIndexExportRequest($id, string $contentType = self::contentTypes['startRoomIndexExport'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling startRoomIndexExport'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/indexexport';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation terminateRoomIndexExport
     *
     * Terminate the room index export
     *
     * REST API Reference for terminateRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/terminate-room-index-export/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function terminateRoomIndexExport(string $contentType = self::contentTypes['terminateRoomIndexExport'][0])
    {
        $this->terminateRoomIndexExportWithHttpInfo($contentType);
    }

    /**
     * Operation terminateRoomIndexExportWithHttpInfo
     *
     * Terminate the room index export
     *
     * REST API Reference for terminateRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/terminate-room-index-export/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function terminateRoomIndexExportWithHttpInfo(string $contentType = self::contentTypes['terminateRoomIndexExport'][0])
    {
        $request = $this->terminateRoomIndexExportRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation terminateRoomIndexExportAsync
     *
     * Terminate the room index export
     *
     * REST API Reference for terminateRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/terminate-room-index-export/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function terminateRoomIndexExportAsync(string $contentType = self::contentTypes['terminateRoomIndexExport'][0])
    {
        return $this->terminateRoomIndexExportAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation terminateRoomIndexExportAsyncWithHttpInfo
     *
     * Terminate the room index export
     *
     * REST API Reference for terminateRoomIndexExport Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/terminate-room-index-export/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function terminateRoomIndexExportAsyncWithHttpInfo(string $contentType = self::contentTypes['terminateRoomIndexExport'][0])
    {
        $returnType = '';
        $request = $this->terminateRoomIndexExportRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'terminateRoomIndexExport'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['terminateRoomIndexExport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function terminateRoomIndexExportRequest(string $contentType = self::contentTypes['terminateRoomIndexExport'][0])
    {


        $resourcePath = '/api/2.0/files/rooms/indexexport';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unarchiveRoom
     *
     * Unarchive a room
     *
     * REST API Reference for unarchiveRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/unarchive-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unarchiveRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FileOperationWrapper
     */
    public function unarchiveRoom($id, $archive_room_request = null, string $contentType = self::contentTypes['unarchiveRoom'][0])
    {
        list($response) = $this->unarchiveRoomWithHttpInfo($id, $archive_room_request, $contentType);
        return $response;
    }

    /**
     * Operation unarchiveRoomWithHttpInfo
     *
     * Unarchive a room
     *
     * REST API Reference for unarchiveRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/unarchive-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unarchiveRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FileOperationWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function unarchiveRoomWithHttpInfo($id, $archive_room_request = null, string $contentType = self::contentTypes['unarchiveRoom'][0])
    {
        $request = $this->unarchiveRoomRequest($id, $archive_room_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FileOperationWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FileOperationWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FileOperationWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation unarchiveRoomAsync
     *
     * Unarchive a room
     *
     * REST API Reference for unarchiveRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/unarchive-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unarchiveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unarchiveRoomAsync($id, $archive_room_request = null, string $contentType = self::contentTypes['unarchiveRoom'][0])
    {
        return $this->unarchiveRoomAsyncWithHttpInfo($id, $archive_room_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unarchiveRoomAsyncWithHttpInfo
     *
     * Unarchive a room
     *
     * REST API Reference for unarchiveRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/unarchive-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unarchiveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unarchiveRoomAsyncWithHttpInfo($id, $archive_room_request = null, string $contentType = self::contentTypes['unarchiveRoom'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FileOperationWrapper';
        $request = $this->unarchiveRoomRequest($id, $archive_room_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unarchiveRoom'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\ArchiveRoomRequest|null $archive_room_request The parameters for archiving a room. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unarchiveRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unarchiveRoomRequest($id, $archive_room_request = null, string $contentType = self::contentTypes['unarchiveRoom'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling unarchiveRoom'
            );
        }



        $resourcePath = '/api/2.0/files/rooms/{id}/unarchive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($archive_room_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($archive_room_request));
            } else {
                $httpBody = $archive_room_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unpinRoom
     *
     * Unpin a room
     *
     * REST API Reference for unpinRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/unpin-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function unpinRoom($id, string $contentType = self::contentTypes['unpinRoom'][0])
    {
        list($response) = $this->unpinRoomWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation unpinRoomWithHttpInfo
     *
     * Unpin a room
     *
     * REST API Reference for unpinRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/unpin-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function unpinRoomWithHttpInfo($id, string $contentType = self::contentTypes['unpinRoom'][0])
    {
        $request = $this->unpinRoomRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation unpinRoomAsync
     *
     * Unpin a room
     *
     * REST API Reference for unpinRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/unpin-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unpinRoomAsync($id, string $contentType = self::contentTypes['unpinRoom'][0])
    {
        return $this->unpinRoomAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unpinRoomAsyncWithHttpInfo
     *
     * Unpin a room
     *
     * REST API Reference for unpinRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/unpin-room/
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unpinRoomAsyncWithHttpInfo($id, string $contentType = self::contentTypes['unpinRoom'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->unpinRoomRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unpinRoom'
     *
     * @param  int $id The room ID. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpinRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unpinRoomRequest($id, string $contentType = self::contentTypes['unpinRoom'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling unpinRoom'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}/unpin';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateRoom
     *
     * Update a room
     *
     * REST API Reference for updateRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateRoomRequest $update_room_request The request parameters for updating a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FolderIntegerWrapper
     */
    public function updateRoom($id, $update_room_request, string $contentType = self::contentTypes['updateRoom'][0])
    {
        list($response) = $this->updateRoomWithHttpInfo($id, $update_room_request, $contentType);
        return $response;
    }

    /**
     * Operation updateRoomWithHttpInfo
     *
     * Update a room
     *
     * REST API Reference for updateRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateRoomRequest $update_room_request The request parameters for updating a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRoom'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FolderIntegerWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRoomWithHttpInfo($id, $update_room_request, string $contentType = self::contentTypes['updateRoom'][0])
    {
        $request = $this->updateRoomRequest($id, $update_room_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\FolderIntegerWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FolderIntegerWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateRoomAsync
     *
     * Update a room
     *
     * REST API Reference for updateRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateRoomRequest $update_room_request The request parameters for updating a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRoomAsync($id, $update_room_request, string $contentType = self::contentTypes['updateRoom'][0])
    {
        return $this->updateRoomAsyncWithHttpInfo($id, $update_room_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateRoomAsyncWithHttpInfo
     *
     * Update a room
     *
     * REST API Reference for updateRoom Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-room/
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateRoomRequest $update_room_request The request parameters for updating a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRoomAsyncWithHttpInfo($id, $update_room_request, string $contentType = self::contentTypes['updateRoom'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FolderIntegerWrapper';
        $request = $this->updateRoomRequest($id, $update_room_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateRoom'
     *
     * @param  int $id The room ID. (required)
     * @param  \OpenAPI\Client\Model\UpdateRoomRequest $update_room_request The request parameters for updating a room. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateRoom'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateRoomRequest($id, $update_room_request, string $contentType = self::contentTypes['updateRoom'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateRoom'
            );
        }

        // verify the required parameter 'update_room_request' is set
        if ($update_room_request === null || (is_array($update_room_request) && count($update_room_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_room_request when calling updateRoom'
            );
        }


        $resourcePath = '/api/2.0/files/rooms/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_room_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_room_request));
            } else {
                $httpBody = $update_room_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadRoomLogo
     *
     * Upload a room logo image
     *
     * REST API Reference for uploadRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-room-logo/
     *
     * @param  \OpenAPI\Client\Model\KeyValuePairStringStringValues[]|null $form_collection The image data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadRoomLogo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\UploadResultWrapper
     */
    public function uploadRoomLogo($form_collection = null, string $contentType = self::contentTypes['uploadRoomLogo'][0])
    {
        list($response) = $this->uploadRoomLogoWithHttpInfo($form_collection, $contentType);
        return $response;
    }

    /**
     * Operation uploadRoomLogoWithHttpInfo
     *
     * Upload a room logo image
     *
     * REST API Reference for uploadRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-room-logo/
     *
     * @param  \OpenAPI\Client\Model\KeyValuePairStringStringValues[]|null $form_collection The image data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadRoomLogo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\UploadResultWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadRoomLogoWithHttpInfo($form_collection = null, string $contentType = self::contentTypes['uploadRoomLogo'][0])
    {
        $request = $this->uploadRoomLogoRequest($form_collection, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\UploadResultWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\UploadResultWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\UploadResultWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadRoomLogoAsync
     *
     * Upload a room logo image
     *
     * REST API Reference for uploadRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-room-logo/
     *
     * @param  \OpenAPI\Client\Model\KeyValuePairStringStringValues[]|null $form_collection The image data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadRoomLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadRoomLogoAsync($form_collection = null, string $contentType = self::contentTypes['uploadRoomLogo'][0])
    {
        return $this->uploadRoomLogoAsyncWithHttpInfo($form_collection, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadRoomLogoAsyncWithHttpInfo
     *
     * Upload a room logo image
     *
     * REST API Reference for uploadRoomLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/upload-room-logo/
     *
     * @param  \OpenAPI\Client\Model\KeyValuePairStringStringValues[]|null $form_collection The image data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadRoomLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadRoomLogoAsyncWithHttpInfo($form_collection = null, string $contentType = self::contentTypes['uploadRoomLogo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\UploadResultWrapper';
        $request = $this->uploadRoomLogoRequest($form_collection, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadRoomLogo'
     *
     * @param  \OpenAPI\Client\Model\KeyValuePairStringStringValues[]|null $form_collection The image data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadRoomLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadRoomLogoRequest($form_collection = null, string $contentType = self::contentTypes['uploadRoomLogo'][0])
    {



        $resourcePath = '/api/2.0/files/logos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'form_collection' => $form_collection,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
