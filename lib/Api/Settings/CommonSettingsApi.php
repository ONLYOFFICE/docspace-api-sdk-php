<?php
/*
 * (c) Copyright Ascensio System SIA 2025
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * OnlyOffice/DocSpaceApiSdk
 *
 * A simple PHP SDK for integrating with the ONLYOFFICE DocSpace API
 *
 * The version of the OpenAPI document: 4.0.0
 * Contact: support@onlyoffice.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.14.0
 */


namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 *  Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CommonSettingsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'closeAdminHelper' => [
            'application/json',
        ],
        'completeWizard' => [
            'application/json',
        ],
        'configureDeepLink' => [
            'application/json',
        ],
        'deletePortalColorTheme' => [
            'application/json',
        ],
        'getDeepLinkSettings' => [
            'application/json',
        ],
        'getPaymentSettings' => [
            'application/json',
        ],
        'getPortalColorTheme' => [
            'application/json',
        ],
        'getPortalHostname' => [
            'application/json',
        ],
        'getPortalLogo' => [
            'application/json',
        ],
        'getPortalSettings' => [
            'application/json',
        ],
        'getSocketSettings' => [
            'application/json',
        ],
        'getSupportedCultures' => [
            'application/json',
        ],
        'getTenantUserInvitationSettings' => [
            'application/json',
        ],
        'getTimeZones' => [
            'application/json',
        ],
        'saveDnsSettings' => [
            'application/json',
        ],
        'saveMailDomainSettings' => [
            'application/json',
        ],
        'savePortalColorTheme' => [
            'application/json',
        ],
        'updateEmailActivationSettings' => [
            'application/json',
        ],
        'updateInvitationSettings' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }


    /**
     * Operation closeAdminHelper
     *
     * Close the admin helper
     *
     * REST API Reference for closeAdminHelper Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/close-admin-helper/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeAdminHelper'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function closeAdminHelper(string $contentType = self::contentTypes['closeAdminHelper'][0])
    {
        $this->closeAdminHelperWithHttpInfo($contentType);
    }

    /**
     * Operation closeAdminHelperWithHttpInfo
     *
     * Close the admin helper
     *
     * REST API Reference for closeAdminHelper Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/close-admin-helper/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeAdminHelper'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function closeAdminHelperWithHttpInfo(string $contentType = self::contentTypes['closeAdminHelper'][0])
    {
        $request = $this->closeAdminHelperRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
        

            throw $e;
        }
    }

    /**
     * Operation closeAdminHelperAsync
     *
     * Close the admin helper
     *
     * REST API Reference for closeAdminHelper Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/close-admin-helper/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeAdminHelper'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeAdminHelperAsync(string $contentType = self::contentTypes['closeAdminHelper'][0])
    {
        return $this->closeAdminHelperAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation closeAdminHelperAsyncWithHttpInfo
     *
     * Close the admin helper
     *
     * REST API Reference for closeAdminHelper Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/close-admin-helper/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeAdminHelper'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function closeAdminHelperAsyncWithHttpInfo(string $contentType = self::contentTypes['closeAdminHelper'][0])
    {
        $returnType = '';
        $request = $this->closeAdminHelperRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'closeAdminHelper'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['closeAdminHelper'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function closeAdminHelperRequest(string $contentType = self::contentTypes['closeAdminHelper'][0])
    {


        $resourcePath = '/api/2.0/settings/closeadminhelper';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation completeWizard
     *
     * Complete the Wizard settings
     *
     * REST API Reference for completeWizard Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/complete-wizard/
     *
     * @param  \OpenAPI\Client\Model\WizardRequestsDto|null $wizard_requests_dto wizard_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeWizard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\WizardSettingsWrapper
     */
    public function completeWizard($wizard_requests_dto = null, string $contentType = self::contentTypes['completeWizard'][0])
    {
        list($response) = $this->completeWizardWithHttpInfo($wizard_requests_dto, $contentType);
        return $response;
    }

    /**
     * Operation completeWizardWithHttpInfo
     *
     * Complete the Wizard settings
     *
     * REST API Reference for completeWizard Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/complete-wizard/
     *
     * @param  \OpenAPI\Client\Model\WizardRequestsDto|null $wizard_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeWizard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\WizardSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function completeWizardWithHttpInfo($wizard_requests_dto = null, string $contentType = self::contentTypes['completeWizard'][0])
    {
        $request = $this->completeWizardRequest($wizard_requests_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\WizardSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\WizardSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\WizardSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation completeWizardAsync
     *
     * Complete the Wizard settings
     *
     * REST API Reference for completeWizard Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/complete-wizard/
     *
     * @param  \OpenAPI\Client\Model\WizardRequestsDto|null $wizard_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeWizard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeWizardAsync($wizard_requests_dto = null, string $contentType = self::contentTypes['completeWizard'][0])
    {
        return $this->completeWizardAsyncWithHttpInfo($wizard_requests_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation completeWizardAsyncWithHttpInfo
     *
     * Complete the Wizard settings
     *
     * REST API Reference for completeWizard Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/complete-wizard/
     *
     * @param  \OpenAPI\Client\Model\WizardRequestsDto|null $wizard_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeWizard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeWizardAsyncWithHttpInfo($wizard_requests_dto = null, string $contentType = self::contentTypes['completeWizard'][0])
    {
        $returnType = '\OpenAPI\Client\Model\WizardSettingsWrapper';
        $request = $this->completeWizardRequest($wizard_requests_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'completeWizard'
     *
     * @param  \OpenAPI\Client\Model\WizardRequestsDto|null $wizard_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['completeWizard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function completeWizardRequest($wizard_requests_dto = null, string $contentType = self::contentTypes['completeWizard'][0])
    {



        $resourcePath = '/api/2.0/settings/wizard/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($wizard_requests_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($wizard_requests_dto));
            } else {
                $httpBody = $wizard_requests_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation configureDeepLink
     *
     * Configure the deep link settings
     *
     * REST API Reference for configureDeepLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/configure-deep-link/
     *
     * @param  \OpenAPI\Client\Model\DeepLinkConfigurationRequestsDto|null $deep_link_configuration_requests_dto deep_link_configuration_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['configureDeepLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper
     */
    public function configureDeepLink($deep_link_configuration_requests_dto = null, string $contentType = self::contentTypes['configureDeepLink'][0])
    {
        list($response) = $this->configureDeepLinkWithHttpInfo($deep_link_configuration_requests_dto, $contentType);
        return $response;
    }

    /**
     * Operation configureDeepLinkWithHttpInfo
     *
     * Configure the deep link settings
     *
     * REST API Reference for configureDeepLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/configure-deep-link/
     *
     * @param  \OpenAPI\Client\Model\DeepLinkConfigurationRequestsDto|null $deep_link_configuration_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['configureDeepLink'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function configureDeepLinkWithHttpInfo($deep_link_configuration_requests_dto = null, string $contentType = self::contentTypes['configureDeepLink'][0])
    {
        $request = $this->configureDeepLinkRequest($deep_link_configuration_requests_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation configureDeepLinkAsync
     *
     * Configure the deep link settings
     *
     * REST API Reference for configureDeepLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/configure-deep-link/
     *
     * @param  \OpenAPI\Client\Model\DeepLinkConfigurationRequestsDto|null $deep_link_configuration_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['configureDeepLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configureDeepLinkAsync($deep_link_configuration_requests_dto = null, string $contentType = self::contentTypes['configureDeepLink'][0])
    {
        return $this->configureDeepLinkAsyncWithHttpInfo($deep_link_configuration_requests_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation configureDeepLinkAsyncWithHttpInfo
     *
     * Configure the deep link settings
     *
     * REST API Reference for configureDeepLink Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/configure-deep-link/
     *
     * @param  \OpenAPI\Client\Model\DeepLinkConfigurationRequestsDto|null $deep_link_configuration_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['configureDeepLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function configureDeepLinkAsyncWithHttpInfo($deep_link_configuration_requests_dto = null, string $contentType = self::contentTypes['configureDeepLink'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper';
        $request = $this->configureDeepLinkRequest($deep_link_configuration_requests_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'configureDeepLink'
     *
     * @param  \OpenAPI\Client\Model\DeepLinkConfigurationRequestsDto|null $deep_link_configuration_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['configureDeepLink'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function configureDeepLinkRequest($deep_link_configuration_requests_dto = null, string $contentType = self::contentTypes['configureDeepLink'][0])
    {



        $resourcePath = '/api/2.0/settings/deeplink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($deep_link_configuration_requests_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($deep_link_configuration_requests_dto));
            } else {
                $httpBody = $deep_link_configuration_requests_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePortalColorTheme
     *
     * Delete a color theme
     *
     * REST API Reference for deletePortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-portal-color-theme/
     *
     * @param  int $id The ID of the portal theme to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomColorThemesSettingsWrapper
     */
    public function deletePortalColorTheme($id, string $contentType = self::contentTypes['deletePortalColorTheme'][0])
    {
        list($response) = $this->deletePortalColorThemeWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation deletePortalColorThemeWithHttpInfo
     *
     * Delete a color theme
     *
     * REST API Reference for deletePortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-portal-color-theme/
     *
     * @param  int $id The ID of the portal theme to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomColorThemesSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePortalColorThemeWithHttpInfo($id, string $contentType = self::contentTypes['deletePortalColorTheme'][0])
    {
        $request = $this->deletePortalColorThemeRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation deletePortalColorThemeAsync
     *
     * Delete a color theme
     *
     * REST API Reference for deletePortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-portal-color-theme/
     *
     * @param  int $id The ID of the portal theme to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePortalColorThemeAsync($id, string $contentType = self::contentTypes['deletePortalColorTheme'][0])
    {
        return $this->deletePortalColorThemeAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePortalColorThemeAsyncWithHttpInfo
     *
     * Delete a color theme
     *
     * REST API Reference for deletePortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/delete-portal-color-theme/
     *
     * @param  int $id The ID of the portal theme to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePortalColorThemeAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deletePortalColorTheme'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper';
        $request = $this->deletePortalColorThemeRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePortalColorTheme'
     *
     * @param  int $id The ID of the portal theme to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deletePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deletePortalColorThemeRequest($id, string $contentType = self::contentTypes['deletePortalColorTheme'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deletePortalColorTheme'
            );
        }


        $resourcePath = '/api/2.0/settings/colortheme';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeepLinkSettings
     *
     * Get the deep link settings
     *
     * REST API Reference for getDeepLinkSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-deep-link-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeepLinkSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper
     */
    public function getDeepLinkSettings(string $contentType = self::contentTypes['getDeepLinkSettings'][0])
    {
        list($response) = $this->getDeepLinkSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getDeepLinkSettingsWithHttpInfo
     *
     * Get the deep link settings
     *
     * REST API Reference for getDeepLinkSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-deep-link-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeepLinkSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeepLinkSettingsWithHttpInfo(string $contentType = self::contentTypes['getDeepLinkSettings'][0])
    {
        $request = $this->getDeepLinkSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getDeepLinkSettingsAsync
     *
     * Get the deep link settings
     *
     * REST API Reference for getDeepLinkSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-deep-link-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeepLinkSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeepLinkSettingsAsync(string $contentType = self::contentTypes['getDeepLinkSettings'][0])
    {
        return $this->getDeepLinkSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeepLinkSettingsAsyncWithHttpInfo
     *
     * Get the deep link settings
     *
     * REST API Reference for getDeepLinkSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-deep-link-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeepLinkSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeepLinkSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['getDeepLinkSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TenantDeepLinkSettingsWrapper';
        $request = $this->getDeepLinkSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeepLinkSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getDeepLinkSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getDeepLinkSettingsRequest(string $contentType = self::contentTypes['getDeepLinkSettings'][0])
    {


        $resourcePath = '/api/2.0/settings/deeplink';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPaymentSettings
     *
     * Get the payment settings
     *
     * REST API Reference for getPaymentSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-payment-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PaymentSettingsWrapper
     */
    public function getPaymentSettings(string $contentType = self::contentTypes['getPaymentSettings'][0])
    {
        list($response) = $this->getPaymentSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getPaymentSettingsWithHttpInfo
     *
     * Get the payment settings
     *
     * REST API Reference for getPaymentSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-payment-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PaymentSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPaymentSettingsWithHttpInfo(string $contentType = self::contentTypes['getPaymentSettings'][0])
    {
        $request = $this->getPaymentSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PaymentSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PaymentSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PaymentSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPaymentSettingsAsync
     *
     * Get the payment settings
     *
     * REST API Reference for getPaymentSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-payment-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentSettingsAsync(string $contentType = self::contentTypes['getPaymentSettings'][0])
    {
        return $this->getPaymentSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPaymentSettingsAsyncWithHttpInfo
     *
     * Get the payment settings
     *
     * REST API Reference for getPaymentSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-payment-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPaymentSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['getPaymentSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PaymentSettingsWrapper';
        $request = $this->getPaymentSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPaymentSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPaymentSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPaymentSettingsRequest(string $contentType = self::contentTypes['getPaymentSettings'][0])
    {


        $resourcePath = '/api/2.0/settings/payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPortalColorTheme
     *
     * Get a color theme
     *
     * REST API Reference for getPortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-color-theme/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalColorTheme'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomColorThemesSettingsWrapper
     */
    public function getPortalColorTheme(string $contentType = self::contentTypes['getPortalColorTheme'][0])
    {
        list($response) = $this->getPortalColorThemeWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getPortalColorThemeWithHttpInfo
     *
     * Get a color theme
     *
     * REST API Reference for getPortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-color-theme/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalColorTheme'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomColorThemesSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortalColorThemeWithHttpInfo(string $contentType = self::contentTypes['getPortalColorTheme'][0])
    {
        $request = $this->getPortalColorThemeRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPortalColorThemeAsync
     *
     * Get a color theme
     *
     * REST API Reference for getPortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-color-theme/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalColorTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortalColorThemeAsync(string $contentType = self::contentTypes['getPortalColorTheme'][0])
    {
        return $this->getPortalColorThemeAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortalColorThemeAsyncWithHttpInfo
     *
     * Get a color theme
     *
     * REST API Reference for getPortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-color-theme/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalColorTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortalColorThemeAsyncWithHttpInfo(string $contentType = self::contentTypes['getPortalColorTheme'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper';
        $request = $this->getPortalColorThemeRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortalColorTheme'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalColorTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortalColorThemeRequest(string $contentType = self::contentTypes['getPortalColorTheme'][0])
    {


        $resourcePath = '/api/2.0/settings/colortheme';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPortalHostname
     *
     * Get hostname
     *
     * REST API Reference for getPortalHostname Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-hostname/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalHostname'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectWrapper
     */
    public function getPortalHostname(string $contentType = self::contentTypes['getPortalHostname'][0])
    {
        list($response) = $this->getPortalHostnameWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getPortalHostnameWithHttpInfo
     *
     * Get hostname
     *
     * REST API Reference for getPortalHostname Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-hostname/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalHostname'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortalHostnameWithHttpInfo(string $contentType = self::contentTypes['getPortalHostname'][0])
    {
        $request = $this->getPortalHostnameRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ObjectWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPortalHostnameAsync
     *
     * Get hostname
     *
     * REST API Reference for getPortalHostname Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-hostname/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalHostname'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortalHostnameAsync(string $contentType = self::contentTypes['getPortalHostname'][0])
    {
        return $this->getPortalHostnameAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortalHostnameAsyncWithHttpInfo
     *
     * Get hostname
     *
     * REST API Reference for getPortalHostname Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-hostname/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalHostname'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortalHostnameAsyncWithHttpInfo(string $contentType = self::contentTypes['getPortalHostname'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectWrapper';
        $request = $this->getPortalHostnameRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortalHostname'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalHostname'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortalHostnameRequest(string $contentType = self::contentTypes['getPortalHostname'][0])
    {


        $resourcePath = '/api/2.0/settings/machine';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPortalLogo
     *
     * Get a portal logo
     *
     * REST API Reference for getPortalLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-logo/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalLogo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringWrapper
     */
    public function getPortalLogo(string $contentType = self::contentTypes['getPortalLogo'][0])
    {
        list($response) = $this->getPortalLogoWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getPortalLogoWithHttpInfo
     *
     * Get a portal logo
     *
     * REST API Reference for getPortalLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-logo/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalLogo'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortalLogoWithHttpInfo(string $contentType = self::contentTypes['getPortalLogo'][0])
    {
        $request = $this->getPortalLogoRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPortalLogoAsync
     *
     * Get a portal logo
     *
     * REST API Reference for getPortalLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-logo/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortalLogoAsync(string $contentType = self::contentTypes['getPortalLogo'][0])
    {
        return $this->getPortalLogoAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortalLogoAsyncWithHttpInfo
     *
     * Get a portal logo
     *
     * REST API Reference for getPortalLogo Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-logo/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortalLogoAsyncWithHttpInfo(string $contentType = self::contentTypes['getPortalLogo'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StringWrapper';
        $request = $this->getPortalLogoRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortalLogo'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalLogo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortalLogoRequest(string $contentType = self::contentTypes['getPortalLogo'][0])
    {


        $resourcePath = '/api/2.0/settings/logo';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPortalSettings
     *
     * Get the portal settings
     *
     * REST API Reference for getPortalSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-settings/
     *
     * @param  bool|null $withpassword Specifies whether to include the password hashing configuration in the response. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SettingsWrapper
     */
    public function getPortalSettings($withpassword = null, string $contentType = self::contentTypes['getPortalSettings'][0])
    {
        list($response) = $this->getPortalSettingsWithHttpInfo($withpassword, $contentType);
        return $response;
    }

    /**
     * Operation getPortalSettingsWithHttpInfo
     *
     * Get the portal settings
     *
     * REST API Reference for getPortalSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-settings/
     *
     * @param  bool|null $withpassword Specifies whether to include the password hashing configuration in the response. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPortalSettingsWithHttpInfo($withpassword = null, string $contentType = self::contentTypes['getPortalSettings'][0])
    {
        $request = $this->getPortalSettingsRequest($withpassword, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getPortalSettingsAsync
     *
     * Get the portal settings
     *
     * REST API Reference for getPortalSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-settings/
     *
     * @param  bool|null $withpassword Specifies whether to include the password hashing configuration in the response. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortalSettingsAsync($withpassword = null, string $contentType = self::contentTypes['getPortalSettings'][0])
    {
        return $this->getPortalSettingsAsyncWithHttpInfo($withpassword, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPortalSettingsAsyncWithHttpInfo
     *
     * Get the portal settings
     *
     * REST API Reference for getPortalSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-portal-settings/
     *
     * @param  bool|null $withpassword Specifies whether to include the password hashing configuration in the response. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPortalSettingsAsyncWithHttpInfo($withpassword = null, string $contentType = self::contentTypes['getPortalSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SettingsWrapper';
        $request = $this->getPortalSettingsRequest($withpassword, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPortalSettings'
     *
     * @param  bool|null $withpassword Specifies whether to include the password hashing configuration in the response. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPortalSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPortalSettingsRequest($withpassword = null, string $contentType = self::contentTypes['getPortalSettings'][0])
    {



        $resourcePath = '/api/2.0/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $withpassword,
            'withpassword', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSocketSettings
     *
     * Get the socket settings
     *
     * REST API Reference for getSocketSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-socket-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSocketSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ObjectWrapper
     */
    public function getSocketSettings(string $contentType = self::contentTypes['getSocketSettings'][0])
    {
        list($response) = $this->getSocketSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getSocketSettingsWithHttpInfo
     *
     * Get the socket settings
     *
     * REST API Reference for getSocketSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-socket-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSocketSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ObjectWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSocketSettingsWithHttpInfo(string $contentType = self::contentTypes['getSocketSettings'][0])
    {
        $request = $this->getSocketSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ObjectWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ObjectWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSocketSettingsAsync
     *
     * Get the socket settings
     *
     * REST API Reference for getSocketSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-socket-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSocketSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSocketSettingsAsync(string $contentType = self::contentTypes['getSocketSettings'][0])
    {
        return $this->getSocketSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSocketSettingsAsyncWithHttpInfo
     *
     * Get the socket settings
     *
     * REST API Reference for getSocketSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-socket-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSocketSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSocketSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['getSocketSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ObjectWrapper';
        $request = $this->getSocketSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSocketSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSocketSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSocketSettingsRequest(string $contentType = self::contentTypes['getSocketSettings'][0])
    {


        $resourcePath = '/api/2.0/settings/socket';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSupportedCultures
     *
     * Get supported languages
     *
     * REST API Reference for getSupportedCultures Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-supported-cultures/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSupportedCultures'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\STRINGArrayWrapper
     */
    public function getSupportedCultures(string $contentType = self::contentTypes['getSupportedCultures'][0])
    {
        list($response) = $this->getSupportedCulturesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getSupportedCulturesWithHttpInfo
     *
     * Get supported languages
     *
     * REST API Reference for getSupportedCultures Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-supported-cultures/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSupportedCultures'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\STRINGArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSupportedCulturesWithHttpInfo(string $contentType = self::contentTypes['getSupportedCultures'][0])
    {
        $request = $this->getSupportedCulturesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\STRINGArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\STRINGArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\STRINGArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getSupportedCulturesAsync
     *
     * Get supported languages
     *
     * REST API Reference for getSupportedCultures Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-supported-cultures/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSupportedCultures'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSupportedCulturesAsync(string $contentType = self::contentTypes['getSupportedCultures'][0])
    {
        return $this->getSupportedCulturesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSupportedCulturesAsyncWithHttpInfo
     *
     * Get supported languages
     *
     * REST API Reference for getSupportedCultures Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-supported-cultures/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSupportedCultures'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSupportedCulturesAsyncWithHttpInfo(string $contentType = self::contentTypes['getSupportedCultures'][0])
    {
        $returnType = '\OpenAPI\Client\Model\STRINGArrayWrapper';
        $request = $this->getSupportedCulturesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSupportedCultures'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSupportedCultures'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSupportedCulturesRequest(string $contentType = self::contentTypes['getSupportedCultures'][0])
    {


        $resourcePath = '/api/2.0/settings/cultures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTenantUserInvitationSettings
     *
     * Get the user invitation settings
     *
     * REST API Reference for getTenantUserInvitationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-tenant-user-invitation-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantUserInvitationSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper
     */
    public function getTenantUserInvitationSettings(string $contentType = self::contentTypes['getTenantUserInvitationSettings'][0])
    {
        list($response) = $this->getTenantUserInvitationSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTenantUserInvitationSettingsWithHttpInfo
     *
     * Get the user invitation settings
     *
     * REST API Reference for getTenantUserInvitationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-tenant-user-invitation-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantUserInvitationSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTenantUserInvitationSettingsWithHttpInfo(string $contentType = self::contentTypes['getTenantUserInvitationSettings'][0])
    {
        $request = $this->getTenantUserInvitationSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTenantUserInvitationSettingsAsync
     *
     * Get the user invitation settings
     *
     * REST API Reference for getTenantUserInvitationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-tenant-user-invitation-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantUserInvitationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenantUserInvitationSettingsAsync(string $contentType = self::contentTypes['getTenantUserInvitationSettings'][0])
    {
        return $this->getTenantUserInvitationSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTenantUserInvitationSettingsAsyncWithHttpInfo
     *
     * Get the user invitation settings
     *
     * REST API Reference for getTenantUserInvitationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-tenant-user-invitation-settings/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantUserInvitationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTenantUserInvitationSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['getTenantUserInvitationSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper';
        $request = $this->getTenantUserInvitationSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTenantUserInvitationSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTenantUserInvitationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTenantUserInvitationSettingsRequest(string $contentType = self::contentTypes['getTenantUserInvitationSettings'][0])
    {


        $resourcePath = '/api/2.0/settings/invitationsettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTimeZones
     *
     * Get time zones
     *
     * REST API Reference for getTimeZones Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-time-zones/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimeZones'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TimezonesRequestsArrayWrapper
     */
    public function getTimeZones(string $contentType = self::contentTypes['getTimeZones'][0])
    {
        list($response) = $this->getTimeZonesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTimeZonesWithHttpInfo
     *
     * Get time zones
     *
     * REST API Reference for getTimeZones Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-time-zones/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimeZones'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TimezonesRequestsArrayWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTimeZonesWithHttpInfo(string $contentType = self::contentTypes['getTimeZones'][0])
    {
        $request = $this->getTimeZonesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TimezonesRequestsArrayWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TimezonesRequestsArrayWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TimezonesRequestsArrayWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getTimeZonesAsync
     *
     * Get time zones
     *
     * REST API Reference for getTimeZones Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-time-zones/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimeZones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimeZonesAsync(string $contentType = self::contentTypes['getTimeZones'][0])
    {
        return $this->getTimeZonesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTimeZonesAsyncWithHttpInfo
     *
     * Get time zones
     *
     * REST API Reference for getTimeZones Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/get-time-zones/
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimeZones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTimeZonesAsyncWithHttpInfo(string $contentType = self::contentTypes['getTimeZones'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TimezonesRequestsArrayWrapper';
        $request = $this->getTimeZonesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTimeZones'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTimeZones'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTimeZonesRequest(string $contentType = self::contentTypes['getTimeZones'][0])
    {


        $resourcePath = '/api/2.0/settings/timezones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveDnsSettings
     *
     * Save the DNS settings
     *
     * REST API Reference for saveDnsSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-dns-settings/
     *
     * @param  \OpenAPI\Client\Model\DnsSettingsRequestsDto|null $dns_settings_requests_dto dns_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveDnsSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringWrapper
     */
    public function saveDnsSettings($dns_settings_requests_dto = null, string $contentType = self::contentTypes['saveDnsSettings'][0])
    {
        list($response) = $this->saveDnsSettingsWithHttpInfo($dns_settings_requests_dto, $contentType);
        return $response;
    }

    /**
     * Operation saveDnsSettingsWithHttpInfo
     *
     * Save the DNS settings
     *
     * REST API Reference for saveDnsSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-dns-settings/
     *
     * @param  \OpenAPI\Client\Model\DnsSettingsRequestsDto|null $dns_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveDnsSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveDnsSettingsWithHttpInfo($dns_settings_requests_dto = null, string $contentType = self::contentTypes['saveDnsSettings'][0])
    {
        $request = $this->saveDnsSettingsRequest($dns_settings_requests_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation saveDnsSettingsAsync
     *
     * Save the DNS settings
     *
     * REST API Reference for saveDnsSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-dns-settings/
     *
     * @param  \OpenAPI\Client\Model\DnsSettingsRequestsDto|null $dns_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveDnsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveDnsSettingsAsync($dns_settings_requests_dto = null, string $contentType = self::contentTypes['saveDnsSettings'][0])
    {
        return $this->saveDnsSettingsAsyncWithHttpInfo($dns_settings_requests_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveDnsSettingsAsyncWithHttpInfo
     *
     * Save the DNS settings
     *
     * REST API Reference for saveDnsSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-dns-settings/
     *
     * @param  \OpenAPI\Client\Model\DnsSettingsRequestsDto|null $dns_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveDnsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveDnsSettingsAsyncWithHttpInfo($dns_settings_requests_dto = null, string $contentType = self::contentTypes['saveDnsSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StringWrapper';
        $request = $this->saveDnsSettingsRequest($dns_settings_requests_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveDnsSettings'
     *
     * @param  \OpenAPI\Client\Model\DnsSettingsRequestsDto|null $dns_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveDnsSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function saveDnsSettingsRequest($dns_settings_requests_dto = null, string $contentType = self::contentTypes['saveDnsSettings'][0])
    {



        $resourcePath = '/api/2.0/settings/dns';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($dns_settings_requests_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($dns_settings_requests_dto));
            } else {
                $httpBody = $dns_settings_requests_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation saveMailDomainSettings
     *
     * Save the mail domain settings
     *
     * REST API Reference for saveMailDomainSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-mail-domain-settings/
     *
     * @param  \OpenAPI\Client\Model\MailDomainSettingsRequestsDto|null $mail_domain_settings_requests_dto mail_domain_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveMailDomainSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\StringWrapper
     */
    public function saveMailDomainSettings($mail_domain_settings_requests_dto = null, string $contentType = self::contentTypes['saveMailDomainSettings'][0])
    {
        list($response) = $this->saveMailDomainSettingsWithHttpInfo($mail_domain_settings_requests_dto, $contentType);
        return $response;
    }

    /**
     * Operation saveMailDomainSettingsWithHttpInfo
     *
     * Save the mail domain settings
     *
     * REST API Reference for saveMailDomainSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-mail-domain-settings/
     *
     * @param  \OpenAPI\Client\Model\MailDomainSettingsRequestsDto|null $mail_domain_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveMailDomainSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\StringWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function saveMailDomainSettingsWithHttpInfo($mail_domain_settings_requests_dto = null, string $contentType = self::contentTypes['saveMailDomainSettings'][0])
    {
        $request = $this->saveMailDomainSettingsRequest($mail_domain_settings_requests_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\StringWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\StringWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\StringWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation saveMailDomainSettingsAsync
     *
     * Save the mail domain settings
     *
     * REST API Reference for saveMailDomainSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-mail-domain-settings/
     *
     * @param  \OpenAPI\Client\Model\MailDomainSettingsRequestsDto|null $mail_domain_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveMailDomainSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveMailDomainSettingsAsync($mail_domain_settings_requests_dto = null, string $contentType = self::contentTypes['saveMailDomainSettings'][0])
    {
        return $this->saveMailDomainSettingsAsyncWithHttpInfo($mail_domain_settings_requests_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation saveMailDomainSettingsAsyncWithHttpInfo
     *
     * Save the mail domain settings
     *
     * REST API Reference for saveMailDomainSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-mail-domain-settings/
     *
     * @param  \OpenAPI\Client\Model\MailDomainSettingsRequestsDto|null $mail_domain_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveMailDomainSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function saveMailDomainSettingsAsyncWithHttpInfo($mail_domain_settings_requests_dto = null, string $contentType = self::contentTypes['saveMailDomainSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\StringWrapper';
        $request = $this->saveMailDomainSettingsRequest($mail_domain_settings_requests_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'saveMailDomainSettings'
     *
     * @param  \OpenAPI\Client\Model\MailDomainSettingsRequestsDto|null $mail_domain_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['saveMailDomainSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function saveMailDomainSettingsRequest($mail_domain_settings_requests_dto = null, string $contentType = self::contentTypes['saveMailDomainSettings'][0])
    {



        $resourcePath = '/api/2.0/settings/maildomainsettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($mail_domain_settings_requests_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($mail_domain_settings_requests_dto));
            } else {
                $httpBody = $mail_domain_settings_requests_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation savePortalColorTheme
     *
     * Save a color theme
     *
     * REST API Reference for savePortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-portal-color-theme/
     *
     * @param  \OpenAPI\Client\Model\CustomColorThemesSettingsRequestsDto|null $custom_color_themes_settings_requests_dto custom_color_themes_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomColorThemesSettingsWrapper
     */
    public function savePortalColorTheme($custom_color_themes_settings_requests_dto = null, string $contentType = self::contentTypes['savePortalColorTheme'][0])
    {
        list($response) = $this->savePortalColorThemeWithHttpInfo($custom_color_themes_settings_requests_dto, $contentType);
        return $response;
    }

    /**
     * Operation savePortalColorThemeWithHttpInfo
     *
     * Save a color theme
     *
     * REST API Reference for savePortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-portal-color-theme/
     *
     * @param  \OpenAPI\Client\Model\CustomColorThemesSettingsRequestsDto|null $custom_color_themes_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomColorThemesSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function savePortalColorThemeWithHttpInfo($custom_color_themes_settings_requests_dto = null, string $contentType = self::contentTypes['savePortalColorTheme'][0])
    {
        $request = $this->savePortalColorThemeRequest($custom_color_themes_settings_requests_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation savePortalColorThemeAsync
     *
     * Save a color theme
     *
     * REST API Reference for savePortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-portal-color-theme/
     *
     * @param  \OpenAPI\Client\Model\CustomColorThemesSettingsRequestsDto|null $custom_color_themes_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function savePortalColorThemeAsync($custom_color_themes_settings_requests_dto = null, string $contentType = self::contentTypes['savePortalColorTheme'][0])
    {
        return $this->savePortalColorThemeAsyncWithHttpInfo($custom_color_themes_settings_requests_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation savePortalColorThemeAsyncWithHttpInfo
     *
     * Save a color theme
     *
     * REST API Reference for savePortalColorTheme Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/save-portal-color-theme/
     *
     * @param  \OpenAPI\Client\Model\CustomColorThemesSettingsRequestsDto|null $custom_color_themes_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function savePortalColorThemeAsyncWithHttpInfo($custom_color_themes_settings_requests_dto = null, string $contentType = self::contentTypes['savePortalColorTheme'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomColorThemesSettingsWrapper';
        $request = $this->savePortalColorThemeRequest($custom_color_themes_settings_requests_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'savePortalColorTheme'
     *
     * @param  \OpenAPI\Client\Model\CustomColorThemesSettingsRequestsDto|null $custom_color_themes_settings_requests_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['savePortalColorTheme'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function savePortalColorThemeRequest($custom_color_themes_settings_requests_dto = null, string $contentType = self::contentTypes['savePortalColorTheme'][0])
    {



        $resourcePath = '/api/2.0/settings/colortheme';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_color_themes_settings_requests_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_color_themes_settings_requests_dto));
            } else {
                $httpBody = $custom_color_themes_settings_requests_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateEmailActivationSettings
     *
     * Update the email activation settings
     *
     * REST API Reference for updateEmailActivationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-email-activation-settings/
     *
     * @param  \OpenAPI\Client\Model\EmailActivationSettings|null $email_activation_settings email_activation_settings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmailActivationSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\EmailActivationSettingsWrapper
     */
    public function updateEmailActivationSettings($email_activation_settings = null, string $contentType = self::contentTypes['updateEmailActivationSettings'][0])
    {
        list($response) = $this->updateEmailActivationSettingsWithHttpInfo($email_activation_settings, $contentType);
        return $response;
    }

    /**
     * Operation updateEmailActivationSettingsWithHttpInfo
     *
     * Update the email activation settings
     *
     * REST API Reference for updateEmailActivationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-email-activation-settings/
     *
     * @param  \OpenAPI\Client\Model\EmailActivationSettings|null $email_activation_settings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmailActivationSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\EmailActivationSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateEmailActivationSettingsWithHttpInfo($email_activation_settings = null, string $contentType = self::contentTypes['updateEmailActivationSettings'][0])
    {
        $request = $this->updateEmailActivationSettingsRequest($email_activation_settings, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\EmailActivationSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\EmailActivationSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\EmailActivationSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateEmailActivationSettingsAsync
     *
     * Update the email activation settings
     *
     * REST API Reference for updateEmailActivationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-email-activation-settings/
     *
     * @param  \OpenAPI\Client\Model\EmailActivationSettings|null $email_activation_settings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmailActivationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailActivationSettingsAsync($email_activation_settings = null, string $contentType = self::contentTypes['updateEmailActivationSettings'][0])
    {
        return $this->updateEmailActivationSettingsAsyncWithHttpInfo($email_activation_settings, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateEmailActivationSettingsAsyncWithHttpInfo
     *
     * Update the email activation settings
     *
     * REST API Reference for updateEmailActivationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-email-activation-settings/
     *
     * @param  \OpenAPI\Client\Model\EmailActivationSettings|null $email_activation_settings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmailActivationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateEmailActivationSettingsAsyncWithHttpInfo($email_activation_settings = null, string $contentType = self::contentTypes['updateEmailActivationSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\EmailActivationSettingsWrapper';
        $request = $this->updateEmailActivationSettingsRequest($email_activation_settings, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateEmailActivationSettings'
     *
     * @param  \OpenAPI\Client\Model\EmailActivationSettings|null $email_activation_settings (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateEmailActivationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateEmailActivationSettingsRequest($email_activation_settings = null, string $contentType = self::contentTypes['updateEmailActivationSettings'][0])
    {



        $resourcePath = '/api/2.0/settings/emailactivation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($email_activation_settings)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($email_activation_settings));
            } else {
                $httpBody = $email_activation_settings;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateInvitationSettings
     *
     * Update user invitation settings
     *
     * REST API Reference for updateInvitationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-invitation-settings/
     *
     * @param  \OpenAPI\Client\Model\TenantUserInvitationSettingsRequestDto|null $tenant_user_invitation_settings_request_dto tenant_user_invitation_settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvitationSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper
     */
    public function updateInvitationSettings($tenant_user_invitation_settings_request_dto = null, string $contentType = self::contentTypes['updateInvitationSettings'][0])
    {
        list($response) = $this->updateInvitationSettingsWithHttpInfo($tenant_user_invitation_settings_request_dto, $contentType);
        return $response;
    }

    /**
     * Operation updateInvitationSettingsWithHttpInfo
     *
     * Update user invitation settings
     *
     * REST API Reference for updateInvitationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-invitation-settings/
     *
     * @param  \OpenAPI\Client\Model\TenantUserInvitationSettingsRequestDto|null $tenant_user_invitation_settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvitationSettings'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInvitationSettingsWithHttpInfo($tenant_user_invitation_settings_request_dto = null, string $contentType = self::contentTypes['updateInvitationSettings'][0])
    {
        $request = $this->updateInvitationSettingsRequest($tenant_user_invitation_settings_request_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation updateInvitationSettingsAsync
     *
     * Update user invitation settings
     *
     * REST API Reference for updateInvitationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-invitation-settings/
     *
     * @param  \OpenAPI\Client\Model\TenantUserInvitationSettingsRequestDto|null $tenant_user_invitation_settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvitationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvitationSettingsAsync($tenant_user_invitation_settings_request_dto = null, string $contentType = self::contentTypes['updateInvitationSettings'][0])
    {
        return $this->updateInvitationSettingsAsyncWithHttpInfo($tenant_user_invitation_settings_request_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateInvitationSettingsAsyncWithHttpInfo
     *
     * Update user invitation settings
     *
     * REST API Reference for updateInvitationSettings Operation
     * @see https://api.onlyoffice.com/docspace/api-backend/usage-api/update-invitation-settings/
     *
     * @param  \OpenAPI\Client\Model\TenantUserInvitationSettingsRequestDto|null $tenant_user_invitation_settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvitationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvitationSettingsAsyncWithHttpInfo($tenant_user_invitation_settings_request_dto = null, string $contentType = self::contentTypes['updateInvitationSettings'][0])
    {
        $returnType = '\OpenAPI\Client\Model\TenantUserInvitationSettingsWrapper';
        $request = $this->updateInvitationSettingsRequest($tenant_user_invitation_settings_request_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateInvitationSettings'
     *
     * @param  \OpenAPI\Client\Model\TenantUserInvitationSettingsRequestDto|null $tenant_user_invitation_settings_request_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateInvitationSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateInvitationSettingsRequest($tenant_user_invitation_settings_request_dto = null, string $contentType = self::contentTypes['updateInvitationSettings'][0])
    {



        $resourcePath = '/api/2.0/settings/invitationsettings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tenant_user_invitation_settings_request_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tenant_user_invitation_settings_request_dto));
            } else {
                $httpBody = $tenant_user_invitation_settings_request_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires HTTP basic authentication
        if (!empty($this->config->getUsername()) || !(empty($this->config->getPassword()))) {
            $headers['Authorization'] = 'Basic ' . base64_encode($this->config->getUsername() . ":" . $this->config->getPassword());
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('ApiKeyBearer');
        if ($apiKey !== null) {
            $headers['ApiKeyBearer'] = $apiKey;
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('asc_auth_key');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
